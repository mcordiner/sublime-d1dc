        -:    0:Source:src/molinit.c
        -:    0:Graph:src/molinit.gcno
        -:    0:Data:src/molinit.gcda
        -:    0:Runs:1
        -:    1:/*
        -:    2: *  molinit.c
        -:    3: *  This file is part of LIME, the versatile line modeling engine
        -:    4: *
        -:    5: *  Copyright (C) 2006-2014 Christian Brinch
        -:    6: *  Copyright (C) 2015-2017 The LIME development team
        -:    7: *
        -:    8:TODO:
        -:    9:	- Clean up all the new messages which are going to dick with the stdout when curses are selected? (Sigh.)
        -:   10: */
        -:   11:
        -:   12:#include "lime.h"
        -:   13:
        -:   14:/*....................................................................*/
function readDummyCollPart called 2 returned 100% blocks executed 100%
        2:   15:void readDummyCollPart(FILE *fp, const int strLen){
        2:   16:  char string[strLen];
        2:   17:  int ntrans=0,ntemp=0,itemp,itrans,idummy,dummyLcu,dummyLcl;
        -:   18:  double dummyTemp,dummyDown;
        -:   19:
        -:   20:  /* Stops compiler warnings when -Wunused-variable */
        -:   21:  (void)dummyTemp;
        -:   22:  (void)dummyDown;
        -:   23:  (void)idummy;
        -:   24:  (void)dummyLcu;
        -:   25:  (void)dummyLcl;
        -:   26:  (void)string;
        -:   27:
        2:   28:  checkFgets(fgets(string, strLen, fp), "dcp 0");
call    0 returned 100%
call    1 returned 100%
        2:   29:  checkFscanf(fscanf(fp,"%d\n", &ntrans), 1, "dcp 1");
call    0 returned 100%
call    1 returned 100%
        2:   30:  checkFgets(fgets(string, strLen, fp), "dcp 2");
call    0 returned 100%
call    1 returned 100%
        2:   31:  checkFscanf(fscanf(fp,"%d\n", &ntemp), 1, "dcp 3");
call    0 returned 100%
call    1 returned 100%
        2:   32:  checkFgets(fgets(string, strLen, fp), "dcp 4");
call    0 returned 100%
call    1 returned 100%
        -:   33:
       37:   34:  for(itemp=0;itemp<ntemp;itemp++)
branch  0 taken 95%
branch  1 taken 5% (fallthrough)
       35:   35:    checkFscanf(fscanf(fp, "%lf", &dummyTemp), 1, "dcp 5");
call    0 returned 100%
call    1 returned 100%
        -:   36:
        2:   37:  checkFscanf(fscanf(fp,"\n"), 0, "dcp 6");
call    0 returned 100%
call    1 returned 100%
        2:   38:  checkFgets(fgets(string, strLen, fp), "dcp 7");
call    0 returned 100%
call    1 returned 100%
        -:   39:
      363:   40:  for(itrans=0;itrans<ntrans;itrans++){
branch  0 taken 99%
branch  1 taken 1% (fallthrough)
      361:   41:    checkFscanf(fscanf(fp, "%d %d %d", &idummy, &dummyLcu, &dummyLcl), 3, "dcp 8");
call    0 returned 100%
call    1 returned 100%
     8846:   42:    for(itemp=0;itemp<ntemp;itemp++){
branch  0 taken 96%
branch  1 taken 4% (fallthrough)
     8485:   43:      checkFscanf(fscanf(fp, "%lf", &dummyDown), 1, "dcp 9");
call    0 returned 100%
call    1 returned 100%
        -:   44:    }
      361:   45:    checkFscanf(fscanf(fp,"\n"), 0, "dcp 10");
call    0 returned 100%
call    1 returned 100%
        -:   46:  }
        2:   47:}
        -:   48:
        -:   49:/*....................................................................*/
        -:   50:void
function checkFirstLineMolDat called 2 returned 100% blocks executed 36%
        2:   51:checkFirstLineMolDat(FILE *fp, char *moldatfile){
        -:   52:  const int sizeI=200;
        2:   53:  char string[sizeI],message[STR_LEN_0];
        -:   54:  char *expectedLine="!MOLECULE";
        -:   55:  char *expectedLine2="! MOLECULE";
        -:   56:
        2:   57:  if(fgets(string, sizeI, fp)==NULL){
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:   58:    if(!silent){
branch  0 never executed
branch  1 never executed
    #####:   59:      sprintf(message, "Moldat file %s seems to be empty.", moldatfile);
    #####:   60:      bail_out(message);
call    0 never executed
        -:   61:    }
    #####:   62:exit(1);
call    0 never executed
        -:   63:  }
        -:   64:
       2*:   65:  if(strncmp(string, expectedLine, strlen(expectedLine))!=0 && strncmp(string, expectedLine2, strlen(expectedLine))!=0){
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
branch  2 never executed
branch  3 never executed
    #####:   66:    if(!silent){
branch  0 never executed
branch  1 never executed
    #####:   67:      sprintf(message, "Bad format first line of moldat file %s.", moldatfile);
    #####:   68:      bail_out(message);
call    0 never executed
        -:   69:    }
    #####:   70:exit(1);
call    0 never executed
        -:   71:  }
        2:   72:}
        -:   73:
        -:   74:/*....................................................................*/
function readMolData called 1 returned 100% blocks executed 60%
        1:   75:void readMolData(configInfo *par, molData *md, int **allUniqueCollPartIds, int *numUniqueCollPartsFound){
        -:   76:  /* NOTE! allUniqueCollPartIds is malloc'd in the present function, but not freed. The calling program must free it elsewhere.
        -:   77:  */
        1:   78:  int i,j,k,ilev,idummy,iline,numPartsAcceptedThisMol,ipart,collPartId=-1,itemp,itrans;
        -:   79:  double dummy;
        -:   80:  _Bool cpWasFoundInUserList,previousCpFound;
        -:   81:  const int sizeI=200;
        1:   82:  char string[sizeI],message[STR_LEN_0+1];
        -:   83:  FILE *fp;
        -:   84:
        -:   85:  /* Stops compiler warnings when -Wunused-variable */
        -:   86:  (void)idummy;
        -:   87:  (void)dummy;
        -:   88:
        1:   89:  *allUniqueCollPartIds = malloc(sizeof(**allUniqueCollPartIds)*MAX_N_COLL_PART);
        1:   90:  *numUniqueCollPartsFound = 0;
        -:   91:
        2:   92:  for(i=0;i<par->nSpecies;i++){
branch  0 taken 50%
branch  1 taken 50% (fallthrough)
        1:   93:    if((fp=fopen(par->moldatfile[i], "r"))==NULL) {
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:   94:      if(!silent) bail_out("Error opening molecular data file");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:   95:exit(1);
call    0 never executed
        -:   96:    }
        -:   97:
        1:   98:    checkFirstLineMolDat(fp, par->moldatfile[i]);
call    0 returned 100%
        -:   99:
        1:  100:    checkFgets(fgets(md[i].molName, 80, fp), "molName");
call    0 returned 100%
call    1 returned 100%
        1:  101:    md[i].molName[strcspn(md[i].molName, "\r\n")] = 0;
        1:  102:    checkFgets(fgets(string, sizeI, fp), "blank line");
call    0 returned 100%
call    1 returned 100%
        1:  103:    checkFscanf(fscanf(fp, "%lf\n", &md[i].amass), 1, "amass");
call    0 returned 100%
call    1 returned 100%
        1:  104:    checkFgets(fgets(string, sizeI, fp), "blank line");
call    0 returned 100%
call    1 returned 100%
        1:  105:    checkFscanf(fscanf(fp, "%d\n", &md[i].nlev), 1, "nlev");
call    0 returned 100%
call    1 returned 100%
        1:  106:    checkFgets(fgets(string, sizeI, fp), "blank line");
call    0 returned 100%
call    1 returned 100%
        -:  107:
        1:  108:    md[i].amass *= AMU;
        -:  109:
        1:  110:    md[i].eterm=malloc(sizeof(double)*md[i].nlev);
        1:  111:    md[i].gstat=malloc(sizeof(double)*md[i].nlev);
        -:  112:
        -:  113:    /* Read the level energies and statistical weights */
       27:  114:    for(ilev=0;ilev<md[i].nlev;ilev++){
branch  0 taken 96%
branch  1 taken 4% (fallthrough)
       26:  115:      checkFscanf(fscanf(fp, "%d %lf %lf", &idummy, &md[i].eterm[ilev], &md[i].gstat[ilev]), 3, "eterm, gstat");
call    0 returned 100%
call    1 returned 100%
       26:  116:      checkFgets(fgets(string, sizeI, fp), "blank line");
call    0 returned 100%
call    1 returned 100%
        -:  117:    }
        -:  118:
        -:  119:    /* Read the number of transitions and allocate array space */
        1:  120:    checkFgets(fgets(string, sizeI, fp), "blank line");
call    0 returned 100%
call    1 returned 100%
        1:  121:    checkFscanf(fscanf(fp, "%d\n", &md[i].nline), 1, "nline");
call    0 returned 100%
call    1 returned 100%
        1:  122:    checkFgets(fgets(string, sizeI, fp), "blank line");
call    0 returned 100%
call    1 returned 100%
        -:  123:
        1:  124:    md[i].lal     = malloc(sizeof(int)   *md[i].nline);
        1:  125:    md[i].lau     = malloc(sizeof(int)   *md[i].nline);
        1:  126:    md[i].aeinst  = malloc(sizeof(double)*md[i].nline);
        1:  127:    md[i].freq    = malloc(sizeof(double)*md[i].nline);
        1:  128:    md[i].beinstu = malloc(sizeof(double)*md[i].nline);
        1:  129:    md[i].beinstl = malloc(sizeof(double)*md[i].nline);
        -:  130:
        -:  131:    /* Read transitions, Einstein A, and frequencies */
       26:  132:    for(iline=0;iline<md[i].nline;iline++){
branch  0 taken 96%
branch  1 taken 4%
       25:  133:      checkFscanf(fscanf(fp, "%d %d %d %lf %lf %lf\n", &idummy, &md[i].lau[iline]\
call    0 returned 100%
       25:  134:        , &md[i].lal[iline], &md[i].aeinst[iline], &md[i].freq[iline], &dummy), 6, "lau, lal etc");
call    0 returned 100%
       25:  135:      md[i].freq[iline]*=1e9;
       25:  136:      md[i].lau[iline]-=1;
       25:  137:      md[i].lal[iline]-=1;
        -:  138:    }
        -:  139:
        -:  140:    /* Calculate Einsten B's */
       26:  141:    for(iline=0;iline<md[i].nline;iline++){
branch  0 taken 96%
branch  1 taken 4% (fallthrough)
        -:  142:      /*		md[i].freq[iline]=(md[i].eterm[md[i].lau[iline]]-md[i].eterm[md[i].lal[iline]])*100*CLIGHT; */
       25:  143:      md[i].beinstu[iline]=md[i].aeinst[iline]*(CLIGHT/md[i].freq[iline])*(CLIGHT/md[i].freq[iline])/(HPLANCK*md[i].freq[iline])/2.;
       25:  144:      md[i].beinstl[iline]=md[i].gstat[md[i].lau[iline]]/md[i].gstat[md[i].lal[iline]]*md[i].beinstu[iline];
        -:  145:    }
        -:  146:
        -:  147:    /* Collision rates below here */
        1:  148:    checkFgets(fgets(string, sizeI, fp), "blank line");
call    0 returned 100%
call    1 returned 100%
        1:  149:    checkFscanf(fscanf(fp,"%d\n", &md[i].npart), 1, "npart");
call    0 returned 100%
call    1 returned 100%
        -:  150:
        1:  151:    md[i].part = malloc(sizeof(*(md[i].part))*md[i].npart);
        -:  152:
        -:  153:    /* Not all the collision partners listed in the moldata file may have associated density functions. Those which don't can play no role and should therefore be ignored. We will try not to store them in md, although due to the demands of backward-compatibility, this will sometimes not be possible, e.g. if the user has not set values for par->collPartIds and if at the same time there are fewer density functions than the total number of collision partners specified in the moldata files. To cover these cases we introduce a new struct cpData attribute: densityIndex, with default value -1 signalling that there is no density function for the associated CP.
        -:  154:    */
        -:  155:    k = 0; /* Index to only those CPs which are found to be associated with a density function. */
        3:  156:    for(ipart=0;ipart<md[i].npart;ipart++){
branch  0 taken 67%
branch  1 taken 33% (fallthrough)
        2:  157:      checkFgets(fgets(string, sizeI, fp), "blank line");
call    0 returned 100%
call    1 returned 100%
        2:  158:      checkFscanf(fscanf(fp,"%d\n", &collPartId), 1, "collPartId integer");
call    0 returned 100%
call    1 returned 100%
        -:  159:
        -:  160:      /* We want to test if the comment after the coll partner ID number is longer than the buffer size. To do this, we write a character - any character, as long as it is not \0 - to the last element of the buffer before reading into it:
        -:  161:      */
        2:  162:      string[sizeof(string)-1] = 'x';
        2:  163:      if(fgets(string, sizeI, fp)==NULL){
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:  164:        if(!silent) bail_out("Read of collision-partner comment line failed.");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  165:exit(1);
call    0 never executed
        -:  166:      } else{
       2*:  167:        if(string[sizeof(string)-1]=='\0' && string[sizeof(string)-2]!='\n'){
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
branch  2 never executed
branch  3 never executed
        -:  168:          /* The presence now of a final \0 means the comment string was either just long enough for the buffer, or too long; the absence of \n in the 2nd-last place means it was too long.
        -:  169:          */
    #####:  170:          if(!silent){
branch  0 never executed
branch  1 never executed
    #####:  171:            snprintf(message, STR_LEN_0, "Collision-partner comment line must be shorter than %d characters.", sizeI-1);
    #####:  172:            bail_out(message);
call    0 never executed
        -:  173:          }
    #####:  174:exit(1);
call    0 never executed
        -:  175:        }
        -:  176:      }
        -:  177:
        -:  178:      /* Look for this CP in par->collPartIds. Note that since we have already called collparts.checkUserDensWeights() by this stage, therefore either we have 1 par->collPartIds entry per density function return, or par->collPartIds==NULL.
        -:  179:      */
        -:  180:      cpWasFoundInUserList = 0;
        2:  181:      if(par->collPartIds!=NULL){
branch  0 taken 100%
branch  1 taken 0%
        4:  182:        for(j=0;j<par->numDensities;j++)
branch  0 taken 50%
branch  1 taken 50% (fallthrough)
        2:  183:          if(collPartId==par->collPartIds[j]) cpWasFoundInUserList = 1;
branch  0 taken 50% (fallthrough)
branch  1 taken 50%
        -:  184:
        -:  185://**** Won't this go wrong when the user has supplied par->collPartNames but not par->collPartIds? See collparts.checkUserDensWeights().
        -:  186:      }
        -:  187:
        2:  188:      if(par->collPartIds==NULL || cpWasFoundInUserList){
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 50% (fallthrough)
branch  3 taken 50%
        -:  189:        /* Check to see if we have encountered collPartId already in a previous moldata file. If not, add it to the list of unique coll parts.
        -:  190:        */
        -:  191:        j = 0;
        -:  192:        previousCpFound = 0;
       1*:  193:        while(j<(*numUniqueCollPartsFound) && !previousCpFound){
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
branch  2 never executed
branch  3 never executed
    #####:  194:          if(collPartId==(*allUniqueCollPartIds)[j])
branch  0 never executed
branch  1 never executed
        -:  195:            previousCpFound = 1;
    #####:  196:          j++;
        -:  197:        }
        -:  198:
        1:  199:        if(!previousCpFound){
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        1:  200:          if((*numUniqueCollPartsFound)>=MAX_N_COLL_PART){
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  201:            if(!silent){
branch  0 never executed
branch  1 never executed
    #####:  202:              snprintf(message, STR_LEN_0, "More than %d unique collision partners found in the moldata files.", MAX_N_COLL_PART);
    #####:  203:              bail_out(message);
call    0 never executed
        -:  204:            }
    #####:  205:exit(1);
call    0 never executed
        -:  206:          }
        -:  207:
        1:  208:          (*allUniqueCollPartIds)[*numUniqueCollPartsFound] = collPartId;
        1:  209:          (*numUniqueCollPartsFound)++;
        -:  210:        }
        -:  211:
        1:  212:        setCollPartsDefaults(&(md[i].part[k]));
call    0 returned 100%
        1:  213:        md[i].part[k].collPartId = collPartId;
        -:  214:
        1:  215:        if(par->lte_only){
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        1:  216:          readDummyCollPart(fp, sizeI);
call    0 returned 100%
        -:  217:
        -:  218:        }else{ /* Add the CP data to md[i].part, we will need it to solve the population levels. */
    #####:  219:          checkFgets(fgets(string, sizeI, fp), "blank line");
call    0 never executed
call    1 never executed
    #####:  220:          checkFscanf(fscanf(fp,"%d\n", &md[i].part[k].ntrans), 1, "ntrans");
call    0 never executed
call    1 never executed
    #####:  221:          checkFgets(fgets(string, sizeI, fp), "blank line");
call    0 never executed
call    1 never executed
    #####:  222:          checkFscanf(fscanf(fp,"%d\n", &md[i].part[k].ntemp), 1, "ntemp");
call    0 never executed
call    1 never executed
    #####:  223:          checkFgets(fgets(string, sizeI, fp), "blank line");
call    0 never executed
call    1 never executed
        -:  224:
    #####:  225:          md[i].part[k].temp = malloc(sizeof(double)*md[i].part[k].ntemp);
    #####:  226:          md[i].part[k].lcl  = malloc(sizeof(int)   *md[i].part[k].ntrans);
    #####:  227:          md[i].part[k].lcu  = malloc(sizeof(int)   *md[i].part[k].ntrans);
        -:  228:
    #####:  229:          for(itemp=0;itemp<md[i].part[k].ntemp;itemp++){
branch  0 never executed
branch  1 never executed
    #####:  230:            checkFscanf(fscanf(fp, "%lf", &md[i].part[k].temp[itemp]), 1, "temp");
call    0 never executed
call    1 never executed
        -:  231:          }
        -:  232:
    #####:  233:          checkFscanf(fscanf(fp,"\n"), 0, "LF");
call    0 never executed
call    1 never executed
    #####:  234:          checkFgets(fgets(string, sizeI, fp), "blank line");
call    0 never executed
call    1 never executed
        -:  235:
    #####:  236:          md[i].part[k].down = malloc(sizeof(double)\
    #####:  237:            *md[i].part[k].ntrans*md[i].part[k].ntemp);
        -:  238:
    #####:  239:          for(itrans=0;itrans<md[i].part[k].ntrans;itrans++){
branch  0 never executed
branch  1 never executed
    #####:  240:            checkFscanf(fscanf(fp, "%d %d %d", &idummy, &md[i].part[k].lcu[itrans], &md[i].part[k].lcl[itrans]), 3, "lcu, lcl");
call    0 never executed
call    1 never executed
    #####:  241:            md[i].part[k].lcu[itrans]-=1;
    #####:  242:            md[i].part[k].lcl[itrans]-=1;
    #####:  243:            for(itemp=0;itemp<md[i].part[k].ntemp;itemp++){
branch  0 never executed
branch  1 never executed
    #####:  244:              j = itrans*md[i].part[k].ntemp+itemp;
    #####:  245:              checkFscanf(fscanf(fp, "%lf", &md[i].part[k].down[j]), 1, "down");
call    0 never executed
call    1 never executed
    #####:  246:              md[i].part[k].down[j] /= 1.0e6;  /* collision data is assuming that coll.part density is in [cm^-3], but LIME uses [m^-3] */
    #####:  247:              md[i].part[k].down[j] *= par->colliScale; /* User scaling of collisional rates */
        -:  248:            }
    #####:  249:            checkFscanf(fscanf(fp,"\n"), 0, "LF");
call    0 never executed
call    1 never executed
        -:  250:          }
        -:  251:        } /* End if(par->lte_only) */
        1:  252:        k++;
        -:  253:      }else{ /* read and discard to keep the file reading in sync */
        1:  254:        readDummyCollPart(fp, sizeI);
call    0 returned 100%
        -:  255:      } /* End if CP found in par->collPartIds. */
        -:  256:    } /* End loop over collision partners this molecule. */
        -:  257:    numPartsAcceptedThisMol = k;
        -:  258:
        1:  259:    if(numPartsAcceptedThisMol!=md[i].npart){
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        1:  260:      md[i].part = realloc(md[i].part, sizeof(*(md[i].part))*numPartsAcceptedThisMol);
        1:  261:      md[i].npart = numPartsAcceptedThisMol;
        -:  262:    }
        -:  263:
        1:  264:    fclose(fp);
call    0 returned 100%
        -:  265:  } /* end loop over molecule index i */
        1:  266:}
        -:  267:
        -:  268:/*....................................................................*/
function assignMolCollPartsToDensities called 0 returned 0% blocks executed 0%
    #####:  269:void assignMolCollPartsToDensities(configInfo *par, molData *md){
        -:  270:  /*
        -:  271:If we have reached this point, par->collPartIds (and par->nMolWeights) should have been malloc'd and filled with sensible values. Here we set up indices which allow us to associate a density function with each collision partner of each radiating molecule. This information is made use of in solver.c.
        -:  272:  */
        -:  273:  int i,j,ipart;
        -:  274:  char message[STR_LEN_0+1];
        -:  275:
    #####:  276:  for(i=0;i<par->nSpecies;i++){
branch  0 never executed
branch  1 never executed
    #####:  277:    for(ipart=0;ipart<md[i].npart;ipart++){
branch  0 never executed
branch  1 never executed
    #####:  278:      md[i].part[ipart].densityIndex = -1; /* Default, signals that there is no density function for this CP. */
    #####:  279:      for(j=0;j<par->numDensities;j++){
branch  0 never executed
branch  1 never executed
    #####:  280:        if(md[i].part[ipart].collPartId==par->collPartIds[j]){
branch  0 never executed
branch  1 never executed
    #####:  281:          md[i].part[ipart].densityIndex = j;
        -:  282:        }
        -:  283:      }
    #####:  284:      if(md[i].part[ipart].densityIndex==-1){
branch  0 never executed
branch  1 never executed
    #####:  285:        if(!silent){
branch  0 never executed
branch  1 never executed
    #####:  286:          snprintf(message, STR_LEN_0, "No density function found for molecule %d coll. part. %d.", i, ipart);
    #####:  287:          warning(message);
call    0 never executed
        -:  288:        }
        -:  289:      }
        -:  290:    }
        -:  291:  }
    #####:  292:}
        -:  293:
        -:  294:/*....................................................................*/
function calcMolCMBs called 1 returned 100% blocks executed 91%
        1:  295:void calcMolCMBs(configInfo *par, molData *md){
        -:  296:  int si, iline;
        -:  297:
        2:  298:  for(si=0;si<par->nSpecies;si++){
branch  0 taken 50%
branch  1 taken 50% (fallthrough)
        1:  299:    md[si].cmb	     = malloc(sizeof(double)*md[si].nline);
       26:  300:    for(iline=0;iline<md[si].nline;iline++){
branch  0 taken 96%
branch  1 taken 4% (fallthrough)
       25:  301:      if(par->tcmb>0.)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
       25:  302:        md[si].cmb[iline] = planckfunc(md[si].freq[iline],par->tcmb);
call    0 returned 100%
        -:  303:      else
    #####:  304:        md[si].cmb[iline]=0.;
        -:  305:    }
        -:  306:  }
        1:  307:}
        -:  308:/*....................................................................*/
function setUpGir called 1 returned 100% blocks executed 72%
        1:  309:void setUpGir(configInfo *par, molData *md){
        -:  310:  int i,ilev,jlev;
        -:  311:  double pumpRate;
        -:  312:  FILE *fp;
        -:  313:  char message[STR_LEN_0+1];
        -:  314:
        2:  315:  for(i=0;i<par->nSpecies;i++){
branch  0 taken 50%
branch  1 taken 50% (fallthrough)
        1:  316:    md[i].gir = malloc(sizeof(double)*md[i].nlev*md[i].nlev);
        -:  317:    /* Read the pumping rate coefficients onto gir array */
       27:  318:    for(ilev=0;ilev<md[i].nlev;ilev++){
branch  0 taken 96%
branch  1 taken 4% (fallthrough)
      702:  319:      for(jlev=0;jlev<md[i].nlev;jlev++){
branch  0 taken 96%
branch  1 taken 4% (fallthrough)
      676:  320:        md[i].gir[ilev*md[i].nlev+jlev] = 0.;
        -:  321:      }
        -:  322:    }
        1:  323:    if((fp=fopen(par->girdatfile[i], "r")) != NULL){
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
       99:  324:      while (fscanf(fp, "%d %d %lf", &ilev, &jlev, &pumpRate) != EOF){
call    0 returned 100%
branch  1 taken 99%
branch  2 taken 1% (fallthrough)
       98:  325:        if(ilev<=0 || jlev<=0){
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
    #####:  326:          if(!silent){
branch  0 never executed
branch  1 never executed
    #####:  327:            snprintf(message, STR_LEN_0, "Girdat file %d: level <1 found. (Values found on the bad line: %d, %d.)", i, ilev, jlev);
    #####:  328:            bail_out(message);
call    0 never executed
    #####:  329:exit(1);
call    0 never executed
        -:  330:          }
        -:  331:        }
       98:  332:        if(ilev>md[i].nlev || jlev>md[i].nlev){
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
    #####:  333:          if(!silent){
branch  0 never executed
branch  1 never executed
    #####:  334:            snprintf(message, STR_LEN_0, "Girdat file %d: level >%d found. (Values found on the bad line: %d, %d.)", i, md[i].nlev, ilev, jlev);
    #####:  335:            bail_out(message);
call    0 never executed
    #####:  336:exit(1);
call    0 never executed
        -:  337:          }
        -:  338:        }
       98:  339:        md[i].gir[(ilev-1)*md[i].nlev+jlev-1] = pumpRate * par->girScale;
        -:  340:      }
        1:  341:      fclose(fp);
call    0 returned 100%
        -:  342:    }else{
    #####:  343:      snprintf(message, STR_LEN_0, "Girdat file %s cannot be opened.",par->girdatfile[i]);
    #####:  344:      bail_out(message);
call    0 never executed
    #####:  345:      exit(1);
call    0 never executed
        -:  346:      }
        -:  347:  }
        1:  348:}
        -:  349:
        -:  350:/*....................................................................*/
function molInit called 1 returned 100% blocks executed 21%
        1:  351:void molInit(configInfo *par, molData *md){
        -:  352:  int i,j,jStart,numActiveCollParts;
        -:  353:  char partstr[90];
        1:  354:  int *allUniqueCollPartIds=NULL;
        -:  355:  int numUniqueCollPartsFound;
        -:  356:
        1:  357:  readMolData(par, md, &allUniqueCollPartIds, &numUniqueCollPartsFound);
call    0 returned 100%
        1:  358:  setUpDensityAux(par, allUniqueCollPartIds, numUniqueCollPartsFound); /* In collparts.c */
call    0 returned 100%
        1:  359:  free(allUniqueCollPartIds);
        -:  360:
        1:  361:  if(par->girdatfile!=NULL){
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        1:  362:    setUpGir(par, md);
call    0 returned 100%
        -:  363:  }
        1:  364:  if(!par->lte_only){
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  365:    assignMolCollPartsToDensities(par, md);
call    0 never executed
        -:  366:
        -:  367:    /* Print out collision partner information.
        -:  368:    */
    #####:  369:    for(i=0;i<par->nSpecies;i++){
branch  0 never executed
branch  1 never executed
    #####:  370:      for(j=0;j<md[i].npart;j++){
branch  0 never executed
branch  1 never executed
    #####:  371:        if(md[i].part[j].densityIndex>=0)
branch  0 never executed
branch  1 never executed
    #####:  372:          copyInparStr(par->collPartNames[md[i].part[j].densityIndex], &(md[i].part[j].name));
call    0 never executed
        -:  373:      }
        -:  374:
        -:  375:      jStart = 0;
    #####:  376:      while(md[i].part[jStart].densityIndex<0) jStart++;
branch  0 never executed
branch  1 never executed
        -:  377:
    #####:  378:      if(jStart<md[i].npart){
branch  0 never executed
branch  1 never executed
        -:  379:        numActiveCollParts = 1;
    #####:  380:        strcpy(partstr, md[i].part[jStart].name);
    #####:  381:        for(j=jStart+1;j<md[i].npart;j++){
branch  0 never executed
branch  1 never executed
    #####:  382:          if(md[i].part[j].densityIndex<0)
branch  0 never executed
branch  1 never executed
    #####:  383:        continue;
        -:  384:
    #####:  385:          strcat( partstr, ", ");
    #####:  386:          strcat( partstr, md[i].part[j].name);
    #####:  387:          numActiveCollParts++;
        -:  388:        }
        -:  389:
    #####:  390:        if(!silent) {
branch  0 never executed
branch  1 never executed
    #####:  391:          collpartmesg(md[i].molName, numActiveCollParts);
call    0 never executed
    #####:  392:          collpartmesg2(partstr);
call    0 never executed
    #####:  393:          collpartmesg3(par->numDensities, 0);//**************** was the 2nd arg used in lime-1.5??
call    0 never executed
        -:  394:        }
        -:  395:      }else{
    #####:  396:        if(!silent) {
branch  0 never executed
branch  1 never executed
    #####:  397:          collpartmesg(md[i].molName, 0);
call    0 never executed
    #####:  398:          collpartmesg3(par->numDensities, 0);//**************** was the 2nd arg used in lime-1.5??
call    0 never executed
        -:  399:        }
        -:  400:      }
        -:  401:    } /* end loop over molecule index i */
        -:  402:  }
        -:  403:
        1:  404:  calcMolCMBs(par, md);
call    0 returned 100%
        1:  405:}
        -:  406:
