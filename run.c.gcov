        -:    0:Source:src/run.c
        -:    0:Graph:src/run.gcno
        -:    0:Data:src/run.gcda
        -:    0:Runs:1
        -:    1:/*
        -:    2: *  run.c
        -:    3: *  This file is part of LIME, the versatile line modeling engine
        -:    4: *
        -:    5: *  Copyright (C) 2006-2014 Christian Brinch
        -:    6: *  Copyright (C) 2015-2017 The LIME development team
        -:    7: *
        -:    8:TODO:
        -:    9: */
        -:   10:
        -:   11:#include "lime.h"
        -:   12:#include <locale.h>
        -:   13:#include "defaults.h"
        -:   14:
        -:   15:int defaultFuncFlags = 0;
        -:   16:double defaultDensyPower = DENSITY_POWER;
        -:   17:double *radii;
        -:   18:
        -:   19:_Bool fixRandomSeeds;
        -:   20:
        -:   21:/*....................................................................*/
        -:   22:void
function reportInfAtOrigin called 0 returned 0% blocks executed 0%
    #####:   23:reportInfAtOrigin(const double value, const char *funcName){
branch  0 never executed
branch  1 never executed
        -:   24:  char message[STR_LEN_0];
        -:   25:
    #####:   26:  if((isinf(value) || isnan(value)) && !silent){
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####:   27:    snprintf(message, STR_LEN_0, "You have a singularity at the origin of your %s() function.", funcName);
    #####:   28:    warning(message);
call    0 never executed
        -:   29:  }
    #####:   30:}
        -:   31:
        -:   32:/*....................................................................*/
        -:   33:void
function reportInfsAtOrigin called 5 returned 100% blocks executed 69%
        5:   34:reportInfsAtOrigin(const int numElements, const double *values, const char *funcName){
        -:   35:  int i;
        -:   36:  char message[STR_LEN_1];
        -:   37:
        5:   38:  if(numElements<=0){
branch  0 taken 80% (fallthrough)
branch  1 taken 20%
       1*:   39:    if((isinf(*values) || isnan(*values)) && !silent){
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
branch  4 never executed
branch  5 never executed
    #####:   40:      snprintf(message, STR_LEN_1, "You have a singularity at the origin of your %s() function.", funcName);
    #####:   41:      warning(message);
call    0 never executed
        -:   42:    }
        -:   43:  }else{
       10:   44:    for(i=0;i<numElements;i++){
branch  0 taken 60%
branch  1 taken 40% (fallthrough)
       6*:   45:      if((isinf(values[i]) || isnan(values[i])) && !silent){
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
branch  4 never executed
branch  5 never executed
    #####:   46:        snprintf(message, STR_LEN_1, "You have a singularity at the origin in return %d of your %s() function.", i, funcName);
    #####:   47:        warning(message);
call    0 never executed
        -:   48:      }
        -:   49:    }
        -:   50:  }
        5:   51:}
        -:   52:
        -:   53:/*....................................................................*/
        -:   54:void
function _printInput called 0 returned 0% blocks executed 0%
    #####:   55:_printInput(const inputPars inpars, image *inimg, const int nImages){
        -:   56:  /*
        -:   57:This is intended purely as a diagnostic program to compare the parameter values passed in by the various wrappers to LIME.
        -:   58:  */
        -:   59:  int i,j;
        -:   60:
    #####:   61:  printf("              radius = %e\n", inpars.radius);
call    0 never executed
    #####:   62:  printf("            minScale = %e\n", inpars.minScale);
call    0 never executed
    #####:   63:  printf("                tcmb = %e\n", inpars.tcmb);
call    0 never executed
        -:   64:
    #####:   65:  for(i=0;i<MAX_N_COLL_PART;i++){
branch  0 never executed
branch  1 never executed
    #####:   66:    if(inpars.nMolWeights[i]>=0.0)
branch  0 never executed
branch  1 never executed
    #####:   67:      printf("       nMolWeights[%d] = %e\n", i, inpars.nMolWeights[i]);
call    0 never executed
    #####:   68:    if(inpars.dustWeights[i]>=0.0)
branch  0 never executed
branch  1 never executed
    #####:   69:      printf("       dustWeights[%d] = %e\n", i, inpars.dustWeights[i]);
call    0 never executed
    #####:   70:    if(inpars.collPartMolWeights[i]>=0.0)
branch  0 never executed
branch  1 never executed
    #####:   71:      printf("collPartMolWeights[%d] = %e\n", i, inpars.collPartMolWeights[i]);
call    0 never executed
    #####:   72:    if(inpars.collPartIds[i]>0)
branch  0 never executed
branch  1 never executed
    #####:   73:      printf("       collPartIds[%d] = %d\n", i, inpars.collPartIds[i]);
call    0 never executed
        -:   74:  }
        -:   75:
    #####:   76:  for(i=0;i<MAX_N_HIGH;i++){
branch  0 never executed
branch  1 never executed
    #####:   77:    if(inpars.gridDensMaxValues[i]<0.0)
branch  0 never executed
branch  1 never executed
        -:   78:      break;
        -:   79:
    #####:   80:    printf(" gridDensMaxValues[%d] = %e\n", i, inpars.gridDensMaxValues[i]);
call    0 never executed
    #####:   81:    printf("    gridDensMaxLoc[%d] = [", i);
call    0 never executed
    #####:   82:    for(j=0;j<DIM;j++){
branch  0 never executed
branch  1 never executed
    #####:   83:      printf("%e,", inpars.gridDensMaxLoc[i][j]);
call    0 never executed
        -:   84:    }
    #####:   85:    printf("]\n");
call    0 never executed
        -:   86:  }
        -:   87:
    #####:   88:  if(i<=0) printf(" gridDensMaxValues unset.\n");
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:   89:
    #####:   90:  printf("          sinkPoints = %d\n", inpars.sinkPoints);
call    0 never executed
    #####:   91:  printf("          pIntensity = %d\n", inpars.pIntensity);
call    0 never executed
    #####:   92:  printf("               blend = %d\n", inpars.blend);
call    0 never executed
    #####:   93:  printf("   traceRayAlgorithm = %d\n", inpars.traceRayAlgorithm);
call    0 never executed
    #####:   94:  printf("   samplingAlgorithm = %d\n", inpars.samplingAlgorithm);
call    0 never executed
    #####:   95:  printf("            sampling = %d\n", inpars.sampling);
call    0 never executed
    #####:   96:  printf("            lte_only = %d\n", inpars.lte_only);
call    0 never executed
    #####:   97:  printf("            init_lte = %d\n", inpars.init_lte);
call    0 never executed
    #####:   98:  printf("           antialias = %d\n", inpars.antialias);
call    0 never executed
    #####:   99:  printf("        polarization = %d\n", inpars.polarization);
call    0 never executed
    #####:  100:  printf("            nThreads = %d\n", inpars.nThreads);
call    0 never executed
    #####:  101:  printf("         nSolveIters = %d\n", inpars.nSolveIters);
call    0 never executed
        -:  102:
    #####:  103:  if(inpars.moldatfile!=NULL && inpars.girdatfile!=NULL){
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  104:    for(i=0;i<MAX_NSPECIES;i++){
branch  0 never executed
branch  1 never executed
    #####:  105:      if(!charPtrIsNullOrEmpty(inpars.moldatfile[i]))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  106:        printf("        moldatfile[%d] = %s\n", i, inpars.moldatfile[i]);
call    0 never executed
        -:  107:
    #####:  108:      if (!charPtrIsNullOrEmpty(inpars.girdatfile[i]))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  109:        printf("        girdatfile[%d] = %s\n", i, inpars.girdatfile[i]);
call    0 never executed
        -:  110:    }
        -:  111:  }else{
    #####:  112:    if(inpars.moldatfile==NULL) printf("            moldatfile = NULL\n");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  113:    if(inpars.girdatfile==NULL) printf("            girdatfile = NULL\n");
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  114:  }
        -:  115:
    #####:  116:  if(inpars.collPartNames!=NULL){
branch  0 never executed
branch  1 never executed
    #####:  117:    for(i=0;i<MAX_N_COLL_PART;i++){
branch  0 never executed
branch  1 never executed
    #####:  118:      if (!charPtrIsNullOrEmpty(inpars.collPartNames[i]))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  119:        printf("     collPartNames[%d] = %s\n", i, inpars.collPartNames[i]);
call    0 never executed
        -:  120:    }
        -:  121:  }else
    #####:  122:    printf("         collPartNames = NULL\n");
call    0 never executed
        -:  123:
    #####:  124:  if (   inpars.outputfile!=NULL)
branch  0 never executed
branch  1 never executed
    #####:  125:    printf("          outputfile = %s\n", inpars.outputfile);
call    0 never executed
        -:  126:  else
    #####:  127:    printf("          outputfile = NULL\n");
call    0 never executed
        -:  128:
    #####:  129:  if (inpars.binoutputfile!=NULL)
branch  0 never executed
branch  1 never executed
    #####:  130:    printf("       binoutputfile = %s\n", inpars.binoutputfile);
call    0 never executed
        -:  131:  else
    #####:  132:    printf("       binoutputfile = NULL\n");
call    0 never executed
        -:  133:
    #####:  134:  if (     inpars.gridfile!=NULL)
branch  0 never executed
branch  1 never executed
    #####:  135:    printf("            gridfile = %s\n", inpars.gridfile);
call    0 never executed
        -:  136:  else
    #####:  137:    printf("            gridfile = NULL\n");
call    0 never executed
        -:  138:
    #####:  139:  if (      inpars.pregrid!=NULL)
branch  0 never executed
branch  1 never executed
    #####:  140:    printf("             pregrid = %s\n", inpars.pregrid);
call    0 never executed
        -:  141:  else
    #####:  142:    printf("             pregrid = NULL\n");
call    0 never executed
        -:  143:
    #####:  144:  if (      inpars.restart!=NULL)
branch  0 never executed
branch  1 never executed
    #####:  145:    printf("             restart = %s\n", inpars.restart);
call    0 never executed
        -:  146:  else
    #####:  147:    printf("             restart = NULL\n");
call    0 never executed
        -:  148:
    #####:  149:  if (         inpars.dust!=NULL)
branch  0 never executed
branch  1 never executed
    #####:  150:    printf("                dust = %s\n", inpars.dust);
call    0 never executed
        -:  151:  else
    #####:  152:    printf("                dust = NULL\n");
call    0 never executed
        -:  153:
    #####:  154:  if (   inpars.gridInFile!=NULL)
branch  0 never executed
branch  1 never executed
    #####:  155:    printf("          gridInFile = %s\n", inpars.gridInFile);
call    0 never executed
        -:  156:  else
    #####:  157:    printf("          gridInFile = NULL\n");
call    0 never executed
        -:  158:
    #####:  159:  if(inpars.gridOutFiles!=NULL){
branch  0 never executed
branch  1 never executed
    #####:  160:    for(i=0;i<NUM_GRID_STAGES;i++){
branch  0 never executed
branch  1 never executed
    #####:  161:      if (inpars.gridOutFiles[i]!=NULL)
branch  0 never executed
branch  1 never executed
    #####:  162:        printf("    gridOutFiles[%d] = %s\n", i, inpars.gridOutFiles[i]);
call    0 never executed
        -:  163:      else
    #####:  164:        printf("    gridOutFiles[%d] = NULL\n", i);
call    0 never executed
        -:  165:    }
        -:  166:  }else
    #####:  167:    printf("        gridOutFiles = NULL\n");
call    0 never executed
        -:  168:
    #####:  169:  if(inpars.resetRNG)
branch  0 never executed
branch  1 never executed
    #####:  170:    printf("            resetRNG = TRUE\n");
call    0 never executed
        -:  171:  else
    #####:  172:    printf("            resetRNG = FALSE\n");
call    0 never executed
        -:  173:
    #####:  174:  if(inpars.doSolveRTE)
branch  0 never executed
branch  1 never executed
    #####:  175:    printf("          doSolveRTE = TRUE\n");
call    0 never executed
        -:  176:  else
    #####:  177:    printf("          doSolveRTE = FALSE\n");
call    0 never executed
        -:  178:
    #####:  179:  for(i=0;i<nImages;i++){
branch  0 never executed
branch  1 never executed
    #####:  180:    printf("\n");
call    0 never executed
    #####:  181:    printf("Image %d\n", i);
call    0 never executed
    #####:  182:    printf("\n");
call    0 never executed
        -:  183:
    #####:  184:    printf("              velres = %e\n", inimg[i].velres);
call    0 never executed
    #####:  185:    printf("              imgres = %e\n", inimg[i].imgres);
call    0 never executed
    #####:  186:    printf("                freq = %e\n", inimg[i].freq);
call    0 never executed
    #####:  187:    printf("           bandwidth = %e\n", inimg[i].bandwidth);
call    0 never executed
    #####:  188:    printf("          source_vel = %e\n", inimg[i].source_vel);
call    0 never executed
    #####:  189:    printf("               theta = %e\n", inimg[i].theta);
call    0 never executed
    #####:  190:    printf("                 phi = %e\n", inimg[i].phi);
call    0 never executed
    #####:  191:    printf("                incl = %e\n", inimg[i].incl);
call    0 never executed
    #####:  192:    printf("              posang = %e\n", inimg[i].posang);
call    0 never executed
    #####:  193:    printf("             azimuth = %e\n", inimg[i].azimuth);
call    0 never executed
        -:  194:
    #####:  195:    printf("               nchan = %d\n", inimg[i].nchan);
call    0 never executed
    #####:  196:    printf("               trans = %d\n", inimg[i].trans);
call    0 never executed
    #####:  197:    printf("                molI = %d\n", inimg[i].molI);
call    0 never executed
    #####:  198:    printf("                pxls = %d\n", inimg[i].pxls);
call    0 never executed
    #####:  199:    printf("                unit = %d\n", inimg[i].unit);
call    0 never executed
        -:  200:
    #####:  201:    if (   inimg[i].units!=NULL)
branch  0 never executed
branch  1 never executed
    #####:  202:      printf("               units = %s\n", inimg[i].units);
call    0 never executed
        -:  203:    else
    #####:  204:      printf("               units = NULL\n");
call    0 never executed
        -:  205:
    #####:  206:    if (inimg[i].filename!=NULL)
branch  0 never executed
branch  1 never executed
    #####:  207:      printf("            filename = %s\n", inimg[i].filename);
call    0 never executed
        -:  208:    else
    #####:  209:      printf("            filename = NULL\n");
call    0 never executed
        -:  210:
    #####:  211:    if(inimg[i].doInterpolateVels)
branch  0 never executed
branch  1 never executed
    #####:  212:      printf("   doInterpolateVels = TRUE\n");
call    0 never executed
        -:  213:    else
    #####:  214:      printf("   doInterpolateVels = FALSE\n");
call    0 never executed
        -:  215:  }
    #####:  216:}
        -:  217:
        -:  218:/*....................................................................*/
        -:  219:int
function checkUserFunctions called 1 returned 100% blocks executed 91%
        1:  220:checkUserFunctions(configInfo *par, _Bool checkForSingularities){
        -:  221:  /*
        -:  222:Run through all the user functions and set flags in the global defaultFuncFlags for those which have defaulted. NOTE however that we will not check which of these functions the user has provided until readOrBuildGrid(), because this will depend on the appropriate data being present or not in any grid file we read in. There are two exceptions to this:
        -:  223:
        -:  224:	- The velocity() function, because this is not only called within readOrBuildGrid() to calculate velocities at the grid node positions and at sample locations along the edges between grids, but also potentially within raytrace() to calculate velocities along ray paths through cells. Therefore we perform extra tests for the presence of a user-supplied velocity function near the end of the present function.
        -:  225:
        -:  226:	- The density() function, because we need to know the number of densities early on, in case we need to call the default gridDensity() function. Thus we test for this below.
        -:  227:  */
        -:  228:
        -:  229:  double x,y,z;
        1:  230:  double *dummyDens = malloc(sizeof(double)*MAX_N_COLL_PART);
        1:  231:  double *dummyAbun = malloc(sizeof(double)*1);
        1:  232:  double *dummyNmol = malloc(sizeof(double)*1);
        -:  233:  double dummyT[2],dummyTurbDop,dummyVel[DIM],dummyB[3],dummyG2d,dummyR[3],dummyNdens;
        -:  234:  int numDensities=0,i;
        -:  235:
        -:  236://**** should give them all values because you don't know what some screwy user routine might return.
        -:  237:
        -:  238:  /* just to stop compiler warnings because this return value is currently unused. */
        -:  239://  (void)dummyDens;
        -:  240:  (void)dummyAbun;
        -:  241:  (void)dummyNmol;
        -:  242:  (void)dummyT;
        -:  243:  (void)dummyTurbDop;
        -:  244:  (void)dummyVel;
        -:  245:  (void)dummyB;
        -:  246:  (void)dummyG2d;
        -:  247:  (void)dummyR;
        -:  248:  (void)dummyNdens;
        -:  249:
        1:  250:  if(checkForSingularities){
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  251:    x = 0.0;
        -:  252:    y = 0.0;
        -:  253:    z = 0.0;
        -:  254:  }else{
    #####:  255:    x = par->minScale;
        -:  256:    y = par->minScale;
        -:  257:    z = par->minScale;
        -:  258:  }
        -:  259:
        1:  260:  dummyR[0] = x;
        1:  261:  dummyR[1] = y;
        1:  262:  dummyR[2] = z;
        -:  263:
       21:  264:  for(i=0;i<MAX_N_COLL_PART;i++) dummyDens[i] = -1.0; /* We expect that no real function will return such values, so this may be used as an indicator for the number of values returned. */
branch  0 taken 95%
branch  1 taken 5% (fallthrough)
        -:  265:
        1:  266:  density(      x, y, z, dummyDens);
call    0 returned 100%
        1:  267:  temperature(  x, y, z, dummyT);
call    0 returned 100%
        1:  268:  abundance(    x, y, z, dummyAbun);
call    0 returned 100%
        1:  269:  molNumDensity(x, y, z, dummyNmol);
call    0 returned 100%
        1:  270:  doppler(      x, y, z, &dummyTurbDop);
call    0 returned 100%
        1:  271:  velocity(     x, y, z, dummyVel);
call    0 returned 100%
        1:  272:  magfield(     x, y, z, dummyB);
call    0 returned 100%
        1:  273:  gasIIdust(    x, y, z, &dummyG2d);
call    0 returned 100%
        -:  274:
        1:  275:  dummyNdens = gridDensity(par, dummyR);
call    0 returned 100%
        -:  276:
        1:  277:  if(checkForSingularities){ /* The default functions have no singulaties so we needn't bother with them. */
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        1:  278:    if(!bitIsSet(defaultFuncFlags, USERFUNC_density))       reportInfsAtOrigin(1, dummyDens, "density");
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
call    3 returned 100%
        1:  279:    if(!bitIsSet(defaultFuncFlags, USERFUNC_temperature))   reportInfsAtOrigin(1, dummyT, "temperature");
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
call    3 returned 100%
       1*:  280:    if(!bitIsSet(defaultFuncFlags, USERFUNC_abundance))     reportInfsAtOrigin(1, dummyAbun, "abundance");
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
call    3 never executed
        1:  281:    if(!bitIsSet(defaultFuncFlags, USERFUNC_molNumDensity)) reportInfsAtOrigin(1, dummyNmol, "molNumDensity");
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
call    3 returned 100%
        1:  282:    if(!bitIsSet(defaultFuncFlags, USERFUNC_doppler))       reportInfsAtOrigin(0, &dummyTurbDop, "doppler");
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
call    3 returned 100%
        1:  283:    if(!bitIsSet(defaultFuncFlags, USERFUNC_velocity))      reportInfsAtOrigin(3, dummyVel, "velocity");
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
call    3 returned 100%
       1*:  284:    if(!bitIsSet(defaultFuncFlags, USERFUNC_magfield))      reportInfsAtOrigin(3, dummyB, "magfield");
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
call    3 never executed
       1*:  285:    if(!bitIsSet(defaultFuncFlags, USERFUNC_gasIIdust))     reportInfsAtOrigin(0, &dummyG2d, "gasIIdust");
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
call    3 never executed
        -:  286:  }
        -:  287:
        -:  288:  /* Calculate the number of density values returned:
        -:  289:  */
        2:  290:  for(i=0;i<MAX_N_COLL_PART;i++){
branch  0 taken 100%
branch  1 taken 0% (fallthrough)
        2:  291:    if(dummyDens[i]<0){ /* Note that NaNs test negative for everything, thus even singular-valued density functions will return the right number of density elements set. */
branch  0 taken 50% (fallthrough)
branch  1 taken 50%
        -:  292:      break;
        -:  293:    }
        -:  294:  }
        -:  295:  numDensities = i;
        -:  296:
        1:  297:  free(dummyNmol);
        1:  298:  free(dummyAbun);
        1:  299:  free(dummyDens);
        -:  300:
        1:  301:  return numDensities;
        -:  302:}
        -:  303:
        -:  304:/*....................................................................*/
        -:  305:void
function parseInput called 1 returned 100% blocks executed 50%
        1:  306:parseInput(const inputPars inpars, image *inimg, const int nImages\
        -:  307:  , configInfo *par, imageInfo **img, molData **md, _Bool checkForSingularities){
        -:  308:  /*
        -:  309:The parameters visible to the user have now been strictly confined to members of the structs 'inputPars' and 'image', both of which are defined in inpars.h. There are however further internally-set values which is is convenient to bundle together with the user-set ones. At present we have a fairly clunky arrangement in which the user-set values are copied member-by-member from the user-dedicated structs to the generic internal structs 'configInfo' and 'imageInfo'. This is done in the present function, along with some checks and other initialization.
        -:  310:  */
        -:  311:  _Bool changedInterp;
        -:  312:  int i,j,id,status=0,numGirDatFiles,numFuncDensities;
        -:  313:  FILE *fp;
        -:  314:  char message[STR_LEN_1];
        -:  315:  _Bool doThetaPhi,foundGoodValue;
        -:  316:  double cos_pa,sin_pa,cosPhi,sinPhi,cos_incl,sin_incl,cosTheta,sinTheta,cos_az,sin_az;
        -:  317:  double tempRotMat[3][3],auxRotMat[3][3],r[3],tempPointDensity,jd,sigma;
        -:  318:  int row,col;
        -:  319:  char *pch_sep = " ,:_", *pch, *pch_end, *units_str;
        1:  320:  const gsl_rng_type *ranNumGenType = gsl_rng_ranlxs2;
        -:  321:  gsl_rng *randGen;
        -:  322:
        -:  323:  /* . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
        -:  324:Copy over user-set parameters to the configInfo versions. (This seems like duplicated effort but it is a good principle to separate the two structs, for several reasons, as follows. (i) We will usually want more config parameters than user-settable ones. The separation leaves it clearer which things the user needs to (or can) set. (ii) The separation allows checking and screening out of impossible combinations of parameters. (iii) We can adopt new names (for clarity) for config parameters without bothering the user with a changed interface.)
        -:  325:  */
        1:  326:  par->radius            = inpars.radius;
        1:  327:  par->minScale          = inpars.minScale;
        1:  328:  par->pIntensity        = inpars.pIntensity;
        1:  329:  par->sinkPoints        = inpars.sinkPoints;
        1:  330:  par->samplingAlgorithm = inpars.samplingAlgorithm;
        1:  331:  par->sampling          = inpars.sampling;
        1:  332:  par->tcmb              = inpars.tcmb;
        1:  333:  par->lte_only          = inpars.lte_only;
        1:  334:  par->init_lte          = inpars.init_lte;
        1:  335:  par->blend             = inpars.blend;
        1:  336:  par->antialias         = inpars.antialias;
        1:  337:  par->polarization      = inpars.polarization;
        1:  338:  par->nThreads          = inpars.nThreads;
        1:  339:  par->nSolveIters       = inpars.nSolveIters;
        1:  340:  par->traceRayAlgorithm = inpars.traceRayAlgorithm;
        1:  341:  par->resetRNG          = inpars.resetRNG;
        1:  342:  par->doSolveRTE        = inpars.doSolveRTE;
        1:  343:  par->Qwater            = inpars.Qwater;
        1:  344:  par->rHelio            = inpars.rHelio;
        1:  345:  par->xne               = inpars.xne;
        1:  346:  par->colliScale        = inpars.colliScale;
        1:  347:  par->girScale          = inpars.girScale;
        1:  348:  par->useEP             = inpars.useEP;
        1:  349:  par->fixRNG            = inpars.fixRNG;
        1:  350:  par->tNuc              = inpars.tNuc;
        1:  351:  par->useCKCdata        = inpars.useCKCdata ;
        -:  352:
        -:  353:  /* Somewhat more carefully copy over the strings:
        -:  354:  */
        1:  355:  copyInparStr(inpars.dust,          &(par->dust));
call    0 returned 100%
        1:  356:  copyInparStr(inpars.outputfile,    &(par->outputfile));
call    0 returned 100%
        1:  357:  copyInparStr(inpars.binoutputfile, &(par->binoutputfile));
call    0 returned 100%
        1:  358:  copyInparStr(inpars.restart,       &(par->restart));
call    0 returned 100%
        1:  359:  copyInparStr(inpars.gridfile,      &(par->gridfile));
call    0 returned 100%
        1:  360:  copyInparStr(inpars.pregrid,       &(par->pregrid));
call    0 returned 100%
        1:  361:  copyInparStr(inpars.gridInFile,    &(par->gridInFile));
call    0 returned 100%
        1:  362:  copyInparStr(inpars.CKCTeFile, 	 &(par->CKCTeFile));
call    0 returned 100%
        1:  363:  copyInparStr(inpars.CKCneFile, 	 &(par->CKCneFile));
call    0 returned 100%
        -:  364:
        1:  365:  if(par->fixRNG){
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        1:  366:    fixRandomSeeds = True;
        1:  367:    printf("Random number generator seeds are fixed.\n");
call    0 returned 100%
        -:  368:    }else{
    #####:  369:    fixRandomSeeds = False; 
        -:  370:  }
        -:  371:
        1:  372:  par->gridOutFiles = malloc(sizeof(char *)*NUM_GRID_STAGES);
        6:  373:  for(i=0;i<NUM_GRID_STAGES;i++)
branch  0 taken 83%
branch  1 taken 17%
        5:  374:    copyInparStr(inpars.gridOutFiles[i], &(par->gridOutFiles[i]));
call    0 returned 100%
        -:  375:
        6:  376:  for(i=0;i<NUM_GRID_STAGES;i++)
branch  0 taken 83%
branch  1 taken 17% (fallthrough)
        5:  377:    par->writeGridAtStage[i] = 0;
        -:  378:
        1:  379:  if(par->pregrid==NULL && par->restart){
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
    #####:  380:    par->nSpecies=0;
    #####:  381:    par->girdatfile = NULL;
        -:  382:  }else{
        -:  383:    /* If the user has provided a list of moldatfile names, the corresponding elements of par->moldatfile will be non-NULL. Thus we can deduce the number of files (species) from the number of non-NULL elements.
        -:  384:    */
        1:  385:    par->nSpecies=0;
        2:  386:    while(par->nSpecies<MAX_NSPECIES && !charPtrIsNullOrEmpty(inpars.moldatfile[par->nSpecies]))
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
branch  3 taken 50%
branch  4 taken 50% (fallthrough)
        1:  387:    par->nSpecies++;
        -:  388:
        -:  389:    numGirDatFiles=0;
        2:  390:    while(numGirDatFiles<MAX_NSPECIES && !charPtrIsNullOrEmpty(inpars.girdatfile[numGirDatFiles]))
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
branch  3 taken 50%
branch  4 taken 50% (fallthrough)
        1:  391:      numGirDatFiles++;
        -:  392:
        1:  393:    if(numGirDatFiles<=0)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  394:      par->girdatfile = NULL;
        1:  395:    else if(numGirDatFiles!=par->nSpecies){
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  396:      if(!silent) bail_out("Number of girdatfiles different from number of species.");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  397:exit(1);
call    0 never executed
        -:  398:    }else{
        1:  399:      par->girdatfile=malloc(sizeof(char *)*par->nSpecies);
        2:  400:      for(id=0;id<par->nSpecies;id++){
branch  0 taken 50%
branch  1 taken 50% (fallthrough)
        1:  401:        copyInparStr(inpars.girdatfile[id], &(par->girdatfile[id]));
call    0 returned 100%
        -:  402:      }
        -:  403:    }
        -:  404:  }
        -:  405:
        -:  406:  /* Copy over the moldatfiles.
        -:  407:  */
        1:  408:  if(par->nSpecies <= 0){
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  409:    par->moldatfile = NULL; /* This will be tested for all line images, so we can never get par->nLineImages>0 if no moldata files have been supplied. */
        -:  410:
        -:  411:  } else {
        1:  412:    par->moldatfile=malloc(sizeof(char *)*par->nSpecies);
        2:  413:    for(id=0;id<par->nSpecies;id++){
branch  0 taken 50%
branch  1 taken 50%
        1:  414:      copyInparStr(inpars.moldatfile[id], &(par->moldatfile[id]));
call    0 returned 100%
        -:  415:    }
        -:  416:
        -:  417:    /* Check if files exist. */
        2:  418:    for(id=0;id<par->nSpecies;id++){
branch  0 taken 50%
branch  1 taken 50% (fallthrough)
        1:  419:      if((fp=fopen(par->moldatfile[id], "r"))==NULL){
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:  420:        if(!silent){
branch  0 never executed
branch  1 never executed
    #####:  421:          snprintf(message, STR_LEN_1, "Molecular data file %s not found.", par->moldatfile[id]);
    #####:  422:          bail_out(message);
call    0 never executed
        -:  423:        }
        -:  424:      } else {
        1:  425:        checkFirstLineMolDat(fp, par->moldatfile[id]);
call    0 returned 100%
        1:  426:        fclose(fp);
call    0 returned 100%
        -:  427:      }
        -:  428:    }
        -:  429:  }
        -:  430:
        -:  431:  /* Copy over the collision-partner pointers:
        -:  432:  */
        1:  433:  par->collPartIds  = malloc(sizeof(int   )*MAX_N_COLL_PART);
       21:  434:  for(i=0;i<MAX_N_COLL_PART;i++) par->collPartIds[i] = inpars.collPartIds[i];
branch  0 taken 95%
branch  1 taken 5% (fallthrough)
        1:  435:  par->nMolWeights  = malloc(sizeof(double)*MAX_N_COLL_PART);
       21:  436:  for(i=0;i<MAX_N_COLL_PART;i++) par->nMolWeights[i] = inpars.nMolWeights[i];
branch  0 taken 95%
branch  1 taken 5% (fallthrough)
        1:  437:  par->collPartNames = malloc(sizeof(char*)*MAX_N_COLL_PART);
       21:  438:  for(i=0;i<MAX_N_COLL_PART;i++) copyInparStr(inpars.collPartNames[i], &(par->collPartNames[i]));
call    0 returned 100%
branch  1 taken 95%
branch  2 taken 5% (fallthrough)
        1:  439:  par->collPartMolWeights = malloc(sizeof(double)*MAX_N_COLL_PART);
       21:  440:  for(i=0;i<MAX_N_COLL_PART;i++) par->collPartMolWeights[i] = inpars.collPartMolWeights[i];
branch  0 taken 95%
branch  1 taken 5% (fallthrough)
        -:  441:
        -:  442:  /* Copy over the grid-density-maximum data and find out how many were set:
        -:  443:  */
        1:  444:  par->gridDensMaxValues = malloc(sizeof(*(par->gridDensMaxValues))*MAX_N_HIGH);
        1:  445:  par->gridDensMaxLoc    = malloc(sizeof(*(par->gridDensMaxLoc))*MAX_N_HIGH);
       11:  446:  for(i=0;i<MAX_N_HIGH;i++){
branch  0 taken 91%
branch  1 taken 9%
       10:  447:    par->gridDensMaxValues[i] = inpars.gridDensMaxValues[i];
       40:  448:    for(j=0;j<DIM;j++) par->gridDensMaxLoc[i][j] = inpars.gridDensMaxLoc[i][j];
branch  0 taken 75%
branch  1 taken 25% (fallthrough)
        -:  449:  }
        -:  450:  i = 0;
       1*:  451:  while(i<MAX_N_HIGH && par->gridDensMaxValues[i]>=0) i++;
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 0%
branch  3 taken 100% (fallthrough)
        1:  452:  par->numGridDensMaxima = i;
        -:  453:
        -:  454:  /* . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
        -:  455:End of copy. */
        -:  456:
        -:  457:  /* Now set the additional values in par. (Note that some of these can be redefined if we read grid points from a file.) */
        1:  458:  par->ncell = par->pIntensity + par->sinkPoints;
        1:  459:  par->radiusSqu = par->radius*par->radius;
        1:  460:  par->minScaleSqu=par->minScale*par->minScale;
        1:  461:  par->doPregrid = (par->pregrid==NULL)?0:1;
        1:  462:  par->nSolveItersDone = 0; /* This can be set to some non-zero value if the user reads in a grid file at dataStageI==5. */
        1:  463:  par->useAbun = 1; /* Can be unset within readOrBuildGrid(). */
        1:  464:  par->dataFlags = 0;
        -:  465:
        1:  466:  if(par->gridInFile==NULL){
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  467:    /* Check that the mandatory parameters now have 'sensible' settings (i.e., that they have been set at all). Raise an exception if not. */
        1:  468:    if (par->radius<=0){
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  469:      if(!silent) bail_out("You must define the radius parameter.");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  470:exit(1);
call    0 never executed
        -:  471:    }
        1:  472:    if (par->minScale<=0){
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  473:      if(!silent) bail_out("You must define the minScale parameter.");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  474:exit(1);
call    0 never executed
        -:  475:    }
        1:  476:    if (par->pIntensity<=0){
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  477:      if(!silent) bail_out("You must define the pIntensity parameter.");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  478:exit(1);
call    0 never executed
        -:  479:    }
        1:  480:    if (par->Qwater<=0){
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  481:      if(!silent) bail_out("You must define the Qwater parameter.");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  482:exit(1);
call    0 never executed
        -:  483:    }
        1:  484:    if (par->rHelio<=0){
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  485:      if(!silent) bail_out("You must define the rHelio parameter.");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  486:exit(1);
call    0 never executed
        -:  487:    }
        -:  488:  }
        -:  489:
        1:  490:  par->gridDensGlobalMax = 1.0; /* Dummy value, needed in case the default gridDensity() is called. */
        1:  491:  par->numDensities = 0; /* Ditto. */
        1:  492:  numFuncDensities = checkUserFunctions(par, checkForSingularities);
call    0 returned 100%
        -:  493:
        -:  494:  /* Calculate par->numDensities.
        -:  495:  */
        1:  496:  if(!(par->doPregrid || par->restart)){ /* These switches cause par->numDensities to be set in routines they call. */
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
        1:  497:    par->numDensities = 0; /* default. */
        -:  498://     removed unused function countDensityCols()
        -:  499:
        -:  500:    if(par->numDensities<=0){
        1:  501:      if(bitIsSet(defaultFuncFlags, USERFUNC_density)){
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:  502:        if(!silent) bail_out("You need to provide a density() function.");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  503:exit(1);
call    0 never executed
        -:  504:      }
        -:  505:
        1:  506:      par->numDensities = numFuncDensities;
        -:  507:
        1:  508:      if(par->numDensities<=0){
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  509:        if(!silent) bail_out("No density values returned.");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  510:exit(1);
call    0 never executed
        -:  511:      }
        -:  512:    }
        -:  513:  }
        -:  514:
        1:  515:  if(!(par->doPregrid || par->restart || par->gridInFile!=NULL)){
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
branch  4 taken 100% (fallthrough)
branch  5 taken 0%
        -:  516:    /* In this case we will need to calculate grid point locations, thus we will need to call the function gridDensity(). The default one is ok, but this (i) needs the user to supply a density function, and (ii) requires par->gridDensGlobalMax etc to be calculated.
        -:  517:    */
        1:  518:    if(bitIsSet(defaultFuncFlags, USERFUNC_gridDensity)){
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
        1:  519:      if(bitIsSet(defaultFuncFlags, USERFUNC_density)){
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:  520:        if(!silent) bail_out("You need to supply either a density() function or a gridDensity() function which doesn't call density().");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  521:exit(1);
call    0 never executed
        -:  522:      }
        -:  523:
        1:  524:      par->gridDensGlobalMax = 1.0; /* We need some sort of >0 value for par->gridDensGlobalMax before we call the default gridDensity(). */
        -:  525:
        -:  526:      /* First try gridDensity() at the origin of coordinates, where the density is often highest:
        -:  527:      */
        4:  528:      for(i=0;i<DIM;i++) r[i] = 0.0;
branch  0 taken 75%
branch  1 taken 25% (fallthrough)
        1:  529:      tempPointDensity = gridDensity(par, r);
call    0 returned 100%
        -:  530:
        1:  531:      if(isinf(tempPointDensity) || isnan(tempPointDensity)){
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
    #####:  532:        if(!silent) warning("There is a singularity at the origin of the gridDensity() function.");
branch  0 never executed
branch  1 never executed
call    2 never executed
        1:  533:      }else if(tempPointDensity<=0.0){
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  534:        if(!silent) warning("The gridDensity() function returns zero at the origin.");
branch  0 never executed
branch  1 never executed
call    2 never executed
        1:  535:      }else if (tempPointDensity>par->gridDensGlobalMax)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  536:        par->gridDensGlobalMax = tempPointDensity;
        -:  537:
        1:  538:      if(isinf(tempPointDensity) || isnan(tempPointDensity) || tempPointDensity<=0.0){
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
branch  4 taken 0%
branch  5 taken 100%
        -:  539:        /* Try gridDensity() a little offset from the origin.
        -:  540:        */
    #####:  541:        for(i=0;i<DIM;i++) r[i] = par->minScale;
branch  0 never executed
branch  1 never executed
    #####:  542:        tempPointDensity = gridDensity(par, r);
call    0 never executed
        -:  543:
    #####:  544:        if(!isinf(tempPointDensity) && !isnan(tempPointDensity) && tempPointDensity>0.0)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####:  545:          par->gridDensGlobalMax = tempPointDensity;
        -:  546:
        -:  547:        else{
        -:  548:          /* Hmm ok, let's try a spread of random locations!
        -:  549:          */
    #####:  550:          randGen = gsl_rng_alloc(ranNumGenType);	/* Random number generator */
call    0 never executed
    #####:  551:          if(fixRandomSeeds)
branch  0 never executed
branch  1 never executed
    #####:  552:            gsl_rng_set(randGen,140978);
call    0 never executed
        -:  553:          else
    #####:  554:            gsl_rng_set(randGen,time(0));
call    0 never executed
call    1 never executed
        -:  555:
        -:  556:          foundGoodValue = FALSE; /* the default. */
    #####:  557:          for(j=0;j<NUM_RAN_DENS;j++){
branch  0 never executed
branch  1 never executed
    #####:  558:            for(i=0;i<DIM;i++) r[i] = par->radius*(2.0*gsl_rng_uniform(randGen) - 1.0);
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  559:            tempPointDensity = gridDensity(par, r);
call    0 never executed
    #####:  560:            if(!isinf(tempPointDensity) && !isnan(tempPointDensity) && tempPointDensity>0.0){
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
        -:  561:              foundGoodValue = TRUE;
        -:  562:          break;
        -:  563:            }
        -:  564:          }
        -:  565:
    #####:  566:          if(foundGoodValue){
branch  0 never executed
branch  1 never executed
    #####:  567:            if (tempPointDensity>par->gridDensGlobalMax)
branch  0 never executed
branch  1 never executed
    #####:  568:              par->gridDensGlobalMax = tempPointDensity;
        -:  569:
    #####:  570:          }else if(par->numGridDensMaxima>0){
branch  0 never executed
branch  1 never executed
        -:  571:            /* Test any maxima the user has provided:
        -:  572:            */
    #####:  573:            par->gridDensGlobalMax = par->gridDensMaxValues[0];
    #####:  574:            for(i=1;i<par->numGridDensMaxima;i++)
branch  0 never executed
branch  1 never executed
    #####:  575:              if(par->gridDensMaxValues[i]>par->gridDensGlobalMax) par->gridDensGlobalMax = par->gridDensMaxValues[i];
branch  0 never executed
branch  1 never executed
        -:  576:          }else{
        -:  577:#ifdef KLUDGE_FOR_BAD_DENS
        -:  578:            /* This has been added under protest to cope with modellib's crappy density functions. */
        -:  579:            defaultDensyPower = 1.0;
        -:  580:            par->gridDensGlobalMax = 1.0;
        -:  581:#else
    #####:  582:            if(!silent) bail_out("Can't find non-pathological values of the gridDensity() function.");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  583:exit(1);
call    0 never executed
        -:  584:#endif
        -:  585:          }
        -:  586:        }
        -:  587:      }
        -:  588:    }
        -:  589:  }
        -:  590:
        6:  591:  for(i=0;i<NUM_GRID_STAGES;i++){
branch  0 taken 83%
branch  1 taken 17% (fallthrough)
        5:  592:    if(par->gridOutFiles[i] != NULL)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  593:      par->writeGridAtStage[i] = 1;
        -:  594:  };
        -:  595:
        -:  596:  /*
        -:  597:Now we need to calculate the cutoff value used in calcSourceFn(). The issue is to decide between
        -:  598:
        -:  599:  y = (1 - exp[-x])/x
        -:  600:
        -:  601:or the approximation using the Taylor expansion of exp(-x), which to 3rd order is
        -:  602:
        -:  603:  y ~ 1 - x/2 + x^2/6.
        -:  604:
        -:  605:The cutoff will be the value of abs(x) for which the error in the exact expression equals the next unused Taylor term, which is x^3/24. This error can be shown to be given for small |x| by epsilon/|x|, where epsilon is the floating-point precision of the computer. Hence the cutoff evaluates to
        -:  606:
        -:  607:  |x|_cutoff = (24*epsilon)^{1/4}.
        -:  608:
        -:  609:  */
        1:  610:  par->taylorCutoff = pow(24.*DBL_EPSILON, 0.25);
        1:  611:  par->nImages = nImages;
        1:  612:  par->numDims = DIM;
        -:  613:
        -:  614:  /* Copy over user-set image values to the generic struct:
        -:  615:  */
        1:  616:  if(nImages>0){
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        1:  617:    *img = malloc(sizeof(**img)*nImages);
        2:  618:    for(i=0;i<nImages;i++){
branch  0 taken 50%
branch  1 taken 50% (fallthrough)
        1:  619:      (*img)[i].nchan      = inimg[i].nchan;
        1:  620:      (*img)[i].trans      = inimg[i].trans;
        1:  621:      (*img)[i].molI       = inimg[i].molI;
        1:  622:      (*img)[i].velres     = inimg[i].velres;
        1:  623:      (*img)[i].imgres     = inimg[i].imgres;
        1:  624:      (*img)[i].pxls       = inimg[i].pxls;
        1:  625:      copyInparStr(inimg[i].units, &((*img)[i].units));
call    0 returned 100%
        1:  626:      (*img)[i].freq       = inimg[i].freq;
        1:  627:      (*img)[i].bandwidth  = inimg[i].bandwidth;
        1:  628:      copyInparStr(inimg[i].filename, &((*img)[i].filename));
call    0 returned 100%
        1:  629:      (*img)[i].source_vel = inimg[i].source_vel;
        1:  630:      (*img)[i].psfShape   = inimg[i].psfShape;
        1:  631:      (*img)[i].rebinSpec  = inimg[i].rebinSpec;
        1:  632:      (*img)[i].nBins      = inimg[i].nBins;
        1:  633:      (*img)[i].binWidth   = inimg[i].binWidth;
        1:  634:      (*img)[i].theta      = inimg[i].theta;
        1:  635:      (*img)[i].phi        = inimg[i].phi;
        1:  636:      (*img)[i].incl       = inimg[i].incl;
        1:  637:      (*img)[i].posang     = inimg[i].posang;
        1:  638:      (*img)[i].azimuth    = inimg[i].azimuth;
        1:  639:      (*img)[i].distance   = inimg[i].distance;
        1:  640:      (*img)[i].doInterpolateVels = inimg[i].doInterpolateVels; // This is only accessed if par->traceRayAlgorithm==1.
        -:  641:    
        1:  642:      (*img)[i].psfWidth = inimg[i].psfWidth / inimg[i].velres;  // Convert the spectral response FWHM to channels
        -:  643:          
        -:  644:    }
        -:  645:  }
        -:  646:
        -:  647:  /* Allocate pixel space and parse image information.
        -:  648:  */
        -:  649:  
        2:  650:  for(i=0;i<nImages;i++){
branch  0 taken 50%
branch  1 taken 50% (fallthrough)
        -:  651:  
        1:  652:   if((*img)[i].rebinSpec == 1){
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  653:      if ((*img)[i].nBins > (*img)[i].nchan){
branch  0 never executed
branch  1 never executed
    #####:  654:      if(!silent){
branch  0 never executed
branch  1 never executed
    #####:  655:      snprintf(message, STR_LEN_1, "The number of channels (nchan) is less than the number of bins (nBin", i);
    #####:  656:      bail_out(message);
call    0 never executed
        -:  657:        }
    #####:  658:      exit(1);
call    0 never executed
        -:  659:      }
        -:  660:      
    #####:  661:      if ((*img)[i].binWidth < (*img)[i].velres){
branch  0 never executed
branch  1 never executed
    #####:  662:      if(!silent){
branch  0 never executed
branch  1 never executed
    #####:  663:      snprintf(message, STR_LEN_1, "The requested bin width is less than the channel width", i);
    #####:  664:      bail_out(message);
call    0 never executed
        -:  665:        }
    #####:  666:      exit(1);
call    0 never executed
        -:  667:      }
        -:  668:      
        -:  669:    }
        -:  670:  
        1:  671:   if((*img)[i].psfShape == 2){
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  672:      if ((*img)[i].nchan < 2. * (*img)[i].psfWidth){
branch  0 never executed
branch  1 never executed
    #####:  673:      if(!silent){
branch  0 never executed
branch  1 never executed
    #####:  674:      snprintf(message, STR_LEN_1, "The number of channels is less than twice the requested PSF width", i);
    #####:  675:      bail_out(message);
call    0 never executed
        -:  676:        }
    #####:  677:      exit(1);
call    0 never executed
        -:  678:      }
        -:  679:   
    #####:  680:      if ((*img)[i].psfWidth < 0.5){
branch  0 never executed
branch  1 never executed
    #####:  681:      if(!silent){
branch  0 never executed
branch  1 never executed
    #####:  682:      snprintf(message, STR_LEN_1, "The spectral PSF width is less than half the channel width", i);
    #####:  683:      bail_out(message);
call    0 never executed
        -:  684:        }
    #####:  685:      exit(1);
call    0 never executed
        -:  686:      }
        -:  687:    } 
        -:  688:   
        -:  689:   
        -:  690:      /* Set up the spectral convolution kernels */
        1:  691:      if((*img)[i].psfShape == 1){ // Kernel is a boxcar
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  692:         (*img)[i].psfKernelN = (int)round((*img)[i].psfWidth);
    #####:  693:         if(!silent && fabs((*img)[i].psfKernelN - (*img)[i].psfWidth)/(*img)[i].psfWidth > 0.001){
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  694:            snprintf(message, STR_LEN_1, "Requested boxcar smoothing of %.2f channels, but nearest integer value of %d will be used.",(*img)[i].psfWidth,(*img)[i].psfKernelN);
    #####:  695:            warning(message);
call    0 never executed
        -:  696:         }
        1:  697:      }else if((*img)[i].psfShape == 2){ // Kernel is Gaussian
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  698:         (*img)[i].psfKernelN = (int)(round((*img)[i].psfWidth) * 2.) + 1;
    #####:  699:         (*img)[i].psfKernel = malloc(sizeof(double) * (*img)[i].psfKernelN);
    #####:  700:         sigma = (*img)[i].psfWidth/2.3548;
        -:  701:         j = 0;
    #####:  702:         for(jd=(-((*img)[i].psfKernelN-1.0)/2.0);jd<=(((*img)[i].psfKernelN-1.0)/2.0);jd++){
branch  0 never executed
branch  1 never executed
    #####:  703:            (*img)[i].psfKernel[j] = (1/(sigma*sqrt(2.0 * PI))) * exp(-pow(jd,2.0)/(2.0*pow(sigma,2.0)));
        -:  704:         //   printf("j=%d  jd=%.1f  G=%8.3e\n",j,jd,(*img)[i].psfKernel[j]);
    #####:  705:            j++;
        -:  706:            
        -:  707:         }
        -:  708:    }
        -:  709:      
        1:  710:    (*img)[i].imgunits = NULL;
        -:  711:
        -:  712:    /* If user has not supplied a units string then use unit value (default 0) to maintain backwards compatibility */
        1:  713:    if((*img)[i].units == NULL){
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        1:  714:      (*img)[i].numunits = 1;
        1:  715:      (*img)[i].imgunits = malloc(sizeof(*(*img)[i].imgunits));
        1:  716:      if((*img)[i].imgunits == NULL){
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  717:        if(!silent) bail_out("Error allocating memory for single unit");
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  718:      }
        1:  719:      (*img)[i].imgunits[0] = inimg[i].unit;
        -:  720:    }else{
        -:  721:      /* Otherwise parse image units, populate imgunits array with appropriate image identifiers and track number
        -:  722:       * of units requested */
    #####:  723:      copyInparStr((*img)[i].units, &(units_str));
call    0 never executed
    #####:  724:      pch = strtok(units_str, pch_sep);
call    0 never executed
        -:  725:      j = 0;
    #####:  726:      while(pch){
branch  0 never executed
branch  1 never executed
    #####:  727:        j++;
    #####:  728:        (*img)[i].imgunits = realloc((*img)[i].imgunits, sizeof(*(*img)[i].imgunits)*j);
    #####:  729:        if((*img)[i].imgunits == NULL){
branch  0 never executed
branch  1 never executed
    #####:  730:          if(!silent) bail_out("Error allocating memory for multiple units");
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  731:        }
    #####:  732:        (*img)[i].imgunits[j-1] = (int)strtol(pch, &pch_end, 0);
call    0 never executed
    #####:  733:        if(*pch_end){
branch  0 never executed
branch  1 never executed
    #####:  734:          snprintf(message, STR_LEN_1, "Image %d: units string contains '%s' which could not be converted to an integer", i, pch_end);
    #####:  735:          if(!silent) bail_out(message);
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  736:exit(1);
call    0 never executed
        -:  737:        }
    #####:  738:        pch = strtok(NULL, pch_sep);
call    0 never executed
        -:  739:      }
    #####:  740:      (*img)[i].numunits = j;
        -:  741:    } /* End parse of units. */
        -:  742:    
       1*:  743:    if((*img)[i].nchan == 0 && (*img)[i].velres<0 ){ /* => user has set neither nchan nor velres. One of the two is required for a line image. */
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
branch  2 never executed
branch  3 never executed
        -:  744:      /* Assume continuum image */
        -:  745:
    #####:  746:      if(par->polarization){
branch  0 never executed
branch  1 never executed
    #####:  747:        (*img)[i].nchan=3;
        -:  748:
    #####:  749:        if(!silent && bitIsSet(defaultFuncFlags, USERFUNC_magfield)){
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####:  750:          warning("You need to supply a magfield function for a polarized image.");
call    0 never executed
        -:  751://***** NOTE that this test is incomplete because the values might be supplied via the gridInFile.
        -:  752:        }
        -:  753:      }else
    #####:  754:        (*img)[i].nchan=1;
        -:  755:
    #####:  756:      if((*img)[i].freq<0){
branch  0 never executed
branch  1 never executed
    #####:  757:        if(!silent){
branch  0 never executed
branch  1 never executed
    #####:  758:          snprintf(message, STR_LEN_1, "Image %d: you must set freq for a continuum image.", i);
    #####:  759:          bail_out(message);
call    0 never executed
        -:  760:        }
    #####:  761:exit(1);
call    0 never executed
        -:  762:      }
        -:  763:
    #####:  764:      if(!silent && ((*img)[i].trans>-1 || (*img)[i].bandwidth>-1.0)){
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####:  765:        snprintf(message, STR_LEN_1, "Image %d: bandwidth and trans are ignored for a continuum image.", i);
    #####:  766:        warning(message);
call    0 never executed
        -:  767:      }
    #####:  768:      (*img)[i].doline=0;
        -:  769:
        -:  770:    }else{ /* => user has set one of either nchan or velres, or possibly both. */
        -:  771:      /* Assume line image */
        -:  772:
        -:  773:      /*
        -:  774:For a valid line image, the user must set one of the following pairs:
        -:  775:  bandwidth, velres (if they also set nchan, this is overwritten)
        -:  776:  bandwidth, nchan (if they also set velres, this is overwritten)
        -:  777:  velres, nchan (if they also set bandwidth, this is overwritten)
        -:  778:
        -:  779:The presence of one of these combinations at least is checked here, although the actual calculation is done in raytrace(), because it depends on moldata info which we have not yet got.
        -:  780:      */
       1*:  781:      if((*img)[i].bandwidth > 0 && (*img)[i].velres > 0){
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
branch  2 never executed
branch  3 never executed
    #####:  782:        if(!silent && (*img)[i].nchan > 0){
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  783:          snprintf(message, STR_LEN_1, "Image %d: your nchan value will be overwritten.", i);
    #####:  784:          warning(message);
call    0 never executed
        -:  785:        }
        -:  786:
        1:  787:      }else if((*img)[i].nchan <= 0 || ((*img)[i].bandwidth <= 0 && (*img)[i].velres <= 0)) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
branch  4 taken 0% (fallthrough)
branch  5 taken 100%
    #####:  788:        if(!silent){
branch  0 never executed
branch  1 never executed
    #####:  789:          snprintf(message, STR_LEN_1, "Image %d: insufficient info to calculate nchan, velres and bandwidth.", i);
    #####:  790:          bail_out(message);
call    0 never executed
        -:  791:        }
    #####:  792:exit(1);
call    0 never executed
        -:  793:      }
        -:  794:
        -:  795:      /* Check that we have keywords which allow us to calculate the image frequency (if necessary) after reading in the moldata file:
        -:  796:      */
        1:  797:      if((*img)[i].trans>-1){ /* => user has set trans, possibly also freq. */
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        1:  798:        if(!silent && (*img)[i].freq > 0){
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
    #####:  799:          snprintf(message, STR_LEN_1, "Image %d: you set trans, so I'm ignoring freq.", i);
    #####:  800:          warning(message);
call    0 never executed
        -:  801:        }
        -:  802:
        1:  803:        if((*img)[i].molI < 0){
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        1:  804:          if(!silent && par->nSpecies>1){
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
    #####:  805:            snprintf(message, STR_LEN_1, "Image %d: you did not set molI, so I'm assuming the 1st molecule.", i);
    #####:  806:            warning(message);
call    0 never executed
        -:  807:          }
        1:  808:          (*img)[i].molI = 0;
        -:  809:        }
    #####:  810:      }else if((*img)[i].freq<0){ /* => user has set neither trans nor freq. */
branch  0 never executed
branch  1 never executed
    #####:  811:        if(!silent){
branch  0 never executed
branch  1 never executed
    #####:  812:          snprintf(message, STR_LEN_1, "Image %d: you must set either freq or trans (plus optionally molI).", i);
    #####:  813:          bail_out(message);
call    0 never executed
        -:  814:        }
    #####:  815:exit(1);
call    0 never executed
        -:  816:      }/* else => the user has set freq. */
        -:  817:
        1:  818:      (*img)[i].doline=1;
        -:  819:    } /* End check of line or continuum. */
        -:  820:
        1:  821:    if((*img)[i].imgres<0.0){
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  822:      if(!silent){
branch  0 never executed
branch  1 never executed
    #####:  823:        snprintf(message, STR_LEN_1, "Image %d: you must set imgres.", i);
    #####:  824:        bail_out(message);
call    0 never executed
        -:  825:      }
    #####:  826:exit(1);
call    0 never executed
        -:  827:    }
        -:  828:
        1:  829:    if((*img)[i].pxls<0){
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  830:      if(!silent){
branch  0 never executed
branch  1 never executed
    #####:  831:        snprintf(message, STR_LEN_1, "Image %d: you must set pxls.", i);
    #####:  832:        bail_out(message);
call    0 never executed
        -:  833:      }
    #####:  834:exit(1);
call    0 never executed
        -:  835:    }
        -:  836:
        1:  837:    if((*img)[i].distance<0.0){
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  838:      if(!silent){
branch  0 never executed
branch  1 never executed
    #####:  839:        snprintf(message, STR_LEN_1, "Image %d: you must set distance.", i);
    #####:  840:        bail_out(message);
call    0 never executed
        -:  841:      }
    #####:  842:exit(1);
call    0 never executed
        -:  843:    }
        -:  844:
        1:  845:    (*img)[i].imgres=(*img)[i].imgres*ARCSEC_TO_RAD;
        1:  846:    (*img)[i].pixel = malloc(sizeof(*((*img)[i].pixel))*(*img)[i].pxls*(*img)[i].pxls);
    65537:  847:    for(id=0;id<((*img)[i].pxls*(*img)[i].pxls);id++){
branch  0 taken 100%
branch  1 taken 1% (fallthrough)
    65536:  848:      (*img)[i].pixel[id].intense = malloc(sizeof(double)*(*img)[i].nchan);
    65536:  849:      (*img)[i].pixel[id].tau = malloc(sizeof(double)*(*img)[i].nchan);
        -:  850:    }
        -:  851:
        -:  852:    /*
        -:  853:The image rotation matrix is used within traceray() to transform the coordinates of a vector (actually two vectors - the ray direction and its starting point) as initially specified in the observer-anchored frame into the coordinate frame of the model. In linear algebra terms, the model-frame vector v_mod is related to the vector v_obs as expressed in observer- (or image-) frame coordinates via the image rotation matrix R by
        -:  854:
        -:  855:    v_mod = R * v_obs,				1
        -:  856:
        -:  857:the multiplication being the usual matrix-vector style. Note that the ith row of R is the ith axis of the model frame with coordinate values expressed in terms of the observer frame.
        -:  858:
        -:  859:The matrix R can be broken into a sequence of several (3 at least are needed for full degrees of freedom) simpler rotations. Since these constituent rotations are usually easier to conceive in terms of rotations of the model in the observer framework, it is convenient to invert equation (1) to give
        -:  860:
        -:  861:    v_obs = R^T * v_mod,			2
        -:  862:
        -:  863:where ^T here denotes transpose. Supposing now we rotate the model in a sequence R_3^T followed by R_2^T followed by R_1^T, equation (2) can be expanded to give
        -:  864:
        -:  865:    v_obs = R_1^T * R_2^T * R_3^T * v_mod.	3
        -:  866:
        -:  867:Inverting everything to return to the format of equation (1), which is what we need, we find
        -:  868:
        -:  869:    v_mod = R_3 * R_2 * R_1 * v_obs.		4
        -:  870:
        -:  871:LIME provides two different schemes of {R_1, R_2, R_3}: {PA, phi, theta} and {PA, inclination, azimuth}. As an example, consider phi, which is a rotation of the model from the observer Z axis towards the X. The matching obs->mod rotation matrix is therefore
        -:  872:
        -:  873:            ( cos(ph)  0  -sin(ph) )
        -:  874:            (                      )
        -:  875:    R_phi = (    0     0     1     ).
        -:  876:            (                      )
        -:  877:            ( sin(ph)  0   cos(ph) )
        -:  878:
        -:  879:    */
        -:  880:
       1*:  881:    doThetaPhi = (((*img)[i].incl<-900.)||((*img)[i].azimuth<-900.)||((*img)[i].posang<-900.))?1:0;
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
        -:  882:
        -:  883:    if(doThetaPhi){
        -:  884:      /* For the present PA is not implemented for the theta/phi scheme. Thus we just load the identity matrix at present.
        -:  885:      */
        1:  886:      (*img)[i].rotMat[0][0] = 1.0;
        1:  887:      (*img)[i].rotMat[0][1] = 0.0;
        1:  888:      (*img)[i].rotMat[0][2] = 0.0;
        1:  889:      (*img)[i].rotMat[1][0] = 0.0;
        1:  890:      (*img)[i].rotMat[1][1] = 1.0;
        1:  891:      (*img)[i].rotMat[1][2] = 0.0;
        1:  892:      (*img)[i].rotMat[2][0] = 0.0;
        1:  893:      (*img)[i].rotMat[2][1] = 0.0;
        1:  894:      (*img)[i].rotMat[2][2] = 1.0;
        -:  895:    }else{
        -:  896:      /* Load PA rotation matrix R_PA:
        -:  897:      */
    #####:  898:      cos_pa   = cos((*img)[i].posang);
    #####:  899:      sin_pa   = sin((*img)[i].posang);
    #####:  900:      (*img)[i].rotMat[0][0] =  cos_pa;
    #####:  901:      (*img)[i].rotMat[0][1] = -sin_pa;
    #####:  902:      (*img)[i].rotMat[0][2] =  0.0;
    #####:  903:      (*img)[i].rotMat[1][0] =  sin_pa;
    #####:  904:      (*img)[i].rotMat[1][1] =  cos_pa;
    #####:  905:      (*img)[i].rotMat[1][2] =  0.0;
    #####:  906:      (*img)[i].rotMat[2][0] =  0.0;
    #####:  907:      (*img)[i].rotMat[2][1] =  0.0;
    #####:  908:      (*img)[i].rotMat[2][2] =  1.0;
        -:  909:    }
        -:  910:
        1:  911:    if(doThetaPhi){
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  912:      /* Load phi rotation matrix R_phi:
        -:  913:      */
        1:  914:      cosPhi   = cos((*img)[i].phi);
        1:  915:      sinPhi   = sin((*img)[i].phi);
        1:  916:      auxRotMat[0][0] =  cosPhi;
        1:  917:      auxRotMat[0][1] =  0.0;
        1:  918:      auxRotMat[0][2] = -sinPhi;
        1:  919:      auxRotMat[1][0] =  0.0;
        1:  920:      auxRotMat[1][1] =  1.0;
        1:  921:      auxRotMat[1][2] =  0.0;
        1:  922:      auxRotMat[2][0] =  sinPhi;
        1:  923:      auxRotMat[2][1] =  0.0;
        1:  924:      auxRotMat[2][2] =  cosPhi;
        -:  925:    }else{
        -:  926:      /* Load inclination rotation matrix R_inc:
        -:  927:      */
    #####:  928:      cos_incl = cos((*img)[i].incl + M_PI);
    #####:  929:      sin_incl = sin((*img)[i].incl + M_PI);
    #####:  930:      auxRotMat[0][0] =  cos_incl;
    #####:  931:      auxRotMat[0][1] =  0.0;
    #####:  932:      auxRotMat[0][2] = -sin_incl;
    #####:  933:      auxRotMat[1][0] =  0.0;
    #####:  934:      auxRotMat[1][1] =  1.0;
    #####:  935:      auxRotMat[1][2] =  0.0;
    #####:  936:      auxRotMat[2][0] =  sin_incl;
    #####:  937:      auxRotMat[2][1] =  0.0;
    #####:  938:      auxRotMat[2][2] =  cos_incl;
        -:  939:    }
        -:  940:
        4:  941:    for(row=0;row<3;row++){
branch  0 taken 75%
branch  1 taken 25% (fallthrough)
       12:  942:      for(col=0;col<3;col++){
branch  0 taken 75%
branch  1 taken 25% (fallthrough)
        9:  943:        tempRotMat[row][col] = 0.0;
       36:  944:        for(j=0;j<3;j++)
branch  0 taken 75%
branch  1 taken 25% (fallthrough)
       27:  945:          tempRotMat[row][col] += auxRotMat[row][j]*(*img)[i].rotMat[j][col];
        -:  946:      }
        -:  947:    }
        -:  948:
        1:  949:    if(doThetaPhi){
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  950:      /* Load theta rotation matrix R_theta:
        -:  951:      */
        1:  952:      cosTheta = cos((*img)[i].theta);
        1:  953:      sinTheta = sin((*img)[i].theta);
        1:  954:      auxRotMat[0][0] =  1.0;
        1:  955:      auxRotMat[0][1] =  0.0;
        1:  956:      auxRotMat[0][2] =  0.0;
        1:  957:      auxRotMat[1][0] =  0.0;
        1:  958:      auxRotMat[1][1] =  cosTheta;
        1:  959:      auxRotMat[1][2] =  sinTheta;
        1:  960:      auxRotMat[2][0] =  0.0;
        1:  961:      auxRotMat[2][1] = -sinTheta;
        1:  962:      auxRotMat[2][2] =  cosTheta;
        -:  963:    }else{
        -:  964:      /* Load azimuth rotation matrix R_az:
        -:  965:      */
    #####:  966:      cos_az   = cos((*img)[i].azimuth + M_PI/2.0);
    #####:  967:      sin_az   = sin((*img)[i].azimuth + M_PI/2.0);
    #####:  968:      auxRotMat[0][0] =  cos_az;
    #####:  969:      auxRotMat[0][1] = -sin_az;
    #####:  970:      auxRotMat[0][2] =  0.0;
    #####:  971:      auxRotMat[1][0] =  sin_az;
    #####:  972:      auxRotMat[1][1] =  cos_az;
    #####:  973:      auxRotMat[1][2] =  0.0;
    #####:  974:      auxRotMat[2][0] =  0.0;
    #####:  975:      auxRotMat[2][1] =  0.0;
    #####:  976:      auxRotMat[2][2] =  1.0;
        -:  977:    }
        -:  978:
        4:  979:    for(row=0;row<3;row++){
branch  0 taken 75%
branch  1 taken 25% (fallthrough)
       12:  980:      for(col=0;col<3;col++){
branch  0 taken 75%
branch  1 taken 25% (fallthrough)
        9:  981:        (*img)[i].rotMat[row][col] = 0.0;
       36:  982:        for(j=0;j<3;j++)
branch  0 taken 75%
branch  1 taken 25% (fallthrough)
       27:  983:          (*img)[i].rotMat[row][col] += auxRotMat[row][j]*tempRotMat[j][col];
        -:  984:      }
        -:  985:    }
        -:  986:  }
        -:  987:
        1:  988:  par->nLineImages = 0;
        1:  989:  par->nContImages = 0;
        1:  990:  par->doInterpolateVels = 0;
        -:  991:  changedInterp=FALSE;
        2:  992:  for(i=0;i<nImages;i++){
branch  0 taken 50%
branch  1 taken 50% (fallthrough)
        1:  993:    if((*img)[i].doline){
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  994:
        -:  995:#ifdef IS_PYTHON
        -:  996:      /* This is done because we want to avoid calling the velocity() function within raytrace(). */
        -:  997:      if(par->traceRayAlgorithm==1 && !(*img)[i].doInterpolateVels\
        -:  998:      && !bitIsSet(defaultFuncFlags, USERFUNC_velocity)\
        -:  999:      && par->nThreads>1){
        -: 1000:        changedInterp = TRUE;
        -: 1001:        (*img)[i].doInterpolateVels = TRUE;
        -: 1002:      }
        -: 1003:#endif
        -: 1004:
       1*: 1005:      if(par->traceRayAlgorithm==1 && !(*img)[i].doInterpolateVels\
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
branch  2 never executed
branch  3 never executed
    #####: 1006:      && bitIsSet(defaultFuncFlags, USERFUNC_velocity)){
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1007:        if(!silent) bail_out("par->traceRayAlgorithm==1 && !img[i].doInterpolateVels requires you to supply a velocity function.");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####: 1008:exit(1);
call    0 never executed
        -: 1009:      }
        1: 1010:      par->nLineImages++;
        -: 1011:    }else
    #####: 1012:      par->nContImages++;
        -: 1013:
        1: 1014:    if((*img)[i].doInterpolateVels)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####: 1015:      par->doInterpolateVels = 1;
        -: 1016:  }
        -: 1017:
        1: 1018:  if(!silent && changedInterp)
        -: 1019:    warning("You cannot call a python velocity function when multi-threaded. Vels will be interpolated from grid values.");
        -: 1020:
        1: 1021:  if(par->nContImages>0){
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####: 1022:    if(par->dust==NULL){
branch  0 never executed
branch  1 never executed
    #####: 1023:      if(!silent) bail_out("You must point par.dust to a dust opacity file for a continuum image.");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####: 1024:exit(1);
call    0 never executed
        -: 1025:    }else{
    #####: 1026:      if((fp=fopen(par->dust, "r"))==NULL){
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1027:        if(!silent){
branch  0 never executed
branch  1 never executed
    #####: 1028:          snprintf(message, STR_LEN_1, "Couldn't open dust opacity data file %s", par->dust);
    #####: 1029:          bail_out(message);
call    0 never executed
        -: 1030:        }
    #####: 1031:exit(1);
call    0 never executed
        -: 1032:      }
    #####: 1033:      fclose(fp);
call    0 never executed
        -: 1034:    }
        -: 1035:  }
        -: 1036:
        1: 1037:  if(par->nLineImages>0 && par->traceRayAlgorithm==0 && !par->doPregrid){
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
branch  4 taken 100% (fallthrough)
branch  5 taken 0%
        1: 1038:    if(bitIsSet(defaultFuncFlags, USERFUNC_velocity)){
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####: 1039:      par->useVelFuncInRaytrace = FALSE;
    #####: 1040:      if(!silent) warning("No velocity function supplied - raytracing will have lower precision.");
branch  0 never executed
branch  1 never executed
call    2 never executed
        -: 1041:    }else
        1: 1042:      par->useVelFuncInRaytrace = TRUE;
        -: 1043:  }else
    #####: 1044:    par->useVelFuncInRaytrace = FALSE;
        -: 1045:
        -: 1046:#ifdef IS_PYTHON
        -: 1047:  if(par->nThreads>1 && par->useVelFuncInRaytrace){
        -: 1048:    par->useVelFuncInRaytrace = FALSE;
        -: 1049:    if(!silent)
        -: 1050:      warning("You cannot call a python velocity function when multi-threaded.");
        -: 1051:  }
        -: 1052:#endif
        -: 1053:
        1: 1054:  par->edgeVelsAvailable=0; /* default value, this is set within getEdgeVelocities(). */
        -: 1055:
        1: 1056:  if(!silent){
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        1: 1057:    if(par->lte_only){
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        1: 1058:        warning("LTE calculation requested\n");
call    0 returned 100%
    #####: 1059:    }else if(par->nSolveIters<=par->nSolveItersDone && !allBitsSet(par->dataFlags, DS_mask_populations)){
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####: 1060:      warning("No supplied pops values, and par->nSolveIters <= par->nSolveItersDone.");
call    0 never executed
        -: 1061:    }
        -: 1062:  }
        -: 1063:
        -: 1064:  /* Allocate moldata array.
        -: 1065:  */
        1: 1066:  if(par->nSpecies>0){
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        1: 1067:    mallocAndSetDefaultMolData(par->nSpecies, md);
call    0 returned 100%
        -: 1068:  } /* otherwise leave it at NULL - we will not be using it. */
        -: 1069:
        1: 1070:  if(par->samplingAlgorithm==0)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        1: 1071:    defaultDensyPower = DENSITY_POWER;
        -: 1072:  else
    #####: 1073:    defaultDensyPower = TREE_POWER;
        -: 1074:
        1: 1075:}
        -: 1076:
        -: 1077:/*....................................................................*/
function gridPopsInit called 1 returned 100% blocks executed 100%
        1: 1078:void gridPopsInit(configInfo *par, molData *md, struct grid *gp){
        -: 1079:  int i,id,ilev;
        -: 1080:
        2: 1081:  for(i=0;i<par->nSpecies;i++){
branch  0 taken 50% (fallthrough)
branch  1 taken 50%
        -: 1082:    /* Allocate space for populations etc */
      501: 1083:    for(id=0;id<par->ncell; id++){
branch  0 taken 100%
branch  1 taken 1% (fallthrough)
      500: 1084:      free(gp[id].mol[i].pops);
      500: 1085:      gp[id].mol[i].pops = malloc(sizeof(double)*md[i].nlev);
    13500: 1086:      for(ilev=0;ilev<md[i].nlev;ilev++)
branch  0 taken 96%
branch  1 taken 4% (fallthrough)
    13000: 1087:        gp[id].mol[i].pops[ilev] = 0.0;
        -: 1088:    }
        -: 1089:  }
        1: 1090:}
        -: 1091:
        -: 1092:/*....................................................................*/
function _printTestGridOutput called 0 returned 0% blocks executed 0%
    #####: 1093:void _printTestGridOutput(struct grid *gp, const int id, const int i, const int ilev){
    #####: 1094:  if(gp[id].mol==NULL){
branch  0 never executed
branch  1 never executed
    #####: 1095:    printf("gp[%d].mol==NULL!\n", id);
call    0 never executed
        -: 1096:  }else{
    #####: 1097:    printf("gp[%d].mol[%d].binv=%e\n", id, i, gp[id].mol[i].binv);
call    0 never executed
    #####: 1098:    printf("gp[%d].mol[%d].nmol=%e\n", id, i, gp[id].mol[i].nmol);
call    0 never executed
        -: 1099:
    #####: 1100:    if(gp[id].mol[i].pops==NULL)
branch  0 never executed
branch  1 never executed
    #####: 1101:      printf("gp[%d].mol[%d].pops==NULL\n", id, i);
call    0 never executed
        -: 1102:    else
    #####: 1103:      printf("gp[%d].mol[%d].pops[%d]=%e\n", id, i, ilev, gp[id].mol[i].pops[ilev]);
call    0 never executed
        -: 1104:
    #####: 1105:    if(gp[id].mol[i].specNumDens==NULL)
branch  0 never executed
branch  1 never executed
    #####: 1106:      printf("gp[%d].mol[%d].specNumDens==NULL\n", id, i);
call    0 never executed
        -: 1107:    else
    #####: 1108:      printf("gp[%d].mol[%d].specNumDens[%d]=%e\n", id, i, ilev, gp[id].mol[i].specNumDens[ilev]);
call    0 never executed
        -: 1109:
    #####: 1110:    if(gp[id].mol[i].cont==NULL)
branch  0 never executed
branch  1 never executed
    #####: 1111:      printf("gp[%d].mol[%d].cont==NULL\n", id, i);
call    0 never executed
        -: 1112:    else{
    #####: 1113:      printf("gp[%d].mol[%d].cont[%d].dust=%e\n", id, i, ilev, gp[id].mol[i].cont[ilev].dust);
call    0 never executed
    #####: 1114:      printf("gp[%d].mol[%d].cont[%d].knu=%e\n",  id, i, ilev, gp[id].mol[i].cont[ilev].knu);
call    0 never executed
        -: 1115:    }
        -: 1116:  }
    #####: 1117:  printf("\n");
call    0 never executed
    #####: 1118:}
        -: 1119:
        -: 1120:/*....................................................................*/
        -: 1121:int
function run called 1 returned 100% blocks executed 75%
        1: 1122:run(inputPars inpars, image *inimg, const int nImages){
        -: 1123:  /* Run LIME with inpars and the output fits files specified.
        -: 1124:
        -: 1125:     This routine may be used as an interface to LIME from external
        -: 1126:     programs. In this case, inpars and img must be specified by the
        -: 1127:     external program.
        -: 1128:  */
        -: 1129:  int i,j,gi,si,ei,status=0,sigactionStatus=0;
        1: 1130:  double initime=time(0);
call    0 returned 100%
        1: 1131:  int popsdone=0,nExtraSolverIters=0;
        1: 1132:  molData *md=NULL;
        -: 1133:  configInfo par;
        1: 1134:  imageInfo *img=NULL;
        1: 1135:  struct grid *gp=NULL;
        -: 1136:  char message[STR_LEN_0];
        1: 1137:  int nEntries=0;
        1: 1138:  double *lamtab=NULL,*kaptab=NULL;
        -: 1139:  double *radii, current;
        -: 1140:  int *gp_sorted;
        -: 1141:
        1: 1142:  struct sigaction sigact = {.sa_handler = sigintHandler};
        1: 1143:  sigactionStatus = sigaction(SIGINT, &sigact, NULL);
call    0 returned 100%
        1: 1144:  if(sigactionStatus){
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####: 1145:    if(!silent){
branch  0 never executed
branch  1 never executed
    #####: 1146:      snprintf(message, STR_LEN_0, "Call to sigaction() returned with status %d", sigactionStatus);
    #####: 1147:      bail_out(message);
call    0 never executed
        -: 1148:    }
    #####: 1149:exit(1);
call    0 never executed
        -: 1150:  }
        -: 1151:
        -: 1152:  /*Set locale to avoid trouble when reading files*/
        1: 1153:  setlocale(LC_ALL, "C");
call    0 returned 100%
        -: 1154:
        1: 1155:  if(!silent) greetings();
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
        1: 1156:  if(!silent) screenInfo();
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
        -: 1157:
        -: 1158:#ifdef FASTEXP
        1: 1159:  calcExpTableEntries(FAST_EXP_MAX_TAYLOR, FAST_EXP_NUM_BITS);
call    0 returned 100%
        -: 1160:#endif
        1: 1161:  fillErfTable();
call    0 returned 100%
        -: 1162:
        1: 1163:  parseInput(inpars, inimg, nImages, &par, &img, &md, TRUE); /* Sets par.numDensities for !(par.doPregrid || par.restart) */
call    0 returned 100%
        -: 1164:
        1: 1165:  if(par.restart){
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####: 1166:    par.doSolveRTE = FALSE;
    #####: 1167:    par.doMolCalcs = (par.nLineImages>0);
        -: 1168:
        -: 1169:  }else{
        -: 1170://    if(par.nSolveIters>0 || par.lte_only) /* To save the user having to set par.doSolveRTE as well as par.nSolveIters>0 or par.lte_only. */
       1*: 1171:    if(par.nSolveIters>par.nSolveItersDone || par.lte_only) /* To save the user having to set par->doSolveRTE as well as par->nSolveIters>0 or par->lte_only. */
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
branch  2 never executed
branch  3 never executed
        1: 1172:      par.doSolveRTE = TRUE;
        -: 1173:
       1*: 1174:    par.doMolCalcs = par.doSolveRTE || par.nLineImages>0;
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
branch  2 never executed
branch  3 never executed
        1: 1175:    if(par.doMolCalcs && par.moldatfile==NULL){
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
    #####: 1176:      if(!silent) bail_out("You must point par->moldatfile to a data file.");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####: 1177:exit(1);
call    0 never executed
        -: 1178:    }
        -: 1179:  }
        -: 1180:
       1*: 1181:  if(!silent && !par.doMolCalcs && par.init_lte)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
branch  4 never executed
branch  5 never executed
    #####: 1182:    warning("Your choice of par.init_lte will have no effect.");
call    0 never executed
        -: 1183:
        1: 1184:  if(par.nSpecies>0 && !par.doMolCalcs){
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
    #####: 1185:    if(!silent) bail_out("If you want only continuum calculations you must supply zero moldatfiles.");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####: 1186:exit(1);
call    0 never executed
        -: 1187:  }
        -: 1188:
        -: 1189:/*Original if-else statement contained dead code and was deleted*/
        1: 1190:    checkUserDensWeights(&par); /* In collparts.c. Needs par.numDensities. */
call    0 returned 100%
        1: 1191:    readOrBuildGrid(&par,&gp);
call    0 returned 100%
        -: 1192:
        1: 1193:  if(par.dust != NULL)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####: 1194:    readDustFile(par.dust, &lamtab, &kaptab, &nEntries);
call    0 never executed
        -: 1195:
        -: 1196:  /* Make all the continuum images:
        -: 1197:  */
        1: 1198:  if(par.nContImages>0){
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####: 1199:    for(i=0;i<par.nImages;i++){
branch  0 never executed
branch  1 never executed
    #####: 1200:      if(!img[i].doline){
branch  0 never executed
branch  1 never executed
    #####: 1201:        raytrace(i, &par, gp, md, img, lamtab, kaptab, nEntries, radii);
call    0 never executed
    #####: 1202:        writeFitsAllUnits(i, &par, img);
call    0 never executed
        -: 1203:      }
        -: 1204:    }
        -: 1205:  }
        -: 1206:
        1: 1207:  if(par.doMolCalcs){
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        1: 1208:    if(!popsdone){
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        1: 1209:      molInit(&par, md);
call    0 returned 100%
        1: 1210:      calcGridMolDoppler(&par, md, gp);
call    0 returned 100%
        -: 1211:    }
        1: 1212:    if(par.useAbun)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####: 1213:      calcGridMolDensities(&par, &gp);
call    0 never executed
        -: 1214:
      501: 1215:    for(gi=0;gi<par.ncell;gi++){
branch  0 taken 100% (fallthrough)
branch  1 taken 1%
     1000: 1216:      for(si=0;si<par.nSpecies;si++){
branch  0 taken 50%
branch  1 taken 50% (fallthrough)
      500: 1217:        gp[gi].mol[si].specNumDens = malloc(sizeof(double)*md[si].nlev);
      500: 1218:        gp[gi].mol[si].pops        = malloc(sizeof(double)*md[si].nlev);
    13500: 1219:        for(ei=0;ei<md[si].nlev;ei++){
branch  0 taken 96%
branch  1 taken 4% (fallthrough)
    13000: 1220:          gp[gi].mol[si].specNumDens[ei] = 0.0;
    13000: 1221:          gp[gi].mol[si].pops[ei] = 0.0;
        -: 1222:        }
        -: 1223:      }
        -: 1224:    }
        -: 1225: 
        1: 1226:    radii = malloc(sizeof(double)*par.pIntensity);
        1: 1227:    gp_sorted = malloc(sizeof(int)*par.pIntensity);
        -: 1228:    
      501: 1229:    for (gi = 0;gi < par.pIntensity;gi++) {
branch  0 taken 100%
branch  1 taken 1% (fallthrough)
      500: 1230:     radii[gi] = gp[gi].radius; //Note: not sorted yet
        -: 1231:    }
        -: 1232:
        1: 1233:    qsort(radii, par.pIntensity, sizeof(double), compare);
call    0 returned 100%
        -: 1234:
      501: 1235:    for(i=0;i<par.pIntensity;i++){
branch  0 taken 100%
branch  1 taken 1% (fallthrough)
      500: 1236:    current = radii[i];
   250500: 1237:    for(j=0;j<par.pIntensity;j++)
branch  0 taken 100%
branch  1 taken 1% (fallthrough)
   250000: 1238:      if(current==gp[j].radius)
branch  0 taken 1% (fallthrough)
branch  1 taken 100%
      500: 1239:        gp_sorted[i] = j; //holds sorted ids according to the time(radius) of its corresponding gridpoint
        -: 1240:  }
        -: 1241:     
        1: 1242:    if(par.doSolveRTE){
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        1: 1243:      gridPopsInit(&par,md,gp);
call    0 returned 100%
        1: 1244:      nExtraSolverIters = levelPops(md, &par, gp, &popsdone, lamtab, kaptab, nEntries, radii, gp_sorted);
call    0 returned 100%
        -: 1245:    }
        -: 1246:
        1: 1247:    calcGridMolSpecNumDens(&par,md,gp);
call    0 returned 100%
        -: 1248:
        1: 1249:    par.nSolveItersDone += nExtraSolverIters;
        -: 1250:  }
        -: 1251:
        1: 1252:  if(onlyBitsSet(par.dataFlags & DS_mask_all_but_mag, DS_mask_3))
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####: 1253:    writeGridIfRequired(&par, gp, NULL, 3);
call    0 never executed
        1: 1254:  else if(onlyBitsSet(par.dataFlags & DS_mask_all_but_mag, DS_mask_5)){
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
        1: 1255:    writeGridIfRequired(&par, gp, md, 5);
call    0 returned 100%
    #####: 1256:  }else if(!silent){
branch  0 never executed
branch  1 never executed
    #####: 1257:    snprintf(message, STR_LEN_0, "Data flags %x match neither mask 3 %x (cont.) or 5 %x (line).", par.dataFlags, DS_mask_3, DS_mask_5);
    #####: 1258:    warning(message);
call    0 never executed
        -: 1259:  }
        -: 1260:
        1: 1261:  freeSomeGridFields((unsigned int)par.ncell, (unsigned short)par.nSpecies, gp);
call    0 returned 100%
        -: 1262:
        -: 1263:  /* Now make the line images.
        -: 1264:  */
        1: 1265:  if(par.nLineImages>0){
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        2: 1266:    for(i=0;i<par.nImages;i++){
branch  0 taken 50%
branch  1 taken 50% (fallthrough)
        1: 1267:      if(img[i].doline){
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        1: 1268:        raytrace(i, &par, gp, md, img, lamtab, kaptab, nEntries, radii);
call    0 returned 100%
        1: 1269:        writeFitsAllUnits(i, &par, img);
call    0 returned 100%
        -: 1270:      }
        -: 1271:    }
        -: 1272:  }
        -: 1273:
        1: 1274:  if(!silent){
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        1: 1275:    if(par.nImages>0) reportOutput(img[0].filename);
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
        1: 1276:    goodnight(initime);
call    0 returned 100%
        -: 1277:  }
        -: 1278:
        1: 1279:  freeGrid((unsigned int)par.ncell, (unsigned short)par.nSpecies, gp);
call    0 returned 100%
        1: 1280:  freeMolData(par.nSpecies, md);
call    0 returned 100%
        1: 1281:  freeImgInfo(par.nImages, img);
call    0 returned 100%
        1: 1282:  freeConfigInfo(&par);
call    0 returned 100%
        -: 1283:
        1: 1284:  if(par.dust != NULL){
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####: 1285:    free(kaptab);
    #####: 1286:    free(lamtab);
        -: 1287:  }
        -: 1288:
        1: 1289:  return status; /* This is a bit of a placeholder for now. Ideally we would like all the functions called to return status values rather than exiting. This would allow python-calling versions of Lime to exit 'nicely' at the top level. */
        -: 1290:}
        -: 1291:
