aux.c:  if (fabs(dTau)<par->taylorCutoff){
aux.c:  if (fabs(dTau)<par->taylorCutoff){
aux.c:  if(par->collPartUserSetFlags==0){ /* this means the user did not set any of the collision-partner-related parameters. Use the old formula. */
aux.c:    for(di=0;di<par->numDensities;di++)
aux.c:      gasMassDensityAMUs += dens[di]*par->collPartMolWeights[di];
collparts.c:We have three sources of information about the density and type of bulk gas (a.k.a. collision partner) species: (i) the number of elements returned by the density() function; (ii) the list par->collPartIds; (iii) and the transition rate values supplied in the moldatfiles. What we want to do is associate density functions with collision partners given in the moldatfiles. We would like to do this if possible without deviating from the original assumptions made in the earliest versions of LIME, and without loading the user down with too much crud.
collparts.c:Below is given a typical timeline of processing within LIME, showing for each stage the questions which the code asks about par->collPartIds and the moldatfiles, and the decisions taken in response.
collparts.c:  par->collPartIds (a struct of type 'configInfo') is malloc'd to size MAX_N_COLL_PART and the inpars values are copied over.
collparts.c:  - The number of >0 (therefore user-set) values of par->collPartIds are counted. Counting starts from the 0th element and stops as soon as the first <=0 value is found.
collparts.c:  - The number of user-set values of par->collPartIds is compared to the number of density() function returns (by now stored in par->numDensities). If the numbers are unequal, par->collPartIds is freed and set to NULL (a warning is issued if the user set some values). If the numbers match, par->collPartIds is reallocated in size to that number (this is possibly unnecessary).
collparts.c:  - If the user has supplied par->collPartNames, with the number of entries correctly matching the number of density() returns (par->numDensities), in the case that par->collPartIds was set to NULL just above, then par->collPartIds is malloc'd to size par->numDensities; it is loaded then with an increasing sequence of integers.
collparts.c:  - par->collPartIds, if set, are checked for uniqueness.
collparts.c:  - The collision partners listed in the set of moldatfiles are read from file. Here we first want to compile a list of unique (that is, without repetition) collision partners that occur in the files. We will only do this however if either (i) the user has supplied no values of par->collPartIds or (ii) the collision partner matches one supplied in par->collPartIds.
collparts.c:  - The processing in this looks quite complicated, but the only thing that is done to par->collPartIds is if it ==NULL: it is then malloc'd to size par->numDensities and, under limited circumstances, its values are set to those read from the moldatfiles.
collparts.c:  - par->collPartIds is compared here to the collision partner IDs in md[i].part[ipart].collPartId. If a CP is found in par->collPartIds but not in md[i].part, no action is taken. If any md[i].part[ipart].collPartId is not found in par->collPartIds, md[i].part[ipart].densityIndex is set to -1. This flags to solver.getFixedMatrix() to ignore the respective transition rates.
collparts.c:This deals with four user-settable list parameters which relate to collision partners and their number densities: par->collPartIds, par->nMolWeights, par->collPartMolWeights and par->collPartNames. We have to see if these (optional) parameters were set, do some basic checks on them, and if they were set make sure they match the number of density values, which by this time should be stored in par->numDensities.
collparts.c:	* par->collPartIds: this list acts as a link between the N density function returns (I'm using here N as shorthand for par->numDensities) and the M collision partner ID integers found in the moldatfiles. This allows us to associate density functions with the collision partner transition rates provided in the moldatfiles.
collparts.c:	* par->collPartNames: essentially this has only cosmetic importance since it has no effect on the functioning of LIME, only on the names of the collision partners which are printed to stdout. Its main purpose is to reassure the user who has provided transition rates for a non-LAMDA collision species in their moldatfile that they are actually getting these values and not some mysterious reversion to LAMDA.
collparts.c:		0	1	par->collPartIds is constructed to contain integers in a sequence from 1 to N. Naturally the user should write matching collision partner ID integers in their moldatfiles.
collparts.c:	* par->collPartMolWeights: this MUST be present if par->collPartNames has been supplied, and it MUST then have the same number and order of elements as all the other collision-partner lists. If this parameter is supplied but par->collPartNames not, it will be ignored.
collparts.c:	* par->nMolWeights: this list gives the weights to be applied to the N density values when calculating molecular densities from abundances.
collparts.c:  par->collPartUserSetFlags = 0;
collparts.c:  while(i<MAX_N_COLL_PART && par->collPartIds[i]>0) i++;
collparts.c:  if(i>0) par->collPartUserSetFlags |= (1<<CPF_BIT_ids);
collparts.c:  while(i<MAX_N_COLL_PART && par->nMolWeights[i]>=0.0) i++;
collparts.c:  if(i>0) par->collPartUserSetFlags |= (1<<CPF_BIT_weights);
collparts.c:  while(i<MAX_N_COLL_PART && par->collPartNames[i]!=NULL) i++;
collparts.c:  if(i>0) par->collPartUserSetFlags |= (1<<CPF_BIT_names);
collparts.c:  while(i<MAX_N_COLL_PART && par->collPartMolWeights[i]>=0) i++;
collparts.c:  if(i>0) par->collPartUserSetFlags |= (1<<CPF_BIT_MolWeights);
collparts.c:  /* Check that we have either 0 par->collPartIds or the same number as the number of density values. If not, the par->collPartIds values the user set will be thrown away, the pointer will be reallocated, and new values will be written to it in setUpDensityAux(), taken from the values in the moldatfiles.
collparts.c:  if(numUserSetCPIds != par->numDensities){
collparts.c:    free(par->collPartIds);
collparts.c:    par->collPartIds = NULL;
collparts.c:    /* Note that in the present case we will (for a line-emission image) look for the collision partners listed in the moldatfiles and set par->collPartIds from them. For that to happen, we require the number of collision partners found in the files to equal par->numDensities. */
collparts.c:    par->collPartIds = realloc(par->collPartIds, sizeof(*(par->collPartIds))*par->numDensities);
collparts.c:  /* Check if we have either 0 par->nMolWeights or the same number as the number of density values.
collparts.c:  if(numUserSetNMWs != par->numDensities){
collparts.c:    free(par->nMolWeights);
collparts.c:    par->nMolWeights = NULL;
collparts.c:    /* Note that in the present case we will (for a line-emission image) look for the collision partners listed in the moldatfiles and set par->nMolWeights from them. */
collparts.c:      if(!silent) warning("par->nMolWeights will be ignored - there should be 1 for each density() return.");
collparts.c:    par->nMolWeights = realloc(par->nMolWeights, sizeof(*(par->nMolWeights))*par->numDensities);
collparts.c:  /* Re the interaction between par->collPartIds and par->collPartNames: the possible scenarios are given in the function header.
collparts.c:  if(numUserSetCPNames != par->numDensities){
collparts.c:    for(i=0;i<MAX_N_COLL_PART;i++) free(par->collPartNames[i]);
collparts.c:    free(par->collPartNames);
collparts.c:    par->collPartNames = NULL;
collparts.c:      if(!silent) warning("par->collPartNames will be ignored - there should be 1 for each density() return.");
collparts.c:  }else{ /* If we get to here, then numUserSetCPNames==par->numDensities. */
collparts.c:    for(i=par->numDensities;i<MAX_N_COLL_PART;i++){
collparts.c:      free(par->collPartNames[i]);
collparts.c:    par->collPartNames = realloc(par->collPartNames, sizeof(*(par->collPartNames))*par->numDensities);
collparts.c:    if(numUserSetCPIds<=0){ /* This implies that we must have set par->collPartIds=NULL a little above here. */
collparts.c:      par->collPartIds = malloc(sizeof(*(par->collPartIds))*par->numDensities);
collparts.c:      for(i=0;i<par->numDensities;i++)
collparts.c:        par->collPartIds[i] = i+1;
collparts.c://**** Won't this go wrong when the collPartIds read from moldatfiles are compared to par->collPartIds in molinit.readMolData()??
collparts.c:      numUserSetCPIds = par->numDensities;
collparts.c:  if(numUserSetCPWeights != par->numDensities || numUserSetCPNames <= 0){
collparts.c:    free(par->collPartMolWeights);
collparts.c:    par->collPartMolWeights = NULL;
collparts.c:        if(!silent) warning("par->collPartMolWeights will be ignored - you must also set par->collPartNames.");
collparts.c:        if(!silent) warning("par->collPartMolWeights will be ignored - there should be 1 for each density() return.");
collparts.c:    par->collPartMolWeights = realloc(par->collPartMolWeights, sizeof(*(par->collPartMolWeights))*par->numDensities);
collparts.c:        if(par->collPartIds[i]==uniqueCPIds[j]){
collparts.c:      uniqueCPIds[i] = par->collPartIds[i];
collparts.c:      sum += par->nMolWeights[i];
collparts.c:The present function, which needs to be called only if we have to calculate the energy level populations at the grid points, deals with the user-settable vectors par->collPartIds and par->nMolWeights. The former of these is used to associate density values with collision-partner species, and the latter is used in converting, for each radiating species, its abundance to a number density, stored respectively in the grid struct attributes abun and nmol. The function deals specifically with the case in which the user has either not set par->collPartIds or par->nMolWeights at all (which they may choose to do), or has set them incorrectly. In either case the respective parameter will have been freed and set to NULL in checkUserDensWeights(). The function tries its best to guess likely values for the parameters, in line with the algorithm used in the code before par->collPartIds and par->nMolWeights were introduced.
collparts.c:  if(par->collPartIds==NULL){ /* For this to happen means that the user set neither par->collPartIds nor par->collPartNames. */
collparts.c:To preserve backward compatibility I am going to try to make the same guesses as were made before par->collPartIds was introduced, but this is made tricky by the fact that the switch block in the previous code did not cover all possibilities. I'm going to add some warnings too. We want users to be able to run their old model.c files for as long as possible, but at the same time urge them to make use of the new facility for specifying par->collPartIds.
collparts.c:    if(par->numDensities > numUniqueCollParts){
collparts.c:        par->collPartIds = malloc(sizeof(int)*par->numDensities); /* par->numDensities must ==1 at this point. */
collparts.c:        par->collPartIds[0] = allUniqueCollPartIds[0];
collparts.c:        par->collPartIds = malloc(sizeof(int)*par->numDensities);
collparts.c:        for(i=0;i<par->numDensities;i++) /* At this point par->numDensities can be only ==1 (previously signalled via 'flag') or ==2. */
collparts.c:          par->collPartIds[i] = allUniqueCollPartIds[i];
collparts.c:        if(par->numDensities==1 && !silent) warning("Calculating molecular density with respect to first collision partner only.");
collparts.c:    }else if(numUniqueCollParts==par->numDensities){ /* At this point, numUniqueCollParts must be >2. */
collparts.c:      par->collPartIds = malloc(sizeof(int)*par->numDensities);
collparts.c:      for(i=0;i<par->numDensities;i++)
collparts.c:        par->collPartIds[i] = allUniqueCollPartIds[i];
collparts.c:    }else{ /* numUniqueCollParts>2 && par->numDensities<numUniqueCollParts */
collparts.c:      for(i=0;i<par->numDensities;i++){
collparts.c:        snprintf(message, STR_LEN_0, "  Collision partner %d assigned code %d (=%s)\n", i, par->collPartIds[i], lamdaNames[par->collPartIds[i]-1]);
collparts.c:    if(par->nMolWeights==NULL){
collparts.c:The same backward-compatible guesses are made here as for par->collPartIds in the foregoing section of code. I've omitted warnings and errors because they have already been issued during the treatment of par->collPartIds.
collparts.c:          par->nMolWeights = malloc(sizeof(double)*par->numDensities);
collparts.c:          par->nMolWeights[0] = 1.0;
collparts.c:          par->nMolWeights = malloc(sizeof(double)*par->numDensities);
collparts.c:          for(i=0;i<par->numDensities;i++) /* At this point par->numDensities can be only ==1 (previously signalled via 'flag') or ==2. */
collparts.c:            par->nMolWeights[i] = 1.0;
collparts.c:      }else if(numUniqueCollParts==par->numDensities){ /* At this point, numUniqueCollParts must be >2. */
collparts.c:        par->nMolWeights = malloc(sizeof(double)*par->numDensities);
collparts.c:        for(i=0;i<par->numDensities;i++)
collparts.c:          par->nMolWeights[i] = 0.0;
collparts.c:        par->nMolWeights[0] = 1.0;
collparts.c:        par->nMolWeights[1] = 1.0;
collparts.c:  }else if(par->nMolWeights==NULL){ /* We get here only if the user has not supplied these values (or not supplied the right number of them) in their model.c. */
collparts.c:    if(par->numDensities==1){
collparts.c:      if(par->collPartIds[0]==CP_H2 || par->collPartIds[0]==CP_p_H2 || par->collPartIds[0]==CP_o_H2){
collparts.c:        par->nMolWeights = malloc(sizeof(double)*par->numDensities);
collparts.c:        par->nMolWeights[0] = 1.0;
collparts.c:    }else if(par->numDensities==2){
collparts.c:      if((par->collPartIds[0]==CP_p_H2 && par->collPartIds[1]==CP_o_H2)\
collparts.c:      || (par->collPartIds[1]==CP_p_H2 && par->collPartIds[0]==CP_o_H2)){
collparts.c:        par->nMolWeights = malloc(sizeof(double)*par->numDensities);
collparts.c:        for(i=0;i<par->numDensities;i++){
collparts.c:          par->nMolWeights[i] = 1.0;
collparts.c:    }else{ /* par->numDensities>2 */
collparts.c:      par->nMolWeights = malloc(sizeof(double)*par->numDensities);
collparts.c:      for(i=0;i<par->numDensities;i++){
collparts.c:        par->nMolWeights[i] = 0.0;
collparts.c:      par->nMolWeights[0] = 1.0;
collparts.c:      par->nMolWeights[1] = 1.0;
collparts.c:  /* If we get to here then par->collPartIds has definitely been malloc'd and its values set.
collparts.c://*** check that no par->collPartIds[i] are out of lamda range.
collparts.c:  if(par->collPartNames==NULL){ /* Then load it from the LAMDA names. */
collparts.c:    par->collPartNames=malloc(sizeof(*par->collPartNames)*par->numDensities);
collparts.c:    for(i=0;i<par->numDensities;i++)
collparts.c:      copyInparStr(lamdaNames[par->collPartIds[i]-1], &(par->collPartNames[i]));
collparts.c:  if(par->collPartMolWeights==NULL){ /* Then load it from the LAMDA mol weights. */
collparts.c:    par->collPartMolWeights=malloc(sizeof(*par->collPartMolWeights)*par->numDensities);
collparts.c:    for(i=0;i<par->numDensities;i++)
collparts.c:      par->collPartMolWeights[i] = lamdaMolWeights[par->collPartIds[i]-1];
collparts.h:/* Bit codes for par->collPartUserSetFlags */
defaults.c:  - The present function is interpreted by LIME as giving *relative* probabilities, the ultimate normalization being set by the desired number of grid points conveyed to the task via par->pIntensity.
defaults.c:  - If par->samplingAlgorithm is chosen to be zero (the current default value), further manipulations to the probability distribution are performed according to the set value of par->sampling.
defaults.c:  if(rSquared>=par->radiusSqu)
defaults.c:  for (i=0;i<par->numDensities;i++) totalDensity += val[i];
defaults.c:  fracDensity = pow(totalDensity,defaultDensyPower)/par->gridDensGlobalMax;
frees.c:  free(par->nMolWeights);
frees.c:  free(par->collPartMolWeights);
frees.c:  free(par->collPartIds);
frees.c:  free(par->outputfile);
frees.c:  free(par->binoutputfile);
frees.c:  free(par->gridfile);
frees.c:  free(par->pregrid);
frees.c:  free(par->restart);
frees.c:  free(par->dust);
frees.c:  free(par->gridDensMaxValues);
frees.c:  free(par->gridDensMaxLoc);
frees.c:  free(par->gridInFile);
frees.c:  if(par->collPartNames!= NULL){
frees.c:    for(i=0;i<par->numDensities;i++)
frees.c:      free(par->collPartNames[i]);
frees.c:    free(par->collPartNames);
frees.c:  if(par->moldatfile!= NULL){
frees.c:    for(i=0;i<par->nSpecies;i++)
frees.c:      free(par->moldatfile[i]);
frees.c:    free(par->moldatfile);
frees.c:  if(par->girdatfile!= NULL){
frees.c:    for(i=0;i<par->nSpecies;i++)
frees.c:      free(par->girdatfile[i]);
frees.c:    free(par->girdatfile);
frees.c:  if(par->gridOutFiles!= NULL){
frees.c:      free(par->gridOutFiles[i]);
frees.c:    free(par->gridOutFiles);
frees.c:  free(par->collPartIds);
frees.c:  free(par->nMolWeights);
frees.c:  free(par->dustWeights);
frees.c:  free(par->collPartMolWeights);
frees.c:  free(par->moldatfile);
frees.c:  free(par->girdatfile);
frees.c:  free(par->collPartNames);
frees.c:  free(par->gridOutFiles);
frees.c:  free(par->gridDensMaxValues);
frees.c:  free(par->gridDensMaxLoc);
grid.c:  if(anyBitSet(par->dataFlags, (DS_mask_all & ~(1 << DS_bit_x))) && !bitIsSet(par->dataFlags, DS_bit_x)){
grid.c:  if(bitIsSet(par->dataFlags, DS_bit_ACOEFF)\
grid.c:  && !(bitIsSet(par->dataFlags, DS_bit_neighbours) && bitIsSet(par->dataFlags, DS_bit_velocity))){
grid.c:  if(bitIsSet(par->dataFlags, DS_bit_populations)\
grid.c:  && !allBitsSet(par->dataFlags & DS_mask_all_but_mag, DS_mask_populations)){
grid.c:  if(gridInfoRead.nSinkPoints>0 && par->sinkPoints>0){
grid.c:    if((int)gridInfoRead.nSinkPoints!=par->sinkPoints){
grid.c:      if(!silent) warning("par->sinkPoints will be overwritten");
grid.c:    if((int)gridInfoRead.nInternalPoints!=par->pIntensity){
grid.c:      if(!silent) warning("par->pIntensity will be overwritten");
grid.c:  par->sinkPoints = 0;//(int)gridInfoRead.nSinkPoints;
grid.c:  par->pIntensity = (int)gridInfoRead.nInternalPoints;
grid.c:  par->ncell = par->pIntensity;
grid.c:    if((int)gridInfoRead.nSpecies!=par->nSpecies && par->doMolCalcs){
grid.c:          , (int)gridInfoRead.nSpecies, par->nSpecies);
grid.c:  if(gridInfoRead.nDensities>0 && par->numDensities>0 && (int)gridInfoRead.nDensities!=par->numDensities){
grid.c:        , (int)gridInfoRead.nDensities, par->numDensities);
grid.c:  if(par->nSolveItersDone>0 && (par->init_lte || par->lte_only)){
grid.c:  if(allBitsSet(par->dataFlags, DS_mask_populations) && par->nSolveItersDone<=0){
grid.c:      bail_out("Populations were read but par->nSolveItersDone<=0.");
grid.c:  status = readGrid(par->gridInFile, &gridInfoRead, desiredKwds\
grid.c:    , numDesiredKwds, gp, collPartNames, numCollPartRead, &(par->dataFlags));
grid.c:  par->radius          = desiredKwds[0].doubleValue;
grid.c:  par->minScale        = desiredKwds[1].doubleValue;
grid.c:  par->nSolveItersDone = desiredKwds[2].intValue;
grid.c:  par->radiusSqu   = par->radius*par->radius;
grid.c:  par->minScaleSqu = par->minScale*par->minScale;
grid.c:  if(par->gridfile) write_VTK_unstructured_Points(par, g);
grid.c:  double logmin; /* Logarithm of par->minScale. */
grid.c:  lograd=log10(par->radius);
grid.c:  logmin=log10(par->minScale);
grid.c:   //Forcing the smallest grid point radius to be equal to par->minScale
grid.c:   x[2]=par->minScale;
grid.c:  par->dataFlags = 0;
grid.c:  if(par->gridInFile!=NULL){
grid.c:  } /* End of read grid file. Whether and what we subsequently calculate will depend on the value of par->dataStageI returned. */
grid.c:Note that we need density and temperature values whether par->doMolCalcs or not.
grid.c:  if(!allBitsSet(par->dataFlags, DS_mask_density)){
grid.c:  if(!allBitsSet(par->dataFlags, DS_mask_temperatures)){
grid.c:  par->useAbun = 1; /* This will remain so if the abun values have been read from file. */
grid.c:  if(par->doMolCalcs){
grid.c:    if(!allBitsSet(par->dataFlags, DS_mask_abundance)){
grid.c:        par->useAbun = 0;
grid.c:        par->useAbun = 1;
grid.c:    if(!allBitsSet(par->dataFlags, DS_mask_turb_doppler)){
grid.c:    if(!allBitsSet(par->dataFlags, DS_mask_velocity)){
grid.c:    if(!allBitsSet(par->dataFlags, DS_mask_ACOEFF)){
grid.c://    if(!par->restart && !(par->lte_only && !allBitsSet(par->dataFlags, DS_mask_populations))){
grid.c:    if(!par->lte_only && allBitsSet(par->dataFlags, DS_mask_populations) && par->doSolveRTE){
grid.c:I don't understand the basis of the commented-out variant (e.g. we certainly won't arrive at this point if par->restart==TRUE), thus I can't be certain if it was right to modify it or not.
grid.c:      if(par->nSolveIters<=par->nSolveItersDone){
grid.c:          snprintf(message, STR_LEN_0, "par->nSolveIters %d must be > par->nSolveItersDone %d", par->nSolveIters, par->nSolveItersDone);
grid.c:  } /* End if par->doMolCalcs */
grid.c:  if(!anyBitSet(par->dataFlags, DS_mask_x)){ /* This should only happen if we did not read a file. Generate the grid point locations. */
grid.c:    mallocAndSetDefaultGrid(gp, (size_t)par->ncell, (size_t)par->nSpecies);
grid.c:    outRandDensities = malloc(sizeof(double   )*par->pIntensity); /* Not used at present; and in fact they are not useful outside this routine, because they are not the values of the physical density at that point, just what densityFunc3D() returns, which is not necessarily the same thing. */
grid.c:    outRandLocations = malloc(sizeof(*outRandLocations)*par->pIntensity);
grid.c:    if(par->samplingAlgorithm==0){
grid.c:      randomsViaRejection(par, (unsigned int)par->pIntensity, randGen, outRandLocations);
grid.c:    for(k=0;k<par->pIntensity;k++){
grid.c:    par->dataFlags |= DS_mask_1;
grid.c:  if(onlyBitsSet(par->dataFlags, DS_mask_1)) /* Only happens if (i) we read no file and have constructed this data within LIME, or (ii) we read a file at dataStageI==1. */
grid.c:   if(!allBitsSet(par->dataFlags, DS_mask_neighbours)){
grid.c:     par->dataFlags |= DS_mask_neighbours;
grid.c:  if(onlyBitsSet(par->dataFlags, DS_mask_2)) /* Only happens if (i) we read no file and have constructed this data within LIME, or (ii) we read a file at dataStageI==2. */
grid.c:  if(!allBitsSet(par->dataFlags, DS_mask_density)){
grid.c:    for(i=0;i<par->ncell; i++)
grid.c:      (*gp)[i].dens = malloc(sizeof(double)*par->numDensities);
grid.c:    for(i=0;i<par->pIntensity;i++)
grid.c:    for(i=par->pIntensity;i<par->ncell;i++){
grid.c:      for(j=0;j<par->numDensities;j++)
grid.c:    par->dataFlags |= DS_mask_density;
grid.c:  if(!allBitsSet(par->dataFlags, DS_mask_temperatures)){
grid.c:    for(i=0;i<par->pIntensity;i++)
grid.c:    for(i=par->pIntensity;i<par->ncell;i++){
grid.c:      (*gp)[i].t[0]=par->tcmb;
grid.c:      (*gp)[i].t[1]=par->tcmb;
grid.c:    par->dataFlags |= DS_mask_temperatures;
grid.c:  if(onlyBitsSet(par->dataFlags, DS_mask_3)) /* Only happens if (i) we read no file and have constructed this data within LIME, or (ii) we read a file at dataStageI==3. */
grid.c:  if(par->doMolCalcs){
grid.c:    if(!allBitsSet(par->dataFlags, DS_mask_abundance)){
grid.c:      dummyPointer = malloc(sizeof(*dummyPointer)*par->nSpecies);
grid.c:      if(par->useAbun){
grid.c:          for(si=0;si<par->nSpecies;si++)
grid.c:          for(si=0;si<par->nSpecies;si++){
grid.c:        for(i=0;i<par->pIntensity;i++){
grid.c:          for(si=0;si<par->nSpecies;si++)
grid.c:        for(i=par->pIntensity;i<par->ncell;i++){
grid.c:          for(si=0;si<par->nSpecies;si++)
grid.c:          for(si=0;si<par->nSpecies;si++)
grid.c:          for(si=0;si<par->nSpecies;si++){
grid.c:        for(i=0;i<par->pIntensity;i++){
grid.c:          for(si=0;si<par->nSpecies;si++)
grid.c:        for(i=par->pIntensity;i<par->ncell;i++){
grid.c:          for(si=0;si<par->nSpecies;si++)
grid.c:      par->dataFlags |= DS_mask_abundance;
grid.c:    if(!allBitsSet(par->dataFlags, DS_mask_turb_doppler)){
grid.c:      for(i=0;i<par->pIntensity;i++)
grid.c:      for(i=par->pIntensity;i<par->ncell;i++)
grid.c:      par->dataFlags |= DS_mask_turb_doppler;
grid.c:    if(!allBitsSet(par->dataFlags, DS_mask_velocity)){
grid.c:      for(i=0;i<par->pIntensity;i++)
grid.c:      par->dataFlags |= DS_mask_velocity;
grid.c:    if(!allBitsSet(par->dataFlags, DS_mask_ACOEFF)){
grid.c:      par->dataFlags |= DS_mask_ACOEFF;
grid.c:  } /* End if(par->doMolCalcs) */
grid.c:  if(!allBitsSet(par->dataFlags, DS_mask_magfield)){
grid.c:    if(par->polarization){
grid.c:      for(i=0;i<par->pIntensity;i++)
grid.c:      par->dataFlags |= DS_mask_magfield;
grid.c:      for(i=0;i<par->pIntensity;i++){
grid.c:    for(i=par->pIntensity;i<par->ncell;i++){
grid.c:  if(onlyBitsSet(par->dataFlags & DS_mask_all_but_mag, DS_mask_4)) /* Only happens if (i) we read no file and have constructed this data within LIME, or (ii) we read a file at dataStageI==4. */
grid_aux.c:  for(i=0;i<par->nSpecies;i++){
grid_aux.c:    for(id=0;id<par->ncell;id++) {
grid_aux.c:  for(id=0;id<par->ncell;id++){
grid_aux.c:    for(ispec=0;ispec<par->nSpecies;ispec++){
grid_aux.c:      for(i=0;i<par->numDensities;i++)
grid_aux.c:                                    *par->nMolWeights[i];
grid_aux.c:  for(gi=0;gi<par->ncell;gi++){
grid_aux.c:    for(ispec=0;ispec<par->nSpecies;ispec++){
grid_aux.c:  for(i=0;i<par->ncell;i++){
grid_aux.c:  pt_array=malloc(sizeof(coordT)*DIM*par->ncell);
grid_aux.c:  for(i=0;i<par->ncell;i++) {
grid_aux.c:  if((fp=fopen(par->gridfile, "w"))==NULL){
grid_aux.c:  fprintf(fp,"POINTS %d float\n",par->ncell);
grid_aux.c:  for(i=0; i<par->ncell; i++) {
grid_aux.c:  fprintf(fp,"POINT_DATA %d\n",par->ncell);
grid_aux.c:  for(i=0;i<par->ncell;i++){
grid_aux.c:  if(par->nSpecies>0){
grid_aux.c:    for(i=0;i<par->ncell;i++){
grid_aux.c:    for(i=0;i<par->ncell;i++){
grid_aux.c:  for(i=0;i<par->ncell;i++){
grid_aux.c:  for(i=0;i<par->ncell;i++){
grid_aux.c:  for(i=0;i<par->ncell;i++){
grid_aux.c:  par->edgeVelsAvailable = 1;
grid_aux.c:  gridInfo.nInternalPoints = par->pIntensity;
grid_aux.c:  gridInfo.nSinkPoints     = par->sinkPoints;
grid_aux.c:  gridInfo.nSpecies        = par->nSpecies;
grid_aux.c:  gridInfo.nDensities      = par->numDensities;
grid_aux.c:  primaryKwds[i].doubleValue = par->radius;
grid_aux.c:  primaryKwds[i].doubleValue = par->minScale;
grid_aux.c:  primaryKwds[i].intValue = par->nSolveItersDone;
grid_aux.c:    , gridInfo, primaryKwds, numKwds, gp, par->collPartNames, par->dataFlags);
grid_aux.c:  if(par->writeGridAtStage[dataStageI-1]){
grid_aux.c:    status = setupAndWriteGrid(par, gp, md, par->gridOutFiles[dataStageI-1]);
grid_old.c:  if(anyBitSet(par->dataFlags, (DS_mask_all & ~(1 << DS_bit_x))) && !bitIsSet(par->dataFlags, DS_bit_x)){
grid_old.c:  if(bitIsSet(par->dataFlags, DS_bit_ACOEFF)\
grid_old.c:  && !(bitIsSet(par->dataFlags, DS_bit_neighbours) && bitIsSet(par->dataFlags, DS_bit_velocity))){
grid_old.c:  if(bitIsSet(par->dataFlags, DS_bit_populations)\
grid_old.c:  && !allBitsSet(par->dataFlags & DS_mask_all_but_mag, DS_mask_populations)){
grid_old.c:  if(gridInfoRead.nSinkPoints>0 && par->sinkPoints>0){
grid_old.c:    if((int)gridInfoRead.nSinkPoints!=par->sinkPoints){
grid_old.c:      if(!silent) warning("par->sinkPoints will be overwritten");
grid_old.c:    if((int)gridInfoRead.nInternalPoints!=par->pIntensity){
grid_old.c:      if(!silent) warning("par->pIntensity will be overwritten");
grid_old.c:  par->sinkPoints = 0;//(int)gridInfoRead.nSinkPoints;
grid_old.c:  par->pIntensity = (int)gridInfoRead.nInternalPoints;
grid_old.c:  par->ncell = par->pIntensity;
grid_old.c:    if((int)gridInfoRead.nSpecies!=par->nSpecies && par->doMolCalcs){
grid_old.c:          , (int)gridInfoRead.nSpecies, par->nSpecies);
grid_old.c:  if(gridInfoRead.nDensities>0 && par->numDensities>0 && (int)gridInfoRead.nDensities!=par->numDensities){
grid_old.c:        , (int)gridInfoRead.nDensities, par->numDensities);
grid_old.c:  if(par->nSolveItersDone>0 && (par->init_lte || par->lte_only)){
grid_old.c:  if(allBitsSet(par->dataFlags, DS_mask_populations) && par->nSolveItersDone<=0){
grid_old.c:      bail_out("Populations were read but par->nSolveItersDone<=0.");
grid_old.c:  status = readGrid(par->gridInFile, &gridInfoRead, desiredKwds\
grid_old.c:    , numDesiredKwds, gp, collPartNames, numCollPartRead, &(par->dataFlags));
grid_old.c:  par->radius          = desiredKwds[0].doubleValue;
grid_old.c:  par->minScale        = desiredKwds[1].doubleValue;
grid_old.c:  par->nSolveItersDone = desiredKwds[2].intValue;
grid_old.c:  par->radiusSqu   = par->radius*par->radius;
grid_old.c:  par->minScaleSqu = par->minScale*par->minScale;
grid_old.c:  if(par->gridfile) write_VTK_unstructured_Points(par, g);
grid_old.c:  double logmin; /* Logarithm of par->minScale. */
grid_old.c:  lograd=log10(par->radius);
grid_old.c:  logmin=log10(par->minScale);
grid_old.c:   //Forcing the smallest grid point radius to be equal to par->minScale
grid_old.c:   x[2]=par->minScale;
grid_old.c:  par->dataFlags = 0;
grid_old.c:  if(par->gridInFile!=NULL){
grid_old.c:  } /* End of read grid file. Whether and what we subsequently calculate will depend on the value of par->dataStageI returned. */
grid_old.c:Note that we need density and temperature values whether par->doMolCalcs or not.
grid_old.c:  if(!allBitsSet(par->dataFlags, DS_mask_density)){
grid_old.c:  if(!allBitsSet(par->dataFlags, DS_mask_temperatures)){
grid_old.c:  par->useAbun = 1; /* This will remain so if the abun values have been read from file. */
grid_old.c:  if(par->doMolCalcs){
grid_old.c:    if(!allBitsSet(par->dataFlags, DS_mask_abundance)){
grid_old.c:        par->useAbun = 0;
grid_old.c:        par->useAbun = 1;
grid_old.c:    if(!allBitsSet(par->dataFlags, DS_mask_turb_doppler)){
grid_old.c:    if(!allBitsSet(par->dataFlags, DS_mask_velocity)){
grid_old.c:    if(!allBitsSet(par->dataFlags, DS_mask_ACOEFF)){
grid_old.c://    if(!par->restart && !(par->lte_only && !allBitsSet(par->dataFlags, DS_mask_populations))){
grid_old.c:    if(!par->lte_only && allBitsSet(par->dataFlags, DS_mask_populations) && par->doSolveRTE){
grid_old.c:I don't understand the basis of the commented-out variant (e.g. we certainly won't arrive at this point if par->restart==TRUE), thus I can't be certain if it was right to modify it or not.
grid_old.c:      if(par->nSolveIters<=par->nSolveItersDone){
grid_old.c:          snprintf(message, STR_LEN_0, "par->nSolveIters %d must be > par->nSolveItersDone %d", par->nSolveIters, par->nSolveItersDone);
grid_old.c:  } /* End if par->doMolCalcs */
grid_old.c:  if(!anyBitSet(par->dataFlags, DS_mask_x)){ /* This should only happen if we did not read a file. Generate the grid point locations. */
grid_old.c:    mallocAndSetDefaultGrid(gp, (size_t)par->ncell, (size_t)par->nSpecies);
grid_old.c:    outRandDensities = malloc(sizeof(double   )*par->pIntensity); /* Not used at present; and in fact they are not useful outside this routine, because they are not the values of the physical density at that point, just what densityFunc3D() returns, which is not necessarily the same thing. */
grid_old.c:    outRandLocations = malloc(sizeof(*outRandLocations)*par->pIntensity);
grid_old.c:    if(par->samplingAlgorithm==0){
grid_old.c:      randomsViaRejection(par, (unsigned int)par->pIntensity, randGen, outRandLocations);
grid_old.c:    for(k=0;k<par->pIntensity;k++){
grid_old.c:    par->dataFlags |= DS_mask_1;
grid_old.c:  if(onlyBitsSet(par->dataFlags, DS_mask_1)) /* Only happens if (i) we read no file and have constructed this data within LIME, or (ii) we read a file at dataStageI==1. */
grid_old.c:   if(!allBitsSet(par->dataFlags, DS_mask_neighbours)){
grid_old.c:     par->dataFlags |= DS_mask_neighbours;
grid_old.c:  if(onlyBitsSet(par->dataFlags, DS_mask_2)) /* Only happens if (i) we read no file and have constructed this data within LIME, or (ii) we read a file at dataStageI==2. */
grid_old.c:  if(!allBitsSet(par->dataFlags, DS_mask_density)){
grid_old.c:    for(i=0;i<par->ncell; i++)
grid_old.c:      (*gp)[i].dens = malloc(sizeof(double)*par->numDensities);
grid_old.c:    for(i=0;i<par->pIntensity;i++)
grid_old.c:    for(i=par->pIntensity;i<par->ncell;i++){
grid_old.c:      for(j=0;j<par->numDensities;j++)
grid_old.c:    par->dataFlags |= DS_mask_density;
grid_old.c:  if(!allBitsSet(par->dataFlags, DS_mask_temperatures)){
grid_old.c:    for(i=0;i<par->pIntensity;i++)
grid_old.c:    for(i=par->pIntensity;i<par->ncell;i++){
grid_old.c:      (*gp)[i].t[0]=par->tcmb;
grid_old.c:      (*gp)[i].t[1]=par->tcmb;
grid_old.c:    par->dataFlags |= DS_mask_temperatures;
grid_old.c:  if(onlyBitsSet(par->dataFlags, DS_mask_3)) /* Only happens if (i) we read no file and have constructed this data within LIME, or (ii) we read a file at dataStageI==3. */
grid_old.c:  if(par->doMolCalcs){
grid_old.c:    if(!allBitsSet(par->dataFlags, DS_mask_abundance)){
grid_old.c:      dummyPointer = malloc(sizeof(*dummyPointer)*par->nSpecies);
grid_old.c:      if(par->useAbun){
grid_old.c:          for(si=0;si<par->nSpecies;si++)
grid_old.c:          for(si=0;si<par->nSpecies;si++){
grid_old.c:        for(i=0;i<par->pIntensity;i++){
grid_old.c:          for(si=0;si<par->nSpecies;si++)
grid_old.c:        for(i=par->pIntensity;i<par->ncell;i++){
grid_old.c:          for(si=0;si<par->nSpecies;si++)
grid_old.c:          for(si=0;si<par->nSpecies;si++)
grid_old.c:          for(si=0;si<par->nSpecies;si++){
grid_old.c:        for(i=0;i<par->pIntensity;i++){
grid_old.c:          for(si=0;si<par->nSpecies;si++)
grid_old.c:        for(i=par->pIntensity;i<par->ncell;i++){
grid_old.c:          for(si=0;si<par->nSpecies;si++)
grid_old.c:      par->dataFlags |= DS_mask_abundance;
grid_old.c:    if(!allBitsSet(par->dataFlags, DS_mask_turb_doppler)){
grid_old.c:      for(i=0;i<par->pIntensity;i++)
grid_old.c:      for(i=par->pIntensity;i<par->ncell;i++)
grid_old.c:      par->dataFlags |= DS_mask_turb_doppler;
grid_old.c:    if(!allBitsSet(par->dataFlags, DS_mask_velocity)){
grid_old.c:      for(i=0;i<par->pIntensity;i++)
grid_old.c:      par->dataFlags |= DS_mask_velocity;
grid_old.c:    if(!allBitsSet(par->dataFlags, DS_mask_ACOEFF)){
grid_old.c:      par->dataFlags |= DS_mask_ACOEFF;
grid_old.c:  } /* End if(par->doMolCalcs) */
grid_old.c:  if(!allBitsSet(par->dataFlags, DS_mask_magfield)){
grid_old.c:    if(par->polarization){
grid_old.c:      for(i=0;i<par->pIntensity;i++)
grid_old.c:      par->dataFlags |= DS_mask_magfield;
grid_old.c:      for(i=0;i<par->pIntensity;i++){
grid_old.c:    for(i=par->pIntensity;i<par->ncell;i++){
grid_old.c:  if(onlyBitsSet(par->dataFlags & DS_mask_all_but_mag, DS_mask_4)) /* Only happens if (i) we read no file and have constructed this data within LIME, or (ii) we read a file at dataStageI==4. */
lime.h:#define N_SMOOTH_ITERS          5                      /* number of smoothing iterations if using  par->samplingAlgorithm=0 */
main.c:  par->radius    = 0;
main.c:  par->minScale  = 0;
main.c:  par->pIntensity= 0;
main.c:  par->sinkPoints= 0;
main.c:  par->Qwater    = 0;
main.c:  par->rHelio    = 0; 
main.c:  par->dust  	    = NULL;
main.c:  par->outputfile   = NULL;
main.c:  par->binoutputfile= NULL;
main.c:  par->gridfile     = NULL;
main.c:  par->pregrid      = NULL;
main.c:  par->restart      = NULL;
main.c:  par->gridInFile   = NULL;
main.c:  par->collPartIds  = malloc(sizeof(int)*MAX_N_COLL_PART);
main.c:  for(i=0;i<MAX_N_COLL_PART;i++) par->collPartIds[i] = 0; /* Possible values start at 1. */
main.c:  par->nMolWeights  = malloc(sizeof(double)*MAX_N_COLL_PART);
main.c:  for(i=0;i<MAX_N_COLL_PART;i++) par->nMolWeights[i] = -1.0;
main.c:  par->dustWeights  = malloc(sizeof(double)*MAX_N_COLL_PART); /* This param no longer has any effect. */
main.c:  for(i=0;i<MAX_N_COLL_PART;i++) par->dustWeights[i] = -1.0;
main.c:  par->collPartMolWeights = malloc(sizeof(double)*MAX_N_COLL_PART);
main.c:  for(i=0;i<MAX_N_COLL_PART;i++) par->collPartMolWeights[i] = -1.0;
main.c:  par->gridDensMaxValues = malloc(sizeof(*(par->gridDensMaxValues))*MAX_N_HIGH);
main.c:  par->gridDensMaxLoc    = malloc(sizeof(*(par->gridDensMaxLoc))*MAX_N_HIGH);
main.c:    par->gridDensMaxValues[i] = -1.0; /* Impossible default value. */
main.c:    for(j=0;j<DIM;j++) par->gridDensMaxLoc[i][j] = 0.0;
main.c:  par->tcmb = LOCAL_CMB_TEMP;
main.c:  par->lte_only=0;
main.c:  par->init_lte=0;
main.c:  par->samplingAlgorithm=0;
main.c:  par->sampling=2; /* Now only accessed if par->samplingAlgorithm==0. */
main.c:  par->blend=0;
main.c:  par->antialias=1;
main.c:  par->polarization=0;
main.c:  par->nThreads = NTHREADS;
main.c:  par->nSolveIters=1;
main.c:  par->traceRayAlgorithm=0;
main.c:  par->resetRNG=0;
main.c:  par->doSolveRTE=0;
main.c:  par->colliScale = 1.0;
main.c:  par->girScale = 1.0;
main.c:  par->xne = 1.0;
main.c:  par->useEP = 0;
main.c:  par->fixRNG = 1;
main.c:  par->gridOutFiles = malloc(sizeof(char *)*NUM_GRID_STAGES);
main.c:    par->gridOutFiles[i] = NULL;
main.c:  par->moldatfile=malloc(sizeof(char *)*MAX_NSPECIES);
main.c:  par->girdatfile=malloc(sizeof(char *)*MAX_NSPECIES);
main.c:    par->moldatfile[id]=NULL;
main.c:    par->girdatfile[id]=NULL;
main.c:  par->collPartNames=malloc(sizeof(char *)*MAX_N_COLL_PART);
main.c:    par->collPartNames[i]=NULL;
main.c:  /* Second-pass reading of the user-set parameters (this time just to read the par->moldatfile and img stuff). */
messages.c:    printf("  Iteration %i / max %i: Starting\n", prog + 1, par->nSolveIters);
messages.c:    printf("  Iteration %i / max %i: DONE\n\n", prog+1, par->nSolveIters);
molinit.c:  for(i=0;i<par->nSpecies;i++){
molinit.c:    if((fp=fopen(par->moldatfile[i], "r"))==NULL) {
molinit.c:    checkFirstLineMolDat(fp, par->moldatfile[i]);
molinit.c:    /* Not all the collision partners listed in the moldata file may have associated density functions. Those which don't can play no role and should therefore be ignored. We will try not to store them in md, although due to the demands of backward-compatibility, this will sometimes not be possible, e.g. if the user has not set values for par->collPartIds and if at the same time there are fewer density functions than the total number of collision partners specified in the moldata files. To cover these cases we introduce a new struct cpData attribute: densityIndex, with default value -1 signalling that there is no density function for the associated CP.
molinit.c:      /* Look for this CP in par->collPartIds. Note that since we have already called collparts.checkUserDensWeights() by this stage, therefore either we have 1 par->collPartIds entry per density function return, or par->collPartIds==NULL.
molinit.c:      if(par->collPartIds!=NULL){
molinit.c:        for(j=0;j<par->numDensities;j++)
molinit.c:          if(collPartId==par->collPartIds[j]) cpWasFoundInUserList = 1;
molinit.c://**** Won't this go wrong when the user has supplied par->collPartNames but not par->collPartIds? See collparts.checkUserDensWeights().
molinit.c:      if(par->collPartIds==NULL || cpWasFoundInUserList){
molinit.c:        if(par->lte_only){
molinit.c:              md[i].part[k].down[j] *= par->colliScale; /* User scaling of collisional rates */
molinit.c:        } /* End if(par->lte_only) */
molinit.c:      } /* End if CP found in par->collPartIds. */
molinit.c:If we have reached this point, par->collPartIds (and par->nMolWeights) should have been malloc'd and filled with sensible values. Here we set up indices which allow us to associate a density function with each collision partner of each radiating molecule. This information is made use of in solver.c.
molinit.c:  for(i=0;i<par->nSpecies;i++){
molinit.c:      for(j=0;j<par->numDensities;j++){
molinit.c:        if(md[i].part[ipart].collPartId==par->collPartIds[j]){
molinit.c:  for(si=0;si<par->nSpecies;si++){
molinit.c:      if(par->tcmb>0.)
molinit.c:        md[si].cmb[iline] = planckfunc(md[si].freq[iline],par->tcmb);
molinit.c:  for(i=0;i<par->nSpecies;i++){
molinit.c:    if((fp=fopen(par->girdatfile[i], "r")) != NULL){
molinit.c:        md[i].gir[(ilev-1)*md[i].nlev+jlev-1] = pumpRate * par->girScale;
molinit.c:      snprintf(message, STR_LEN_0, "Girdat file %s cannot be opened.",par->girdatfile[i]);
molinit.c:  if(par->girdatfile!=NULL){
molinit.c:  if(!par->lte_only){
molinit.c:    for(i=0;i<par->nSpecies;i++){
molinit.c:          copyInparStr(par->collPartNames[md[i].part[j].densityIndex], &(md[i].part[j].name));
molinit.c:          collpartmesg3(par->numDensities, 0);//**************** was the 2nd arg used in lime-1.5??
molinit.c:          collpartmesg3(par->numDensities, 0);//**************** was the 2nd arg used in lime-1.5??
popsin.c:  if((fp=fopen(par->restart, "rb"))==NULL){
popsin.c:  par->numDensities = 1;
popsin.c:  checkFread(fread(&par->radius,   sizeof(double), 1, fp), 1, "par->radius");
popsin.c:  checkFread(fread(&par->ncell,    sizeof(int), 1, fp), 1, "par->ncell");
popsin.c:  if(par->ncell != (par->pIntensity + par->sinkPoints)){
popsin.c:    if(!silent) bail_out("Num grid points read from file != par->pIntensity + par->sinkPoints.");
popsin.c:  checkFread(fread(&par->nSpecies, sizeof(int), 1, fp), 1, "par->nSpecies");
popsin.c:  if( par->nSpecies < 0 || par->nSpecies > MAX_NSPECIES )
popsin.c:  *md=realloc(*md, sizeof(molData)*par->nSpecies);
popsin.c:  for(i=0;i<par->nSpecies;i++){
popsin.c:  mallocAndSetDefaultGrid(gp, (size_t)par->ncell, (size_t)par->nSpecies);
popsin.c:  for(i=0;i<par->ncell;i++){
popsin.c:    for(j=0;j<par->nSpecies;j++)
popsin.c:    for(j=0;j<par->nSpecies;j++){
popsin.c:2017-06-21 IMS: Note that we have a bit of an issue with knu and dust here. These values are stored in the par->restart file for the frequencies of all the spectral lines, but what we actually need in raytrace are the values of knu and dust appropriate to the nominal continuum frequency of the image, which will not always be the same as that of any of the spectral lines. Probably the best thing would be to write some sort of interpolation routine, read in the line-frequency knu and dust values (which we are presently discarding), then call the interpolation routine within raytrace() as an alternative to calcGridContDustOpacity(). If this was done, the necessity to supply a dust file to par->dust, as well as density and temperature functions as below, would be avoided. However this is a bit more hacking than I presently want to contemplate.
popsin.c:  delaunay(DIM, *gp, (unsigned long)par->ncell, 0, 1, &dc, &numCells);
popsin.c:  /* We just asked delaunay() to flag any grid points with IDs lower than par->pIntensity (which means their distances from model centre are less than the model radius) but which are nevertheless found to be sink points by virtue of the geometry of the mesh of Delaunay cells. Now we need to reshuffle the list of grid points, then reset par->pIntensity, such that all the non-sink points still have IDs lower than par->pIntensity.
popsin.c:  nExtraSinks = reorderGrid((unsigned long)par->ncell, *gp);
popsin.c:  par->pIntensity -= nExtraSinks;
popsin.c:  par->sinkPoints += nExtraSinks;
popsin.c:    par->dataFlags |= (1 << DS_bit_ACOEFF);
popsin.c:  par->dataFlags |= (1 << DS_bit_x);
popsin.c:  par->dataFlags |= (1 << DS_bit_neighbours);
popsin.c:  par->dataFlags |= (1 << DS_bit_velocity);
popsin.c:  par->dataFlags |= (1 << DS_bit_abundance);
popsin.c:  par->dataFlags |= (1 << DS_bit_turb_doppler);
popsin.c:/*  par->dataFlags |= (1 << DS_bit_magfield); commented out because we are not yet reading it in popsin (and may never do so) */
popsin.c:  par->dataFlags |= (1 << DS_bit_populations);
popsin.c:  for(i=0;i<par->ncell; i++)
popsin.c:    (*gp)[i].dens = malloc(sizeof(double)*par->numDensities);
popsin.c:  for(i=0;i<par->pIntensity;i++)
popsin.c:  for(i=par->pIntensity;i<par->ncell;i++){
popsin.c:    for(j=0;j<par->numDensities;j++)
popsin.c:  par->dataFlags |= DS_mask_density;
popsin.c:  for(i=0;i<par->pIntensity;i++)
popsin.c:  for(i=par->pIntensity;i<par->ncell;i++){
popsin.c:    (*gp)[i].t[0]=par->tcmb;
popsin.c:    (*gp)[i].t[1]=par->tcmb;
popsin.c:  par->dataFlags |= DS_mask_temperatures;
popsin.c:  par->useAbun = 0;
popsout.c:  if((fp=fopen(par->outputfile, "w"))==NULL){
popsout.c:  for(j=0;j<par->pIntensity;j++){
popsout.c:    for(l=0;l<par->numDensities;l++) dens+=gp[j].dens[l]*par->nMolWeights[l];
popsout.c:  dummyMol = malloc(sizeof(*dummyMol)*par->nSpecies);
popsout.c:  dummy2 = malloc(sizeof(*dummy2)*par->nSpecies);
popsout.c:  for(j=0;j<par->nSpecies;j++){
popsout.c:  if((fp=fopen(par->binoutputfile, "wb"))==NULL){
popsout.c:  checkFwrite(fwrite(&par->radius,   sizeof(double), 1, fp), 1, "radius");
popsout.c:  checkFwrite(fwrite(&par->ncell,    sizeof(int),    1, fp), 1, "ncell");
popsout.c:  checkFwrite(fwrite(&par->nSpecies, sizeof(int),    1, fp), 1, "nSpecies");
popsout.c:  for(i=0;i<par->nSpecies;i++){
popsout.c:  for(i=0;i<par->ncell;i++){
popsout.c:    for(j=0;j<par->nSpecies;j++)
popsout.c:    for(j=0;j<par->nSpecies;j++){
popsout.c:  for(j=0;j<par->nSpecies;j++){
predefgrid.c:  par->numDensities = 1;
predefgrid.c:  for(i=0;i<par->ncell; i++)
predefgrid.c:    gp[i].dens = malloc(sizeof(double)*par->numDensities);
predefgrid.c:  if((fp=fopen(par->pregrid,"r"))==NULL) {
predefgrid.c:  for(i=0;i<par->pIntensity;i++){
predefgrid.c:    if( nRead != 9 || gp[i].id < 0 || gp[i].id > par->pIntensity)
predefgrid.c:    if(!silent) progressbar((double) i/((double)par->pIntensity-1), 4);	
predefgrid.c:  for(i=par->pIntensity;i<par->ncell;i++){
predefgrid.c:      scale=par->radius*sqrt(1/(x*x+y*y+z*z));
predefgrid.c:      gp[i].t[0]=par->tcmb;
predefgrid.c:      gp[i].t[1]=par->tcmb;
predefgrid.c:  delaunay(DIM, gp, (unsigned long)par->ncell, 0, 1, &dc, &numCells);
predefgrid.c:  /* We just asked delaunay() to flag any grid points with IDs lower than par->pIntensity (which means their distances from model centre are less than the model radius) but which are nevertheless found to be sink points by virtue of the geometry of the mesh of Delaunay cells. Now we need to reshuffle the list of grid points, then reset par->pIntensity, such that all the non-sink points still have IDs lower than par->pIntensity.
predefgrid.c:  nExtraSinks = reorderGrid((unsigned long)par->ncell, gp);
predefgrid.c:  par->pIntensity -= nExtraSinks;
predefgrid.c:  par->sinkPoints += nExtraSinks;
predefgrid.c:  par->dataFlags |= (1 << DS_bit_x);
predefgrid.c:  par->dataFlags |= (1 << DS_bit_neighbours);
predefgrid.c:  par->dataFlags |= (1 << DS_bit_velocity);
predefgrid.c:  par->dataFlags |= (1 << DS_bit_density);
predefgrid.c:  par->dataFlags |= (1 << DS_bit_abundance);
predefgrid.c:  par->dataFlags |= (1 << DS_bit_turb_doppler);
predefgrid.c:  par->dataFlags |= (1 << DS_bit_temperatures);
predefgrid.c:  par->dataFlags |= (1 << DS_bit_magfield);
predefgrid.c:  if(par->gridfile) write_VTK_unstructured_Points(par, gp);
py_main.c:  free(par->collPartIds);
py_main.c:  free(par->nMolWeights);
py_main.c:  free(par->dustWeights);
py_main.c:  free(par->collPartMolWeights);
py_main.c:  free(par->gridDensMaxValues);
py_main.c:  free(par->gridDensMaxLoc);
py_main.c:  free(par->outputfile);
py_main.c:  free(par->binoutputfile);
py_main.c:  free(par->gridfile);
py_main.c:  free(par->pregrid);
py_main.c:  free(par->restart);
py_main.c:  free(par->dust);
py_main.c:  free(par->gridInFile);
py_main.c:  if(par->moldatfile!= NULL){
py_main.c:      free(par->moldatfile[i]);
py_main.c:    free(par->moldatfile);
py_main.c:  if(par->girdatfile!= NULL){
py_main.c:      free(par->girdatfile[i]);
py_main.c:    free(par->girdatfile);
py_main.c:  if(par->gridOutFiles!= NULL){
py_main.c:      free(par->gridOutFiles[i]);
py_main.c:    free(par->gridOutFiles);
py_main.c:  if(par->collPartNames!= NULL){
py_main.c:      free(par->collPartNames[i]);
py_main.c:    free(par->collPartNames);
py_utils.c:  inpar->collPartIds  = malloc(sizeof(int)*MAX_N_COLL_PART);
py_utils.c:  if(inpar->collPartIds==NULL) RETURN_NO_MEM(1)
py_utils.c:  for(i=0;i<MAX_N_COLL_PART;i++) inpar->collPartIds[i] = 0; /* Possible values start at 1. */
py_utils.c:  inpar->nMolWeights  = malloc(sizeof(double)*MAX_N_COLL_PART);
py_utils.c:  if(inpar->nMolWeights==NULL) RETURN_NO_MEM(2)
py_utils.c:  for(i=0;i<MAX_N_COLL_PART;i++) inpar->nMolWeights[i] = -1.0;
py_utils.c:  inpar->dustWeights  = malloc(sizeof(double)*MAX_N_COLL_PART); /* This param no longer has any effect. */
py_utils.c:  if(inpar->dustWeights==NULL) RETURN_NO_MEM(3)
py_utils.c:  for(i=0;i<MAX_N_COLL_PART;i++) inpar->dustWeights[i] = -1.0;
py_utils.c:  inpar->collPartMolWeights = malloc(sizeof(double)*MAX_N_COLL_PART);
py_utils.c:  if(inpar->collPartMolWeights==NULL) RETURN_NO_MEM(4)
py_utils.c:  for(i=0;i<MAX_N_COLL_PART;i++) inpar->collPartMolWeights[i] = -1.0;
py_utils.c:  inpar->gridDensMaxValues = malloc(sizeof(*(inpar->gridDensMaxValues))*MAX_N_HIGH);
py_utils.c:  if(inpar->gridDensMaxValues==NULL) RETURN_NO_MEM(5)
py_utils.c:  inpar->gridDensMaxLoc    = malloc(sizeof(*(inpar->gridDensMaxLoc))*MAX_N_HIGH);
py_utils.c:  if(inpar->gridDensMaxLoc==NULL) RETURN_NO_MEM(6)
py_utils.c:    inpar->gridDensMaxValues[i] = -1.0; /* Impossible default value. */
py_utils.c:    for(j=0;j<DIM;j++) inpar->gridDensMaxLoc[i][j] = 0.0;
py_utils.c:  inpar->outputfile    = malloc(sizeof(char)*(PY_STR_LEN_0+1));
py_utils.c:  if(inpar->outputfile   ==NULL) RETURN_NO_MEM(7)
py_utils.c:  inpar->outputfile[0]    = '\0';
py_utils.c:  inpar->binoutputfile = malloc(sizeof(char)*(PY_STR_LEN_0+1));
py_utils.c:  if(inpar->binoutputfile==NULL) RETURN_NO_MEM(8)
py_utils.c:  inpar->binoutputfile[0] = '\0';
py_utils.c:  inpar->gridfile      = malloc(sizeof(char)*(PY_STR_LEN_0+1));
py_utils.c:  if(inpar->gridfile     ==NULL) RETURN_NO_MEM(9)
py_utils.c:  inpar->gridfile[0]      = '\0';
py_utils.c:  inpar->pregrid       = malloc(sizeof(char)*(PY_STR_LEN_0+1));
py_utils.c:  if(inpar->pregrid      ==NULL) RETURN_NO_MEM(10)
py_utils.c:  inpar->pregrid[0]       = '\0';
py_utils.c:  inpar->restart       = malloc(sizeof(char)*(PY_STR_LEN_0+1));
py_utils.c:  if(inpar->restart      ==NULL) RETURN_NO_MEM(11)
py_utils.c:  inpar->restart[0]       = '\0';
py_utils.c:  inpar->dust          = malloc(sizeof(char)*(PY_STR_LEN_0+1));
py_utils.c:  if(inpar->dust         ==NULL) RETURN_NO_MEM(12)
py_utils.c:  inpar->dust[0]          = '\0';
py_utils.c:  inpar->gridInFile    = malloc(sizeof(char)*(PY_STR_LEN_0+1));
py_utils.c:  if(inpar->gridInFile   ==NULL) RETURN_NO_MEM(13)
py_utils.c:  inpar->gridInFile[0]    = '\0';
py_utils.c:  inpar->moldatfile = malloc(sizeof(char *)*MAX_NSPECIES);
py_utils.c:  if(inpar->moldatfile==NULL) RETURN_NO_MEM(14)
py_utils.c:  inpar->girdatfile = malloc(sizeof(char *)*MAX_NSPECIES);
py_utils.c:  if(inpar->girdatfile==NULL) RETURN_NO_MEM(15)
py_utils.c:    inpar->moldatfile[i] = malloc(sizeof(char)*(PY_STR_LEN_0+1));
py_utils.c:    if(inpar->moldatfile[i]==NULL) RETURN_NO_MEM(16)
py_utils.c:    inpar->moldatfile[i][0] = '\0';
py_utils.c:    inpar->girdatfile[i] = malloc(sizeof(char)*(PY_STR_LEN_0+1));
py_utils.c:    if(inpar->girdatfile[i]==NULL) RETURN_NO_MEM(17)
py_utils.c:    inpar->girdatfile[i][0] = '\0';
py_utils.c:  inpar->gridOutFiles = malloc(sizeof(char *)*NUM_GRID_STAGES);
py_utils.c:  if(inpar->gridOutFiles==NULL) RETURN_NO_MEM(18)
py_utils.c:    inpar->gridOutFiles[i] = malloc(sizeof(char)*(PY_STR_LEN_0+1));
py_utils.c:    if(inpar->gridOutFiles[i]==NULL) RETURN_NO_MEM(19)
py_utils.c:    inpar->gridOutFiles[i][0] = '\0';
py_utils.c:  inpar->collPartNames = malloc(sizeof(char *)*MAX_N_COLL_PART);
py_utils.c:  if(inpar->collPartNames==NULL) RETURN_NO_MEM(20)
py_utils.c:    inpar->collPartNames[i] = malloc(sizeof(char)*(PY_STR_LEN_0+1));
py_utils.c:    if(inpar->collPartNames[i]==NULL) RETURN_NO_MEM(21)
py_utils.c:    inpar->collPartNames[i][0] = '\0';
py_utils.c:  inpar->radius            = tempValue.doubleValue;
py_utils.c:  inpar->minScale          = tempValue.doubleValue;
py_utils.c:  inpar->pIntensity        = tempValue.intValue;
py_utils.c:  inpar->sinkPoints        = tempValue.intValue;
py_utils.c:    free(inpar->dust);
py_utils.c:    inpar->dust = NULL;
py_utils.c:    strcpy(inpar->dust,          tempValue.strValue);
py_utils.c:    free(inpar->outputfile);
py_utils.c:    inpar->outputfile = NULL;
py_utils.c:    strcpy(inpar->outputfile,    tempValue.strValue);
py_utils.c:    free(inpar->binoutputfile);
py_utils.c:    inpar->binoutputfile = NULL;
py_utils.c:    strcpy(inpar->binoutputfile, tempValue.strValue);
py_utils.c:    free(inpar->gridfile);
py_utils.c:    inpar->gridfile = NULL;
py_utils.c:    strcpy(inpar->gridfile,      tempValue.strValue);
py_utils.c:    free(inpar->pregrid);
py_utils.c:    inpar->pregrid = NULL;
py_utils.c:    strcpy(inpar->pregrid,       tempValue.strValue);
py_utils.c:    free(inpar->restart);
py_utils.c:    inpar->restart = NULL;
py_utils.c:    strcpy(inpar->restart,       tempValue.strValue);
py_utils.c:    free(inpar->gridInFile);
py_utils.c:    inpar->gridInFile = NULL;
py_utils.c:    strcpy(inpar->gridInFile,    tempValue.strValue);
py_utils.c:      inpar->collPartIds[j] = tempValues[j].intValue;
py_utils.c:      inpar->nMolWeights[j] = tempValues[j].doubleValue;
py_utils.c:      inpar->dustWeights[j] = tempValues[j].doubleValue;
py_utils.c:      inpar->collPartMolWeights[j] = tempValues[j].doubleValue;
py_utils.c:      inpar->gridDensMaxValues[j] = tempValues[j].doubleValue;
py_utils.c:        inpar->gridDensMaxLoc[j][k] = tempValues2[j][k].doubleValue;
py_utils.c:  inpar->tcmb              = tempValue.doubleValue;
py_utils.c:  inpar->lte_only          = tempValue.boolValue;
py_utils.c:  inpar->init_lte          = tempValue.boolValue;
py_utils.c:  inpar->samplingAlgorithm = tempValue.intValue;
py_utils.c:  inpar->sampling          = tempValue.intValue;
py_utils.c:  inpar->blend             = tempValue.boolValue;
py_utils.c:  inpar->antialias         = tempValue.intValue;
py_utils.c:  inpar->polarization      = tempValue.boolValue;
py_utils.c:  inpar->nThreads          = tempValue.intValue;
py_utils.c:  inpar->nSolveIters       = tempValue.intValue;
py_utils.c:  inpar->traceRayAlgorithm = tempValue.intValue;
py_utils.c:  inpar->resetRNG          = tempValue.boolValue;
py_utils.c:  inpar->doSolveRTE        = tempValue.boolValue;
py_utils.c:      strcpy(inpar->gridOutFiles[j], tempValues[j].strValue);
py_utils.c:      strcpy(inpar->moldatfile[j], tempValues[j].strValue);
py_utils.c:      strcpy(inpar->girdatfile[j], tempValues[j].strValue);
py_utils.c:      strcpy(inpar->collPartNames[j], tempValues[j].strValue);
raytrace.c:  if(par->dust == NULL)
raytrace.c:  for(id=0;id<par->ncell;id++){
raytrace.c:  if(par->dust != NULL){
raytrace.c:    if (r < rayData.radius[par->pIntensity - 1] && r > par->minScale){
raytrace.c:       for (i = 1; i < par->pIntensity; i++){
raytrace.c:          for(molI=0;molI<par->nSpecies;molI++){
raytrace.c:    if(ro>=rho_grid[par->pIntensity-1]){
raytrace.c:    for(i=0;i<par->pIntensity;i++) //TODO: use a more efficient searching algorithm, such as binary search (since its already sorted)
raytrace.c:      else if(index==par->pIntensity){
raytrace.c:        index = par->pIntensity-1;
raytrace.c:This function constructs an image cube by following sets of rays (at least 1 per image pixel) through the model, solving the radiative transfer equations as appropriate for each ray. The ray locations within each pixel are chosen randomly within the pixel, but the number of rays per pixel is set equal to the number of projected model grid points falling within that pixel, down to a minimum equal to par->alias.
raytrace.c:    double pixelSize, imgCentrePixels,minfreq,absDeltaFreq,xs[2],rho_grid[par->pIntensity],radiusarr[par->pIntensity], sorted_radius[par->pIntensity], ro;
raytrace.c:      for(molI=0;molI<par->nSpecies;molI++){
raytrace.c:  for (id = 0;id < par->pIntensity;id++) {
raytrace.c:  qsort(sorted_radius, par->pIntensity, sizeof(double), compare);
raytrace.c:  rayData.id = malloc(sizeof(int) * par->pIntensity);
raytrace.c:  rayData.flux = malloc(sizeof(*rayData.flux) * par->pIntensity);
raytrace.c:  rayData.fluxc = malloc(sizeof(*rayData.fluxc) * par->pIntensity);
raytrace.c:  for (i = 0; i < par->pIntensity; i++) {
raytrace.c:  for (i = 0; i < par->pIntensity; i++) {
raytrace.c:    for (j = 0; j < par->pIntensity; j++) //TODO: More efficient algorithm than sequential search could be implemented
raytrace.c:  for(i = 0; i < par->pIntensity; i++){
raytrace.c:  rayData.mols = malloc(sizeof(*rayData.mols) * par->nSpecies);
raytrace.c:  for(molI=0;molI<par->nSpecies;molI++){
raytrace.c:  for(molI=0;molI<par->nSpecies;molI++){
raytrace.c:  logdz=log10(par->radius)/dz_grid_size;
raytrace.c:  zp_grid[dz_grid_size]=par->radius;
raytrace.c:  omp_set_num_threads(par->nThreads);
raytrace.c:  for(i = 0; i < par->pIntensity; i++){
raytrace.c:          if(ro>=par->radius){
raytrace.c:          for(k=0;k<par->pIntensity;k++)
raytrace.c:  for(i = 0; i < par->pIntensity; i++){
raytrace.c:  for(molI=0;molI<par->nSpecies;molI++){
run.c:    x = par->minScale;
run.c:    y = par->minScale;
run.c:    z = par->minScale;
run.c:  par->radius            = inpars.radius;
run.c:  par->minScale          = inpars.minScale;
run.c:  par->pIntensity        = inpars.pIntensity;
run.c:  par->sinkPoints        = inpars.sinkPoints;
run.c:  par->samplingAlgorithm = inpars.samplingAlgorithm;
run.c:  par->sampling          = inpars.sampling;
run.c:  par->tcmb              = inpars.tcmb;
run.c:  par->lte_only          = inpars.lte_only;
run.c:  par->init_lte          = inpars.init_lte;
run.c:  par->blend             = inpars.blend;
run.c:  par->antialias         = inpars.antialias;
run.c:  par->polarization      = inpars.polarization;
run.c:  par->nThreads          = inpars.nThreads;
run.c:  par->nSolveIters       = inpars.nSolveIters;
run.c:  par->traceRayAlgorithm = inpars.traceRayAlgorithm;
run.c:  par->resetRNG          = inpars.resetRNG;
run.c:  par->doSolveRTE        = inpars.doSolveRTE;
run.c:  par->Qwater            = inpars.Qwater;
run.c:  par->rHelio            = inpars.rHelio;
run.c:  par->xne               = inpars.xne;
run.c:  par->colliScale        = inpars.colliScale;
run.c:  par->girScale          = inpars.girScale;
run.c:  par->useEP             = inpars.useEP;
run.c:  par->fixRNG            = inpars.fixRNG;
run.c:  copyInparStr(inpars.dust,          &(par->dust));
run.c:  copyInparStr(inpars.outputfile,    &(par->outputfile));
run.c:  copyInparStr(inpars.binoutputfile, &(par->binoutputfile));
run.c:  copyInparStr(inpars.restart,       &(par->restart));
run.c:  copyInparStr(inpars.gridfile,      &(par->gridfile));
run.c:  copyInparStr(inpars.pregrid,       &(par->pregrid));
run.c:  copyInparStr(inpars.gridInFile,    &(par->gridInFile));
run.c:  if(par->fixRNG){
run.c:  par->gridOutFiles = malloc(sizeof(char *)*NUM_GRID_STAGES);
run.c:    copyInparStr(inpars.gridOutFiles[i], &(par->gridOutFiles[i]));
run.c:    par->writeGridAtStage[i] = 0;
run.c:  if(par->pregrid==NULL && par->restart){
run.c:    par->nSpecies=0; /* This will get set during popsin(). */
run.c:    par->girdatfile = NULL;
run.c:    /* If the user has provided a list of moldatfile names, the corresponding elements of par->moldatfile will be non-NULL. Thus we can deduce the number of files (species) from the number of non-NULL elements.
run.c:    par->nSpecies=0;
run.c:    while(par->nSpecies<MAX_NSPECIES && !charPtrIsNullOrEmpty(inpars.moldatfile[par->nSpecies]))
run.c:    par->nSpecies++;
run.c:      par->girdatfile = NULL;
run.c:    else if(numGirDatFiles!=par->nSpecies){
run.c:      par->girdatfile=malloc(sizeof(char *)*par->nSpecies);
run.c:      for(id=0;id<par->nSpecies;id++){
run.c:        copyInparStr(inpars.girdatfile[id], &(par->girdatfile[id]));
run.c:  if(par->nSpecies <= 0){
run.c:    par->moldatfile = NULL; /* This will be tested for all line images, so we can never get par->nLineImages>0 if no moldata files have been supplied. */
run.c:    par->moldatfile=malloc(sizeof(char *)*par->nSpecies);
run.c:    for(id=0;id<par->nSpecies;id++){
run.c:      copyInparStr(inpars.moldatfile[id], &(par->moldatfile[id]));
run.c:    for(id=0;id<par->nSpecies;id++){
run.c:      if((fp=fopen(par->moldatfile[id], "r"))==NULL){
run.c:          snprintf(message, STR_LEN_1, "Moldat file %s not found locally - fetching it from LAMDA", par->moldatfile[id]);
run.c:        openSocket(par->moldatfile[id]);
run.c:        checkFirstLineMolDat(fp, par->moldatfile[id]);
run.c:  par->collPartIds  = malloc(sizeof(int   )*MAX_N_COLL_PART);
run.c:  for(i=0;i<MAX_N_COLL_PART;i++) par->collPartIds[i] = inpars.collPartIds[i];
run.c:  par->nMolWeights  = malloc(sizeof(double)*MAX_N_COLL_PART);
run.c:  for(i=0;i<MAX_N_COLL_PART;i++) par->nMolWeights[i] = inpars.nMolWeights[i];
run.c:  par->collPartNames = malloc(sizeof(char*)*MAX_N_COLL_PART);
run.c:  for(i=0;i<MAX_N_COLL_PART;i++) copyInparStr(inpars.collPartNames[i], &(par->collPartNames[i]));
run.c:  par->collPartMolWeights = malloc(sizeof(double)*MAX_N_COLL_PART);
run.c:  for(i=0;i<MAX_N_COLL_PART;i++) par->collPartMolWeights[i] = inpars.collPartMolWeights[i];
run.c:  par->gridDensMaxValues = malloc(sizeof(*(par->gridDensMaxValues))*MAX_N_HIGH);
run.c:  par->gridDensMaxLoc    = malloc(sizeof(*(par->gridDensMaxLoc))*MAX_N_HIGH);
run.c:    par->gridDensMaxValues[i] = inpars.gridDensMaxValues[i];
run.c:    for(j=0;j<DIM;j++) par->gridDensMaxLoc[i][j] = inpars.gridDensMaxLoc[i][j];
run.c:  while(i<MAX_N_HIGH && par->gridDensMaxValues[i]>=0) i++;
run.c:  par->numGridDensMaxima = i;
run.c:  par->ncell = par->pIntensity + par->sinkPoints;
run.c:  par->radiusSqu = par->radius*par->radius;
run.c:  par->minScaleSqu=par->minScale*par->minScale;
run.c:  par->doPregrid = (par->pregrid==NULL)?0:1;
run.c:  par->nSolveItersDone = 0; /* This can be set to some non-zero value if the user reads in a grid file at dataStageI==5. */
run.c:  par->useAbun = 1; /* Can be unset within readOrBuildGrid(). */
run.c:  par->dataFlags = 0;
run.c:  if(par->gridInFile==NULL){
run.c:    if (par->radius<=0){
run.c:    if (par->minScale<=0){
run.c:    if (par->pIntensity<=0){
run.c:    if (par->Qwater<=0){
run.c:    if (par->rHelio<=0){
run.c:  par->gridDensGlobalMax = 1.0; /* Dummy value, needed in case the default gridDensity() is called. */
run.c:  par->numDensities = 0; /* Ditto. */
run.c:  /* Calculate par->numDensities.
run.c:  if(!(par->doPregrid || par->restart)){ /* These switches cause par->numDensities to be set in routines they call. */
run.c:    par->numDensities = 0; /* default. */
run.c:    if(par->gridInFile!=NULL){
run.c:      status = countDensityCols(par->gridInFile, &(par->numDensities));
run.c:    if(par->numDensities<=0){
run.c:      par->numDensities = numFuncDensities;
run.c:      if(par->numDensities<=0){
run.c:  if(!(par->doPregrid || par->restart || par->gridInFile!=NULL)){
run.c:    /* In this case we will need to calculate grid point locations, thus we will need to call the function gridDensity(). The default one is ok, but this (i) needs the user to supply a density function, and (ii) requires par->gridDensGlobalMax etc to be calculated.
run.c:      par->gridDensGlobalMax = 1.0; /* We need some sort of >0 value for par->gridDensGlobalMax before we call the default gridDensity(). */
run.c:      }else if (tempPointDensity>par->gridDensGlobalMax)
run.c:        par->gridDensGlobalMax = tempPointDensity;
run.c:        for(i=0;i<DIM;i++) r[i] = par->minScale;
run.c:          par->gridDensGlobalMax = tempPointDensity;
run.c:            for(i=0;i<DIM;i++) r[i] = par->radius*(2.0*gsl_rng_uniform(randGen) - 1.0);
run.c:            if (tempPointDensity>par->gridDensGlobalMax)
run.c:              par->gridDensGlobalMax = tempPointDensity;
run.c:          }else if(par->numGridDensMaxima>0){
run.c:            par->gridDensGlobalMax = par->gridDensMaxValues[0];
run.c:            for(i=1;i<par->numGridDensMaxima;i++)
run.c:              if(par->gridDensMaxValues[i]>par->gridDensGlobalMax) par->gridDensGlobalMax = par->gridDensMaxValues[i];
run.c:            par->gridDensGlobalMax = 1.0;
run.c:    if(par->gridOutFiles[i] != NULL)
run.c:      par->writeGridAtStage[i] = 1;
run.c:  par->taylorCutoff = pow(24.*DBL_EPSILON, 0.25);
run.c:  par->nImages = nImages;
run.c:  par->numDims = DIM;
run.c:      (*img)[i].doInterpolateVels = inimg[i].doInterpolateVels; // This is only accessed if par->traceRayAlgorithm==1.
run.c:      if(par->polarization){
run.c:          if(!silent && par->nSpecies>1){
run.c:  par->nLineImages = 0;
run.c:  par->nContImages = 0;
run.c:  par->doInterpolateVels = 0;
run.c:      if(par->traceRayAlgorithm==1 && !(*img)[i].doInterpolateVels\
run.c:      && par->nThreads>1){
run.c:      if(par->traceRayAlgorithm==1 && !(*img)[i].doInterpolateVels\
run.c:        if(!silent) bail_out("par->traceRayAlgorithm==1 && !img[i].doInterpolateVels requires you to supply a velocity function.");
run.c:      par->nLineImages++;
run.c:      par->nContImages++;
run.c:      par->doInterpolateVels = 1;
run.c:  if(par->nContImages>0){
run.c:    if(par->dust==NULL){
run.c:      if((fp=fopen(par->dust, "r"))==NULL){
run.c:          snprintf(message, STR_LEN_1, "Couldn't open dust opacity data file %s", par->dust);
run.c:  if(par->nLineImages>0 && par->traceRayAlgorithm==0 && !par->doPregrid){
run.c:      par->useVelFuncInRaytrace = FALSE;
run.c:      par->useVelFuncInRaytrace = TRUE;
run.c:    par->useVelFuncInRaytrace = FALSE;
run.c:  if(par->nThreads>1 && par->useVelFuncInRaytrace){
run.c:    par->useVelFuncInRaytrace = FALSE;
run.c:  par->edgeVelsAvailable=0; /* default value, this is set within getEdgeVelocities(). */
run.c:    if(par->lte_only){
run.c:    }else if(par->nSolveIters<=par->nSolveItersDone && !allBitsSet(par->dataFlags, DS_mask_populations)){
run.c:      warning("No supplied pops values, and par->nSolveIters <= par->nSolveItersDone.");
run.c:  if(par->nSpecies>0){
run.c:    mallocAndSetDefaultMolData(par->nSpecies, md);
run.c:  if(par->samplingAlgorithm==0)
run.c:  for(i=0;i<par->nSpecies;i++){
run.c:    for(id=0;id<par->ncell; id++){
run.c:    if(par.nSolveIters>par.nSolveItersDone || par.lte_only) /* To save the user having to set par->doSolveRTE as well as par->nSolveIters>0 or par->lte_only. */
run.c:      if(!silent) bail_out("You must point par->moldatfile to a data file.");
smooth.c:    delaunay(DIM, gp, (unsigned long)par->ncell, 0, 0, &dc, &numCells);
smooth.c:    for(i=0;i<par->pIntensity;i++){
smooth.c:      if(par->radius-sqrt(gp[i].x[0]*gp[i].x[0] + gp[i].x[1]*gp[i].x[1] + gp[i].x[2]*gp[i].x[2])<mindist) cn=-1;
smooth.c:        if((move[0]*move[0]+move[1]*move[1]+move[2]*move[2])<par->radiusSqu &&
smooth.c:           (move[0]*move[0]+move[1]*move[1]+move[2]*move[2])>par->minScaleSqu){
smooth.c:    for(i=par->pIntensity;i<par->ncell;i++){
smooth.c:      dist=par->radius/sqrt(gp[i].x[0]*gp[i].x[0] + gp[i].x[1]*gp[i].x[1] + gp[i].x[2]*gp[i].x[2]);
solver.c:  (*blends).mols = malloc(sizeof(struct molWithBlends)*par->nSpecies);
solver.c:  for(molI=0;molI<par->nSpecies;molI++){
solver.c:      for(molJ=0;molJ<par->nSpecies;molJ++){
solver.c:    if(!par->blend)
solver.c:    if(par->blend)
solver.c:  for(i=0;i<par->nSpecies;i++){
solver.c:    for(id=0;id<par->ncell;id++){
solver.c:      for(id=0;id<par->ncell;id++){
solver.c:  for(id=0;id<par->ncell;id++){
solver.c:    for(si=0;si<par->nSpecies;si++){
solver.c:  for(id=0;id<par->ncell;id++){
solver.c:    for(si=0;si<par->nSpecies;si++){
solver.c:  if(par->dust != NULL){
solver.c:  for(si=0;si<par->nSpecies;si++){
solver.c:    if(par->dust == NULL){
solver.c:    for(id=0;id<par->ncell;id++){
solver.c:  if(par->dust != NULL){
solver.c:  double deltav[par->nSpecies],vfac_in[par->nSpecies],vfac_out[par->nSpecies],vfac_inprev[par->nSpecies];
solver.c:    for(molI=0;molI<par->nSpecies;molI++){
solver.c:    for (molI=0;molI<par->nSpecies;molI++){
solver.c:      if(numLinks>par->ncell){
solver.c:        for(molI=0;molI<par->nSpecies;molI++){
solver.c:          if(par->edgeVelsAvailable) {
solver.c:      for(molI=0;molI<par->nSpecies;molI++){
solver.c:        if(par->edgeVelsAvailable)
solver.c:      for(molI=0;molI<par->nSpecies;molI++){
solver.c:          if(par->blend && blends.mols!=NULL && molI==blends.mols[nextMolWithBlend].molI\
solver.c:              if(par->edgeVelsAvailable)
solver.c:        if(par->blend && blends.mols!=NULL && molI==blends.mols[nextMolWithBlend].molI)
solver.c:    for(molI=0;molI<par->nSpecies;molI++){
solver.c:        if(par->blend && blends.mols!=NULL && molI==blends.mols[nextMolWithBlend].molI\
solver.c:  double jbar[par->pIntensity],molDens[par->nSpecies], tau, beta;
solver.c:  rnuc = par->minScale;
solver.c:  else if(time>time_struct.time[par->pIntensity-1])
solver.c:    time = time_struct.time[par->pIntensity-1];
solver.c:   Te = Telec(radius,par->Qwater,gp[id].t[0]);
solver.c:   ne = nelec(radius,par->Qwater,vexp,Te,par->rHelio,par->xne);
solver.c:   if(par->girdatfile!=NULL){
solver.c:   if(par->useEP){ 
solver.c:  for(id=0;id<par->pIntensity;id++){
solver.c:    for(ispec=0;ispec<par->nSpecies;ispec++){
solver.c:  if(par->outputfile) popsout(par,gp,md);
solver.c:  rnuc = par->minScale;
solver.c:  double timearr[par->pIntensity], sorted_timearr[par->pIntensity]; //times through which the solver will iterate (each one corresponds to a specific gridpoint)
solver.c:  for(id=0;id<par->pIntensity;id++){
solver.c:  qsort(sorted_timearr, par->pIntensity, sizeof(double), compare);
solver.c:  time_struct.id = malloc(sizeof(int)*par->pIntensity);
solver.c:  for(i=0;i<par->pIntensity;i++){
solver.c:    for(j=0;j<par->pIntensity;j++) //TODO: More efficient algorithm than sequential search could be implemented
solver.c:  double (*jbar_grid)[md[ispec].nline] = malloc(sizeof(double[par->pIntensity][md[ispec].nline]));
solver.c:  for (i = 1; i < par->pIntensity; i++){
solver.c:  int RNG_seeds[par->nThreads];
solver.c:  int nextMolWithBlend[par->pIntensity],nMaserWarnings[par->pIntensity];
solver.c:  for(id=0;id<par->pIntensity;id++){
solver.c:  for(ispec=0;ispec<par->nSpecies;ispec++)
solver.c:  if(par->lte_only){
solver.c:    if(par->outputfile) popsout(par,gp,md);
solver.c:    threadRans = malloc(sizeof(gsl_rng *)*par->pIntensity);
solver.c:    for (i=0;i<par->pIntensity;i++){
solver.c:      if (par->resetRNG==1) RNG_seeds[i] = (int)(gsl_rng_uniform(ran)*1e6);
solver.c:   if(par->outputfile) popsout(par,gp,md);
solver.c:  gridPointData *mp[par->pIntensity];
solver.c:  double *halfFirstDs[par->pIntensity];
solver.c:  for(id=0;id<par->pIntensity;id++){
solver.c:    mp[id]=malloc(sizeof(gridPointData)*par->nSpecies);
solver.c:    for (ispec=0;ispec<par->nSpecies;ispec++){
solver.c:  for(ispec=0;ispec<par->nSpecies;ispec++){
solver.c:    for(i=0;i<par->pIntensity;i++)
solver.c:      if(par->blend && blends.mols!=NULL && ispec==blends.mols[nextMolWithBlend[i]].molI)
solver.c:  for(id=0;id<par->pIntensity;id++){
solver.c:  for (i=0;i<par->pIntensity;i++){
solver.c:    freeGridPointData(par->nSpecies, mp[i]);
solver.c:  if(par->outputfile != NULL) popsout(par,gp,md);
solver.c:  for (i=0;i<par->pIntensity;i++)
solver.c:  par->dataFlags |= (1 << DS_bit_populations);
solver.c:  if(par->binoutputfile != NULL) binpopsout(par,gp,md);
writefits.c:  if(!img[im].doline && par->polarization)
writefits.c:    if(par->polarization){ /* ichan should have run from 0 to 2 in this case. Stokes I, Q and U but no V. Load zeros into the last pol channel: */
