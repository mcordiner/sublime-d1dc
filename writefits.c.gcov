        -:    0:Source:src/writefits.c
        -:    0:Graph:src/writefits.gcno
        -:    0:Data:src/writefits.gcda
        -:    0:Runs:1
        -:    1:/*
        -:    2: *  writefits.c
        -:    3: *  This file is part of LIME, the versatile line modeling engine
        -:    4: *
        -:    5: *  Copyright (C) 2006-2014 Christian Brinch
        -:    6: *  Copyright (C) 2015-2017 The LIME development team
        -:    7: *
        -:    8: */
        -:    9:
        -:   10:#include "lime.h"
        -:   11:
        -:   12:void
function writeWCS called 4 returned 100% blocks executed 100%
        4:   13:writeWCS(fitsfile *fptr, const int i, int axesOrder[4], float cdelt[4], double crpix[4], double crval[4], char ctype[4][9], char cunit[4][9]){
        -:   14:  char myStr[9];
        4:   15:  int status = 0;
        -:   16:
        4:   17:  sprintf(myStr, "CTYPE%d  ", i+1);
        4:   18:  fits_write_key(fptr, TSTRING, myStr, &ctype[axesOrder[i]], "", &status);
call    0 returned 100%
        4:   19:  sprintf(myStr, "CDELT%d  ", i+1);
        4:   20:  fits_write_key(fptr, TFLOAT, myStr, &cdelt[axesOrder[i]], "", &status);
call    0 returned 100%
        4:   21:  sprintf(myStr, "CRPIX%d  ", i+1);
        4:   22:  fits_write_key(fptr, TDOUBLE, myStr, &crpix[axesOrder[i]], "", &status);
call    0 returned 100%
        4:   23:  sprintf(myStr, "CRVAL%d  ", i+1);
        4:   24:  fits_write_key(fptr, TDOUBLE, myStr, &crval[axesOrder[i]], "", &status);
call    0 returned 100%
        4:   25:  sprintf(myStr, "CUNIT%d  ", i+1);
        4:   26:  fits_write_key(fptr, TSTRING, myStr, &cunit[axesOrder[i]], "", &status);	
call    0 returned 100%
        4:   27:}
        -:   28:
        -:   29:void 
function write4Dfits called 1 returned 100% blocks executed 48%
        1:   30:write4Dfits(int im, int unit_index, configInfo *par, imageInfo *img){
        -:   31:  /*
        -:   32:Users have complained that downstream packages (produced by lazy coders >:8) will not deal with FITS cubes having less that 4 axes. Thus all LIME output images are now sent to the present function.
        -:   33:  */
        -:   34:  const int numAxes=4;
        -:   35:  double bscale,bzero,epoch,lonpole,equinox,restfreq;
        1:   36:  int axesOrder[] = {0,1,2,3};
        1:   37:  char ctype[numAxes][9],cunit[numAxes][9];
        1:   38:  double crpix[numAxes],crval[numAxes];
        -:   39:  float cdelt[numAxes];
        -:   40:  double ru3,scale=1.0;
        -:   41:  int velref,unitI,i;
        -:   42:  float *row;
        -:   43:  int px,py,ichan;
        -:   44:  fitsfile *fptr;
        1:   45:  int status = 0;
        -:   46:  int naxis=numAxes, bitpix=-32;
        1:   47:  long naxes[numAxes];
        1:   48:  long int fpixels[numAxes],lpixels[numAxes];
        1:   49:  char negfile[100]="! ",message[STR_LEN_0];
        -:   50:  unsigned long ppi;
        -:   51:
        1:   52:  unitI = img[im].imgunits[unit_index];
        1:   53:  row = malloc(sizeof(*row)*img[im].pxls);
        -:   54:
        1:   55:  naxes[axesOrder[0]] = img[im].pxls;
        1:   56:  naxes[axesOrder[1]] = img[im].pxls;
        -:   57:
        1:   58:  if(img[im].doline)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        1:   59:    naxes[axesOrder[2]] = img[im].nchan;
        -:   60:  else
    #####:   61:    naxes[axesOrder[2]] = 1; /* In this case nchan can =3, the number of active Stokes parameters, if the dust is polarized. */
        -:   62:
       1*:   63:  if(!img[im].doline && par->polarization)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
branch  2 never executed
branch  3 never executed
    #####:   64:    naxes[axesOrder[3]]=4;
        -:   65:  else
        1:   66:    naxes[axesOrder[3]]=1;
        -:   67:
        1:   68:  fits_create_file(&fptr, img[im].filename, &status);
call    0 returned 100%
        -:   69:
        1:   70:  if(status!=0){
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        1:   71:    if(!silent) warning("Overwriting existing fits file                   ");
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
        1:   72:    status=0;
        1:   73:    strcat(negfile,img[im].filename);
        1:   74:    fits_create_file(&fptr, negfile, &status);
call    0 returned 100%
        -:   75:  }
        -:   76:
        -:   77:  /* Write FITS header */ 
        1:   78:  fits_create_img(fptr, bitpix, naxis, naxes, &status);
call    0 returned 100%
        1:   79:  epoch   =2.0e3;
        1:   80:  lonpole =1.8e2;
        1:   81:  equinox =2.0e3;
        1:   82:  restfreq=img[im].freq;
        1:   83:  velref  =257;
        -:   84:
        1:   85:  sprintf(ctype[axesOrder[0]], "RA---SIN");
        1:   86:  cdelt[axesOrder[0]] = -1.8e2*(float)(img[im].imgres/M_PI);
        1:   87:  crpix[axesOrder[0]] = ((double)img[im].pxls)/2.0 + 0.5;
        1:   88:  crval[axesOrder[0]] = 0.0e0;
        1:   89:  sprintf(cunit[axesOrder[0]], "DEG    ");
        -:   90:
        1:   91:  sprintf(ctype[axesOrder[1]], "DEC--SIN");
        1:   92:  cdelt[axesOrder[1]] = 1.8e2*(float)(img[im].imgres/M_PI);
        1:   93:  crpix[axesOrder[1]] = ((double)img[im].pxls)/2.0 + 0.5;
        1:   94:  crval[axesOrder[1]] = 0.0e0;
        1:   95:  sprintf(cunit[axesOrder[1]], "DEG    ");
        -:   96:
        1:   97:  sprintf(ctype[axesOrder[2]], "VELO-LSR");
        1:   98:  if(img[im].doline)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        1:   99:    cdelt[axesOrder[2]] = (float)img[im].velres;
        -:  100:  else
    #####:  101:    cdelt[axesOrder[2]] = 1.0;
        1:  102:  crpix[axesOrder[2]] = (double) (naxes[axesOrder[2]]-1)/2.+1;
        1:  103:  crval[axesOrder[2]] = 0.0e0;
        1:  104:  sprintf(cunit[axesOrder[2]], "m/s    ");
        -:  105:
        1:  106:  sprintf(ctype[axesOrder[3]], "STOKES  ");
        1:  107:  cdelt[axesOrder[3]] = 1.0;
        1:  108:  crpix[axesOrder[3]] = (double) (naxes[axesOrder[3]]-1)/2.+1;
        1:  109:  crval[axesOrder[3]] = 1.0e0;
        1:  110:  sprintf(cunit[axesOrder[3]], "       ");
        -:  111:
        1:  112:  bscale  =1.0e0;
        1:  113:  bzero   =0.0e0;
        -:  114:
        1:  115:  fits_write_key(fptr, TSTRING, "OBJECT  ", &"LIMEMDL ",    "", &status);
call    0 returned 100%
        1:  116:  fits_write_key(fptr, TDOUBLE, "EPOCH   ", &epoch,         "", &status);
call    0 returned 100%
        1:  117:  fits_write_key(fptr, TDOUBLE, "LONPOLE ", &lonpole,       "", &status);
call    0 returned 100%
        1:  118:  fits_write_key(fptr, TDOUBLE, "EQUINOX ", &equinox,       "", &status);
call    0 returned 100%
        1:  119:  fits_write_key(fptr, TSTRING, "SPECSYS ", &"LSRK    ",    "", &status);
call    0 returned 100%
        1:  120:  fits_write_key(fptr, TDOUBLE, "RESTFRQ", &restfreq,      "", &status);
call    0 returned 100%
        1:  121:  fits_write_key(fptr, TINT,    "VELREF  ", &velref,        "", &status);
call    0 returned 100%
        -:  122:
        5:  123:  for(i=0;i<numAxes;i++)
branch  0 taken 80%
branch  1 taken 20% (fallthrough)
        4:  124:    writeWCS(fptr, i, axesOrder, cdelt, crpix, crval, ctype, cunit);
call    0 returned 100%
        -:  125:
        1:  126:  fits_write_key(fptr, TDOUBLE, "BSCALE  ", &bscale,        "", &status);
call    0 returned 100%
        1:  127:  fits_write_key(fptr, TDOUBLE, "BZERO   ", &bzero,         "", &status);
call    0 returned 100%
        -:  128:
        1:  129:  if(unitI==0) fits_write_key(fptr, TSTRING, "BUNIT", &"K       ", "", &status);
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
       1*:  130:  if(unitI==1) fits_write_key(fptr, TSTRING, "BUNIT", &"Jy/pix", "", &status);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
       1*:  131:  if(unitI==2) fits_write_key(fptr, TSTRING, "BUNIT", &"WM2HZSR ", "", &status);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
       1*:  132:  if(unitI==3) fits_write_key(fptr, TSTRING, "BUNIT", &"Lsun/PX ", "", &status);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
       1*:  133:  if(unitI==4) fits_write_key(fptr, TSTRING, "BUNIT", &"        ", "", &status);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
        -:  134:
        1:  135:  if(     unitI==0)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        1:  136:    scale=0.5*(CLIGHT/img[im].freq)*(CLIGHT/img[im].freq)/KBOLTZ;
    #####:  137:  else if(unitI==1)
branch  0 never executed
branch  1 never executed
    #####:  138:    scale=1e26*img[im].imgres*img[im].imgres;
    #####:  139:  else if(unitI==2)
branch  0 never executed
branch  1 never executed
        -:  140:    scale=1.0;
    #####:  141:  else if(unitI==3) {
branch  0 never executed
branch  1 never executed
    #####:  142:    ru3 = img[im].distance/1.975e13;
    #####:  143:    scale=4.*M_PI*ru3*ru3*img[im].freq*img[im].imgres*img[im].imgres;
        -:  144:  }
    #####:  145:  else if(unitI==4) {
branch  0 never executed
branch  1 never executed
    #####:  146:    if (img[im].rebinSpec == 1) {
branch  0 never executed
branch  1 never executed
    #####:  147:      if(!silent) bail_out("No rebinned tau image is available (needs to be coded)");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  148:    exit(0);
call    0 never executed
        -:  149:    }
        -:  150:  }
        -:  151:  else{
    #####:  152:    if(!silent) bail_out("Image unit number invalid");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  153:    exit(0);
call    0 never executed
        -:  154:  }
        -:  155:
        -:  156:  /* Write FITS data */
        1:  157:  if(img[im].doline){
branch  0 taken 100%
branch  1 taken 0%
       51:  158:    for(ichan=0;ichan<img[im].nchan;ichan++){
branch  0 taken 98%
branch  1 taken 2%
    12850:  159:      for(py=0;py<img[im].pxls;py++){
branch  0 taken 100%
branch  1 taken 1% (fallthrough)
  3289600:  160:        for(px=0;px<img[im].pxls;px++){
branch  0 taken 100%
branch  1 taken 1% (fallthrough)
  3276800:  161:          ppi = py*img[im].pxls + px;
        -:  162:
  3276800:  163:          if(unitI>-1 && unitI<4)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
  3276800:  164:            row[px]=(float) img[im].pixel[ppi].intense[ichan]*scale;
    #####:  165:          else if(unitI==4)
branch  0 never executed
branch  1 never executed
    #####:  166:            row[px]=(float) img[im].pixel[ppi].tau[ichan];
        -:  167:          else {
    #####:  168:            if(!silent) bail_out("Image unit number invalid");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  169:            exit(0);
call    0 never executed
        -:  170:          }
  3276800:  171:          if (fabs(row[px])<IMG_MIN_ALLOWED) row[px]=IMG_MIN_ALLOWED;
branch  0 taken 28% (fallthrough)
branch  1 taken 72%
        -:  172:        }
    12800:  173:        fpixels[axesOrder[0]] = 1;
    12800:  174:        fpixels[axesOrder[1]] = py+1;
    12800:  175:        fpixels[axesOrder[2]] = ichan+1;
    12800:  176:        fpixels[axesOrder[3]] = 1;
    12800:  177:        lpixels[axesOrder[0]] = img[im].pxls;
    12800:  178:        lpixels[axesOrder[1]] = py+1;
    12800:  179:        lpixels[axesOrder[2]] = ichan+1;
    12800:  180:        lpixels[axesOrder[3]] = 1;
    12800:  181:        fits_write_subset(fptr, TFLOAT, fpixels, lpixels, row, &status);
call    0 returned 100%
        -:  182:      }
        -:  183:    }
        -:  184:  }else{
    #####:  185:    for(ichan=0;ichan<img[im].nchan;ichan++){
branch  0 never executed
branch  1 never executed
    #####:  186:      for(py=0;py<img[im].pxls;py++){
branch  0 never executed
branch  1 never executed
    #####:  187:        for(px=0;px<img[im].pxls;px++){
branch  0 never executed
branch  1 never executed
    #####:  188:          ppi = py*img[im].pxls + px;
        -:  189:
    #####:  190:          if(unitI>-1 && unitI<4)
branch  0 never executed
branch  1 never executed
    #####:  191:            row[px]=(float) img[im].pixel[ppi].intense[ichan]*scale;
    #####:  192:          else if(unitI==4)
branch  0 never executed
branch  1 never executed
    #####:  193:            row[px]=(float) img[im].pixel[ppi].tau[ichan];
        -:  194:          else {
    #####:  195:            if(!silent) bail_out("Image unit number invalid");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  196:            exit(0);
call    0 never executed
        -:  197:          }
    #####:  198:          if (fabs(row[px])<IMG_MIN_ALLOWED) row[px]=IMG_MIN_ALLOWED;
branch  0 never executed
branch  1 never executed
        -:  199:        }
    #####:  200:        fpixels[axesOrder[0]] = 1;
    #####:  201:        fpixels[axesOrder[1]] = py+1;
    #####:  202:        fpixels[axesOrder[3]] = ichan+1;
    #####:  203:        fpixels[axesOrder[2]] = 1;
    #####:  204:        lpixels[axesOrder[0]] = img[im].pxls;
    #####:  205:        lpixels[axesOrder[1]] = py+1;
    #####:  206:        lpixels[axesOrder[3]] = ichan+1;
    #####:  207:        lpixels[axesOrder[2]] = 1;
    #####:  208:        fits_write_subset(fptr, TFLOAT, fpixels, lpixels, row, &status);
call    0 never executed
        -:  209:      }
        -:  210:    }
        -:  211:
    #####:  212:    if(par->polarization){ /* ichan should have run from 0 to 2 in this case. Stokes I, Q and U but no V. Load zeros into the last pol channel: */
branch  0 never executed
branch  1 never executed
    #####:  213:      if(img[im].nchan!=3){
branch  0 never executed
branch  1 never executed
    #####:  214:        if(!silent){
branch  0 never executed
branch  1 never executed
    #####:  215:          sprintf(message, "%d pol channels found but %d expected.", img[im].nchan, 3);
    #####:  216:          bail_out(message);
call    0 never executed
        -:  217:        }
    #####:  218:exit(1);
call    0 never executed
        -:  219:      }
        -:  220:      ichan = 3;
    #####:  221:      for(px=0;px<img[im].pxls;px++)
branch  0 never executed
branch  1 never executed
    #####:  222:        row[px] = IMG_MIN_ALLOWED;
    #####:  223:      for(py=0;py<img[im].pxls;py++){
branch  0 never executed
branch  1 never executed
    #####:  224:        fpixels[axesOrder[0]] = 1;
    #####:  225:        fpixels[axesOrder[1]] = py+1;
    #####:  226:        fpixels[axesOrder[3]] = ichan+1;
    #####:  227:        fpixels[axesOrder[2]] = 1;
    #####:  228:        lpixels[axesOrder[0]] = img[im].pxls;
    #####:  229:        lpixels[axesOrder[1]] = py+1;
    #####:  230:        lpixels[axesOrder[3]] = ichan+1;
    #####:  231:        lpixels[axesOrder[2]] = 1;
    #####:  232:        fits_write_subset(fptr, TFLOAT, fpixels, lpixels, row, &status);
call    0 never executed
        -:  233:      }
        -:  234:    }
        -:  235:  }
        -:  236:
        1:  237:  fits_close_file(fptr, &status);
call    0 returned 100%
        -:  238:
        1:  239:  free(row);
        1:  240:}
        -:  241:
function writeFits called 1 returned 100% blocks executed 50%
        1:  242:void writeFits(const int i, const int unit_index, configInfo *par, imageInfo *img){
        1:  243:  int unitI = img[i].imgunits[unit_index];
        -:  244:
        1:  245:  if(unitI>5){
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  246:    if(!silent) bail_out("Image unit number invalid");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  247:exit(1);
call    0 never executed
        -:  248:  }
        1:  249:  write4Dfits(i, unit_index, par, img);
call    0 returned 100%
        1:  250:}
        -:  251:
function removeFilenameExtension called 0 returned 0% blocks executed 0%
    #####:  252:char *removeFilenameExtension(char* inStr, char extensionChar, char pathSeparator) {
        -:  253:    char *outStr, *lastDotInFilename, *lastPathSeparatorInFilename;
        -:  254:
    #####:  255:    if (inStr == NULL)
branch  0 never executed
branch  1 never executed
        -:  256:        return NULL;
        -:  257:
    #####:  258:    outStr = malloc(strlen(inStr) + 1);
    #####:  259:    if(!outStr){
branch  0 never executed
branch  1 never executed
    #####:  260:        if(!silent) bail_out("Error allocating memory for filename extension removal");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  261:        exit(0);
call    0 never executed
        -:  262:    }
    #####:  263:    strcpy(outStr, inStr);
        -:  264:    /* Find last occurrences of extension character and path separator character */
    #####:  265:    lastDotInFilename = strrchr(outStr, extensionChar);
    #####:  266:    lastPathSeparatorInFilename = (pathSeparator == 0) ? NULL : strrchr(outStr, pathSeparator);
branch  0 never executed
branch  1 never executed
        -:  267:
        -:  268:    /* Truncate filename at occurrence of last extension character assuming it comes after the last path separator character */
    #####:  269:    if (lastDotInFilename != NULL) {
branch  0 never executed
branch  1 never executed
    #####:  270:        if (lastPathSeparatorInFilename != NULL) {
branch  0 never executed
branch  1 never executed
    #####:  271:            if (lastPathSeparatorInFilename < lastDotInFilename) {
branch  0 never executed
branch  1 never executed
    #####:  272:                *lastDotInFilename = '\0';
        -:  273:            }
        -:  274:        } else {
    #####:  275:            *lastDotInFilename = '\0';
        -:  276:        }
        -:  277:    }
        -:  278:    return outStr;
        -:  279:}
        -:  280:
function insertUnitStrInFilename called 0 returned 0% blocks executed 0%
    #####:  281:void insertUnitStrInFilename(char *img_filename_root, configInfo *par, imageInfo *img, const int im, const int unit_index){
        -:  282:  char *temp_filename, *temp_extensionless_filename, message[STR_LEN_0];
        -:  283:  static char* unit_names[] = {"Kelvin", "Jansky-per-px", "SI", "LSun-per-px", "Tau", "#Rays"};
        -:  284:  char *ext;
        -:  285:
        -:  286:  /* Check if unit index falls outside range of possible unit names */
    #####:  287:  if(unit_index < 0 || unit_index > sizeof(unit_names)/sizeof(*unit_names) - 1){
branch  0 never executed
branch  1 never executed
    #####:  288:    sprintf(message, "Image unit index '%d' does not have a corresponding unit name", unit_index);
    #####:  289:    if(!silent) bail_out(message);
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  290:    exit(0);
call    0 never executed
        -:  291:  }
        -:  292:
    #####:  293:  copyInparStr(img_filename_root, &(temp_filename));
call    0 never executed
        -:  294:  /* Extract filename extension */
    #####:  295:  ext = strrchr(img_filename_root, '.');
    #####:  296:  if (!ext) {
branch  0 never executed
branch  1 never executed
        -:  297:    /* Set to blank string if no filename extension was extracted */
        -:  298:    ext = "";
        -:  299:  } else {
        -:  300:    /* Remove extension from temporary filename */
    #####:  301:      temp_extensionless_filename = removeFilenameExtension(temp_filename, '.', '/');
call    0 never executed
    #####:  302:      strcpy(temp_filename, temp_extensionless_filename);
    #####:  303:      free(temp_extensionless_filename);
        -:  304:  }
        -:  305:  /* Append unit name to temporary filename */
    #####:  306:  strcat(temp_filename, "_");
    #####:  307:  strcat(temp_filename, unit_names[img[im].imgunits[unit_index]]);
    #####:  308:  strcat(temp_filename, ext);
        -:  309:
        -:  310:  /* Update image filename from temporary filename */
    #####:  311:  copyInparStr(temp_filename, &(img[im].filename));
call    0 never executed
    #####:  312:  free(temp_filename);
    #####:  313:}
        -:  314:
function writeFitsAllUnits called 1 returned 100% blocks executed 33%
        1:  315:void writeFitsAllUnits(const int i, configInfo *par, imageInfo *img){
        -:  316:  int j;
        -:  317:  char *img_filename_root;
        -:  318:
        1:  319:  if(img[i].numunits == 1){
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        1:  320:    writeFits(i,0,par,img);
call    0 returned 100%
        -:  321:  }else{
    #####:  322:    copyInparStr(img[i].filename, &(img_filename_root));
call    0 never executed
    #####:  323:    for(j=0;j<img[i].numunits;j++) {
branch  0 never executed
branch  1 never executed
    #####:  324:      insertUnitStrInFilename(img_filename_root, par, img, i, j);
call    0 never executed
    #####:  325:      writeFits(i,j,par,img);
call    0 never executed
        -:  326:    }
        -:  327:  }
        1:  328:}
        -:  329:
