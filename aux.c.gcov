        -:    0:Source:src/aux.c
        -:    0:Graph:src/aux.gcno
        -:    0:Data:src/aux.gcda
        -:    0:Runs:1
        -:    1:/*
        -:    2: *  aux.c
        -:    3: *  This file is part of LIME, the versatile line modeling engine
        -:    4: *
        -:    5: *  Copyright (C) 2006-2014 Christian Brinch
        -:    6: *  Copyright (C) 2015-2017 The LIME development team
        -:    7: *
        -:    8:TODO:
        -:    9: */
        -:   10:
        -:   11:#include "lime.h"
        -:   12:
        -:   13:/*....................................................................*/
function sigintHandler called 0 returned 0% blocks executed 0%
    #####:   14:void sigintHandler(int sigI){
        -:   15:#ifdef IS_PYTHON
        -:   16:  Py_Finalize();
        -:   17:#endif
        -:   18:
        -:   19://*** write output file?
        -:   20:
    #####:   21:exit(1);
        -:   22:}
        -:   23:
        -:   24:/*....................................................................*/
function compare called 4559 returned 100% blocks executed 100%
     4559:   25:int compare(const void *a,const void *b) {
        -:   26:double *x = (double *) a;
        -:   27:double *y = (double *) b;
     4559:   28:if (*x < *y) return -1;
branch  0 taken 52% (fallthrough)
branch  1 taken 48%
     2349:   29:else if (*x > *y) return 1; return 0;
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:   30:}
        -:   31:
        -:   32:/*....................................................................*/
function linear_interp called 12068300 returned 100% blocks executed 100%
 12068300:   33:double linear_interp(double x0, double x1, double y0, double y1, double value){
 12068300:   34:  return((y0*(x1-value) + y1*(value-x0))/(x1-x0));
        -:   35:}
        -:   36:
        -:   37:/*....................................................................*/
function checkFgets called 43 returned 100% blocks executed 40%
       43:   38:void checkFgets(char *fgetsResult, char *message){
        -:   39:  const size_t buflen=80;
       43:   40:  char string[buflen];
        -:   41:
       43:   42:  if(fgetsResult==NULL){
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:   43:    if(!silent){
branch  0 never executed
branch  1 never executed
    #####:   44:      snprintf(string, buflen, "fgets() failed to read %s", message);
    #####:   45:      bail_out(string);
call    0 never executed
        -:   46:    }
    #####:   47:exit(1);
call    0 never executed
        -:   48:  }
       43:   49:}
        -:   50:
        -:   51:/*....................................................................*/
function checkFscanf called 9305 returned 100% blocks executed 40%
     9305:   52:void checkFscanf(const int fscanfResult, const int expectedNum, char *message){
        -:   53:  const size_t buflen=80;
     9305:   54:  char string[buflen];
        -:   55:
     9305:   56:  if(fscanfResult!=expectedNum){
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:   57:    if(!silent){
branch  0 never executed
branch  1 never executed
    #####:   58:      snprintf(string, buflen, "fscanf() failed to read %s - read %d bytes when %d expected.", message, fscanfResult, expectedNum);
    #####:   59:      bail_out(string);
call    0 never executed
        -:   60:    }
    #####:   61:exit(1);
call    0 never executed
        -:   62:  }
     9305:   63:}
        -:   64:
        -:   65:/*....................................................................*/
function checkFread called 0 returned 0% blocks executed 0%
    #####:   66:void checkFread(const size_t freadResult, const size_t expectedNum, char *message){
        -:   67:  const size_t buflen=80;
    #####:   68:  char string[buflen];
        -:   69:
    #####:   70:  if(freadResult!=expectedNum){
branch  0 never executed
branch  1 never executed
    #####:   71:    if(!silent){
branch  0 never executed
branch  1 never executed
    #####:   72:      snprintf(string, buflen, "fread() failed to read %s. Expected %d got %d", message, (int)expectedNum, (int)freadResult);
    #####:   73:      bail_out(string);
call    0 never executed
        -:   74:    }
    #####:   75:exit(1);
call    0 never executed
        -:   76:  }
    #####:   77:}
        -:   78:
        -:   79:/*....................................................................*/
function checkFwrite called 0 returned 0% blocks executed 0%
    #####:   80:void checkFwrite(const size_t fwriteResult, const size_t expectedNum, char *message){
        -:   81:  const size_t buflen=80;
    #####:   82:  char string[buflen];
        -:   83:
    #####:   84:  if(fwriteResult!=expectedNum){
branch  0 never executed
branch  1 never executed
    #####:   85:    if(!silent){
branch  0 never executed
branch  1 never executed
    #####:   86:      snprintf(string, buflen, "fwrite() failed to write %s. Expected %d got %d", message, (int)expectedNum, (int)fwriteResult);
    #####:   87:      bail_out(string);
call    0 never executed
        -:   88:    }
    #####:   89:exit(1);
call    0 never executed
        -:   90:  }
    #####:   91:}
        -:   92:
        -:   93:/*....................................................................*/
function mallocAndSetDefaultMolData called 1 returned 100% blocks executed 100%
        1:   94:void mallocAndSetDefaultMolData(const int nSpecies, molData **md){
        -:   95:  int i;
        -:   96:
        1:   97:  (*md)=malloc(sizeof(molData)*nSpecies);
        2:   98:  for(i=0;i<nSpecies;i++){
branch  0 taken 50%
branch  1 taken 50% (fallthrough)
        1:   99:    (*md)[i].nlev  = -1;
        1:  100:    (*md)[i].nline = -1;
        1:  101:    (*md)[i].npart = -1;
        1:  102:    (*md)[i].amass = -1.0;
        1:  103:    (*md)[i].part    = NULL;
        1:  104:    (*md)[i].lal     = NULL;
        1:  105:    (*md)[i].lau     = NULL;
        1:  106:    (*md)[i].aeinst  = NULL;
        1:  107:    (*md)[i].gir     = NULL;
        1:  108:    (*md)[i].freq    = NULL;
        1:  109:    (*md)[i].beinstu = NULL;
        1:  110:    (*md)[i].beinstl = NULL;
        1:  111:    (*md)[i].eterm   = NULL;
        1:  112:    (*md)[i].gstat   = NULL;
        1:  113:    (*md)[i].cmb     = NULL;
        -:  114:  }
        1:  115:}
        -:  116:
        -:  117:/*....................................................................*/
function calcSourceFn called 2469900 returned 100% blocks executed 100%
  2469900:  118:void calcSourceFn(double dTau, const configInfo *par, double *remnantSnu, double *expDTau){
        -:  119:  /*
        -:  120:  The source function S is defined as j_nu/alpha, which is clearly not
        -:  121:  defined for alpha==0. However S is used in the algorithm only in the
        -:  122:  term (1-exp[-alpha*ds])*S, which is defined for all values of alpha.
        -:  123:  The present function calculates this term and returns it in the
        -:  124:  argument remnantSnu. For values of abs(alpha*ds) less than a pre-
        -:  125:  calculated cutoff supplied in configInfo, a Taylor approximation is
        -:  126:  used.
        -:  127:
        -:  128:  Note that the same cutoff condition holds for replacement of
        -:  129:  exp(-dTau) by its Taylor expansion to 3rd order.
        -:  130:
        -:  131:  Note that this is called from within the multi-threaded block.
        -:  132:  */
        -:  133:
        -:  134:#ifdef FASTEXP
  2469900:  135:  *expDTau = FastExp(dTau);
call    0 returned 100%
  2469900:  136:  if (fabs(dTau)<par->taylorCutoff){
branch  0 taken 96% (fallthrough)
branch  1 taken 4%
  2359257:  137:    *remnantSnu = 1. - dTau*(1. - dTau*(1./3.))*(1./2.);
        -:  138:  } else {
   110643:  139:    *remnantSnu = (1.-(*expDTau))/dTau;
        -:  140:  }
        -:  141:#else
        -:  142:  if (fabs(dTau)<par->taylorCutoff){
        -:  143:    *remnantSnu = 1. - dTau*(1. - dTau*(1./3.))*(1./2.);
        -:  144:    *expDTau = 1. - dTau*(*remnantSnu);
        -:  145:  } else {
        -:  146:    *expDTau = exp(-dTau);
        -:  147:    *remnantSnu = (1.-(*expDTau))/dTau;
        -:  148:  }
        -:  149:#endif
  2469900:  150:}
        -:  151:
        -:  152:/*....................................................................*/
function planckfunc called 1177 returned 100% blocks executed 80%
     1177:  153:double planckfunc(const double freq, const double tKelvin){
        -:  154:  double bb=10.,wn;
     1177:  155:  if(tKelvin<EPS) bb = 0.0;
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  156:  else {
     1177:  157:    wn=freq/CLIGHT;
     1177:  158:    if (HPLANCK*freq>100.*KBOLTZ*tKelvin) 
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  159:      bb=2.*HPLANCK*wn*wn*freq*exp(-HPLANCK*freq/KBOLTZ/tKelvin);
        -:  160:    else 
     1177:  161:      bb=2.*HPLANCK*wn*wn*freq/(exp(HPLANCK*freq/KBOLTZ/tKelvin)-1);
        -:  162:  }
     1177:  163:  return bb;
        -:  164:}
        -:  165:
        -:  166:/*....................................................................*/
        -:  167:double
function gaussline called 4874700 returned 100% blocks executed 100%
  4874700:  168:gaussline(const double v, const double oneOnSigma){
        -:  169:  double val;
  4874700:  170:  val = v*v*oneOnSigma*oneOnSigma;
        -:  171:#ifdef FASTEXP
  4874700:  172:  return FastExp(val);
call    0 returned 100%
        -:  173:#else
        -:  174:  return exp(-val);
        -:  175:#endif
        -:  176:}
        -:  177:
        -:  178:/*....................................................................*/
        -:  179:double
function dotProduct3D called 4874700 returned 100% blocks executed 100%
  4874700:  180:dotProduct3D(const double *vA, const double *vB){
  4874700:  181:  return vA[0]*vB[0] + vA[1]*vB[1] + vA[2]*vB[2];
        -:  182:}
        -:  183:
        -:  184:/*....................................................................*/
        -:  185:void
function copyInparStr called 39 returned 100% blocks executed 100%
       39:  186:copyInparStr(const char *inStr, char **outStr){
       39:  187:  if(inStr==NULL || strlen(inStr)<=0 || strlen(inStr)>STR_LEN_0){
branch  0 taken 21% (fallthrough)
branch  1 taken 79%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
branch  4 taken 0% (fallthrough)
branch  5 taken 100%
       31:  188:    *outStr = NULL;
        -:  189:  }else{
        8:  190:    *outStr = malloc(sizeof(**outStr)*(STR_LEN_0+1));
        8:  191:    strcpy(*outStr, inStr);
        -:  192:  }
       39:  193:}
        -:  194:
        -:  195:/*....................................................................*/
        -:  196:_Bool
function charPtrIsNullOrEmpty called 4 returned 100% blocks executed 100%
        4:  197:charPtrIsNullOrEmpty(const char *inStr){
        4:  198:  if(inStr==NULL || strlen(inStr)<=0)
branch  0 taken 50% (fallthrough)
branch  1 taken 50%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
        -:  199:    return TRUE;
        -:  200:  else
        2:  201:    return FALSE;
        -:  202:}
        -:  203:
        -:  204:/*....................................................................*/
function readDustFile called 0 returned 0% blocks executed 0%
    #####:  205:void readDustFile(char *dustFileName, double **lamtab, double **kaptab\
        -:  206:  , int *nEntries){
        -:  207:
        -:  208:  /* NOTE! The calling routine must free lamtab and kaptab after use.
        -:  209:  */
        -:  210:  FILE *fp;
        -:  211:  int i=0,k;
        -:  212:  char string[80];
        -:  213:
        -:  214:  /* Open the file and count the values it contains.
        -:  215:  */
    #####:  216:  if((fp=fopen(dustFileName, "r"))==NULL){
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  217:    if(!silent) bail_out("Error opening dust opacity data file!");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  218:    exit(1);
call    0 never executed
        -:  219:  }
        -:  220:
        -:  221:
    #####:  222:  while(fgets(string,80,fp) != NULL){
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  223:    i++;
        -:  224:  }
        -:  225:
    #####:  226:  rewind(fp);
call    0 never executed
        -:  227:
        -:  228:  /* Now read the values.
        -:  229:  */
    #####:  230:  if(i>0){
branch  0 never executed
branch  1 never executed
    #####:  231:    *lamtab=malloc(sizeof(**lamtab)*i);
    #####:  232:    *kaptab=malloc(sizeof(**kaptab)*i);
        -:  233:  } else {
    #####:  234:    if(!silent) bail_out("No opacities read");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  235:    exit(1);
call    0 never executed
        -:  236:  }
    #####:  237:  for(k=0;k<i;k++){
branch  0 never executed
branch  1 never executed
    #####:  238:    checkFscanf(fscanf(fp,"%lf %lf\n", &(*lamtab)[k], &(*kaptab)[k]), 2, "dust opacities.");
call    0 never executed
call    1 never executed
    #####:  239:    (*lamtab)[k]=log10((*lamtab)[k]/1e6);
    #####:  240:    (*kaptab)[k]=log10((*kaptab)[k]);
        -:  241:  }
    #####:  242:  fclose(fp);
call    0 never executed
        -:  243:
    #####:  244:  *nEntries = i;
    #####:  245:}
        -:  246:
        -:  247:/*....................................................................*/
function interpolateKappa called 0 returned 0% blocks executed 0%
    #####:  248:double interpolateKappa(const double freq, double *lamtab, double *kaptab\
        -:  249:  , const int nEntries, gsl_spline *spline, gsl_interp_accel *acc){
        -:  250:  /* Note that the multiplications by 0.1 below are to convert cm^2/g to m^2/kg. */
        -:  251:
        -:  252:  double loglam, kappa;
        -:  253:
    #####:  254:  loglam=log10(CLIGHT/freq);
    #####:  255:  if(loglam < lamtab[0])
branch  0 never executed
branch  1 never executed
    #####:  256:    kappa = 0.1*pow(10.,kaptab[0] + (loglam-lamtab[0])\
    #####:  257:          *(kaptab[1]-kaptab[0])/(lamtab[1]-lamtab[0]));
    #####:  258:  else if(loglam > lamtab[nEntries-1])
branch  0 never executed
branch  1 never executed
    #####:  259:    kappa = 0.1*pow(10.,kaptab[nEntries-2] + (loglam-lamtab[nEntries-2])\
    #####:  260:          *(kaptab[nEntries-1]-kaptab[nEntries-2])\
    #####:  261:          /(lamtab[nEntries-1]-lamtab[nEntries-2]));
        -:  262:  else
    #####:  263:    kappa = 0.1*pow(10.,gsl_spline_eval(spline,loglam,acc));
call    0 never executed
        -:  264:
    #####:  265:  return kappa;
        -:  266:}
        -:  267:
        -:  268:/*....................................................................*/
function calcDustData called 500 returned 100% blocks executed 92%
      500:  269:void calcDustData(configInfo *par, double *dens, double *freqs\
        -:  270:  , const double gtd, double *kappatab, const int numLines, const double tsKelvin[]\
        -:  271:  , double *knus, double *dusts){
        -:  272:
        -:  273:  double tKelvin,gasMassDensityAMUs,dustToGas;
        -:  274:  int di,iline;
        -:  275:
        -:  276:  /* Check if input model supplies a dust temperature. Otherwise use the kinetic temperature. */
      500:  277:  if(tsKelvin[1]<=0.0) { /* Flags that the user has not set it. */
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
      500:  278:    tKelvin = tsKelvin[0];
        -:  279:  } else {
        -:  280:    tKelvin = tsKelvin[1];
        -:  281:  }
        -:  282:
      500:  283:  if(par->collPartUserSetFlags==0){ /* this means the user did not set any of the collision-partner-related parameters. Use the old formula. */
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
    #####:  284:    dustToGas = AMU*2.4*dens[0]/gtd;
        -:  285:  }else{
        -:  286:    gasMassDensityAMUs = 0.0;
     1000:  287:    for(di=0;di<par->numDensities;di++)
branch  0 taken 50%
branch  1 taken 50% (fallthrough)
      500:  288:      gasMassDensityAMUs += dens[di]*par->collPartMolWeights[di];
        -:  289:
      500:  290:    dustToGas = AMU*gasMassDensityAMUs/gtd;
        -:  291:  }
        -:  292:
     1000:  293:  for(iline=0;iline<numLines;iline++){
branch  0 taken 50%
branch  1 taken 50% (fallthrough)
      500:  294:    knus[iline] = kappatab[iline]*dustToGas;
      500:  295:    dusts[iline] = planckfunc(freqs[iline],tKelvin);
call    0 returned 100%
        -:  296:  }
      500:  297:}
        -:  298:
        -:  299:/*....................................................................*/
function allBitsSet called 14 returned 100% blocks executed 67%
       14:  300:_Bool allBitsSet(const int flags, const int mask){
        -:  301:  /* Returns true only if all the masked bits of flags are set. */
        -:  302:
       14:  303:  if(~flags & mask)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  304:    return 0;
        -:  305:  else
    #####:  306:    return 1;
        -:  307:}
        -:  308:
        -:  309:/*....................................................................*/
function anyBitSet called 1 returned 100% blocks executed 100%
        1:  310:_Bool anyBitSet(const int flags, const int mask){
        -:  311:  /* Returns true if any of the masked bits of flags are set. */
        -:  312:
        1:  313:  if(flags & mask)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  314:    return 1;
        -:  315:  else
        1:  316:    return 0;
        -:  317:}
        -:  318:
        -:  319:/*....................................................................*/
function bitIsSet called 22 returned 100% blocks executed 100%
       22:  320:_Bool bitIsSet(const int flags, const int bitI){
        -:  321:  /* Returns true if the designated bit of flags is set. */
        -:  322:
       22:  323:  if(flags & (1 << bitI))
branch  0 taken 77% (fallthrough)
branch  1 taken 23%
        -:  324:    return 1;
        -:  325:  else
       17:  326:    return 0;
        -:  327:}
        -:  328:
        -:  329:/*....................................................................*/
function onlyBitsSet called 6 returned 100% blocks executed 100%
        6:  330:_Bool onlyBitsSet(const int flags, const int mask){
        -:  331:  /* Returns true if flags has no bits set apart from those which are true in mask. */
        -:  332:
        6:  333:  if(flags & ~mask)
branch  0 taken 83% (fallthrough)
branch  1 taken 17%
        -:  334:    return 0;
        -:  335:  else
        5:  336:    return 1;
        -:  337:}
