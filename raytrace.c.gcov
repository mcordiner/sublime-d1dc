        -:    0:Source:src/raytrace.c
        -:    0:Graph:src/raytrace.gcno
        -:    0:Data:src/raytrace.gcda
        -:    0:Runs:1
        -:    1:#include "lime.h"
        -:    2:#include <math.h>
        -:    3:
        -:    4:struct flux{
        -:    5:  double *intense;
        -:    6:  double *tau;
        -:    7:};
        -:    8:
        -:    9:struct fluxc{
        -:   10:  double *intense;
        -:   11:  double *tau;
        -:   12:  double *image;
        -:   13:  double *imageRB;
        -:   14:};
        -:   15:
        -:   16:struct molecule{
        -:   17:  int numLines;
        -:   18:  int *lines;
        -:   19:};
        -:   20:
        -:   21:struct rayData{
        -:   22:  int *id;
        -:   23:  double *radius;
        -:   24:  struct molecule *mols;
        -:   25:  struct flux *flux;
        -:   26:  struct fluxc *fluxc;
        -:   27:};
        -:   28:
        -:   29:/*....................................................................*/
function calcGridContDustOpacity called 1 returned 100% blocks executed 56%
        1:   30:void calcGridContDustOpacity(configInfo *par, const double freq\
        -:   31:  , double *lamtab, double *kaptab, const int nEntries, struct grid *gp){
        -:   32:
        -:   33:  int id;
        -:   34:  double gtd;
        -:   35:  gsl_spline *spline = NULL;
        -:   36:  gsl_interp_accel *acc = NULL;
        -:   37:  double *kappatab = NULL;
        -:   38:  double *knus=NULL, *dusts=NULL;
        -:   39:  double *freqs=NULL;
        -:   40:
        1:   41:  kappatab = malloc(sizeof(*kappatab)*1);
        1:   42:  knus     = malloc(sizeof(*knus)    *1);
        1:   43:  dusts    = malloc(sizeof(*dusts)   *1);
        1:   44:  freqs    = malloc(sizeof(*freqs)   *1);
        -:   45:
        1:   46:  freqs[0] = freq;
        -:   47:
        1:   48:  if(par->dust == NULL)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        1:   49:    kappatab[0] = 0.;
        -:   50:  else{
    #####:   51:    acc = gsl_interp_accel_alloc();
call    0 never executed
    #####:   52:    spline = gsl_spline_alloc(gsl_interp_cspline,nEntries);
call    0 never executed
    #####:   53:    gsl_spline_init(spline,lamtab,kaptab,nEntries);
call    0 never executed
    #####:   54:    kappatab[0] = interpolateKappa(freq, lamtab, kaptab, nEntries, spline, acc);
call    0 never executed
        -:   55:  }
        -:   56:
      501:   57:  for(id=0;id<par->ncell;id++){
branch  0 taken 100%
branch  1 taken 1% (fallthrough)
      500:   58:    gasIIdust(gp[id].x[0],gp[id].x[1],gp[id].x[2],&gtd);
call    0 returned 100%
      500:   59:    calcDustData(par, gp[id].dens, freqs, gtd, kappatab, 1, gp[id].t, knus, dusts); /* in aux.c. */
call    0 returned 100%
      500:   60:    gp[id].cont.knu = knus[0];
      500:   61:    gp[id].cont.dust = dusts[0];
        -:   62:  }
        -:   63:
        1:   64:  if(par->dust != NULL){
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:   65:    gsl_spline_free(spline);
call    0 never executed
    #####:   66:    gsl_interp_accel_free(acc);
call    0 never executed
        -:   67:  }
        1:   68:  free(knus);
        1:   69:  free(dusts);
        1:   70:  free(freqs);
        1:   71:  free(kappatab);
        1:   72:}
        -:   73:
        -:   74:
        -:   75:/*....................................................................*/
        -:   76:void
function traceray called 500 returned 100% blocks executed 50%
      500:   77:traceray(imageInfo *img,configInfo *par,struct grid *gp,molData *md,struct rayData rayData,const int im, int index, double* rho_grid, int dz_grid_size, double* dz_grid, double* dz_vals, int* dz_indices, double* posneg, double local_cmb, double* vels){
        -:   78:
        -:   79:// Note: this can be sped up considerably by separating the main loop into 2 parts: (1) generating the source function for each channel for each z point, and (2) doing the linear interpolation in a separate loop
        -:   80:
        -:   81:  int ichan,stokesId,di,i,j,posn1,posn2,molI,lineI,lineID,zp_i,navg,totalNumImagePixels,lastchan,ppi;
        -:   82:  double zp,x[DIM],dx[DIM],vel[DIM],dz,dtau,col,r,logr,avg,avgtau,newBinWidth;
        -:   83:  double contJnu,contAlpha,alpha,jnu,jnu1,alpha1,jnu2,alpha2,logr1,logr2,lineRedShift,vThisChan,deltav,logdz,vfac=0.0;
        -:   84:  double remnantSnu,expDTau,brightnessIncrement, *newvels=NULL;
        -:   85:
      500:   86:  totalNumImagePixels = img[im].pxls*img[im].pxls;
        -:   87:
     2000:   88:  for(di=0;di<DIM;di++){
branch  0 taken 75%
branch  1 taken 25% (fallthrough)
     1500:   89:    dx[di]= -img[im].rotMat[di][2]; /* This points towards the observer. */
        -:   90:  }
        -:   91:
      500:   92:  x[0] = rho_grid[index];
        -:   93:  x[1] = 0.0;
        -:   94:
        -:   95:  
        -:   96:  // Loop through the z-axis of the coma (from back to front), integrating the source function
    50500:   97:  for (zp_i=0;zp_i<(2*dz_grid_size);zp_i++){
branch  0 taken 99%
branch  1 taken 1% (fallthrough)
        -:   98:  
    50000:   99:   x[2] = posneg[zp_i] * dz_grid[dz_indices[zp_i]];
    50000:  100:   dz = dz_vals[dz_indices[zp_i]];
    50000:  101:   r = sqrt(x[0]*x[0] + x[1]*x[1] + x[2]*x[2]);
    50000:  102:   logr=log10(r);
        -:  103:    
        -:  104:    // Find the CVODE grid points that bracket our current radius, and if we are inside the model boundary, add to the integral
    50000:  105:    if (r < rayData.radius[par->pIntensity - 1] && r > par->minScale){
branch  0 taken 100% (fallthrough)
branch  1 taken 1%
branch  2 taken 99% (fallthrough)
branch  3 taken 1%
    49398:  106:      if (r > rayData.radius[0]){
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
 15419712:  107:       for (i = 1; i < par->pIntensity; i++){
branch  0 taken 100%
branch  1 taken 0% (fallthrough)
 15419712:  108:         if (rayData.radius[i] > r){
branch  0 taken 1% (fallthrough)
branch  1 taken 100%
    49398:  109:             posn1 = rayData.id[i];
    49398:  110:             posn2 = rayData.id[i-1];
    49398:  111:             logr1 = log10(rayData.radius[i]);
    49398:  112:             logr2 = log10(rayData.radius[i-1]);
    49398:  113:             break;
        -:  114:         }
        -:  115:       }
        -:  116:      
        -:  117:      // Find the velocity vector   
    49398:  118:      velocity(x[0],x[1],x[2],vel);
call    0 returned 100%
        -:  119:     
        -:  120:      /* Calculate first the continuum stuff because it is the same for all channels:*/
        -:  121:      
        -:  122:      // If zp is behind the nucleus, set continuum source terms accordingly and do not include any line component
    49398:  123:      if(x[0] < par->minScale && x[2] < 0){
branch  0 taken 3% (fallthrough)
branch  1 taken 97%
branch  2 taken 50% (fallthrough)
branch  3 taken 50%
        -:  124:
        -:  125:        alpha = 1.0e-2;  // Arbitrarily high opacity (cm^-1) for the solid nucleus
      651:  126:        jnu = alpha * planckfunc(img[im].freq,par->tNuc);
call    0 returned 100%
        -:  127:      
    33201:  128:        for(ichan=0;ichan<img[im].nchan;ichan++){
branch  0 taken 98%
branch  1 taken 2% (fallthrough)
        -:  129:
    32550:  130:            dtau=alpha*dz;
    32550:  131:            calcSourceFn(dtau, par, &remnantSnu, &expDTau);
call    0 returned 100%
    32550:  132:            remnantSnu *= jnu*dz;
        -:  133:
        -:  134:            #ifdef FASTEXP
    32550:  135:            brightnessIncrement = FastExp(rayData.flux[index].tau[ichan])*remnantSnu;
call    0 returned 100%
        -:  136:            #else
        -:  137:            brightnessIncrement =    exp(-rayData.flux[index].tau[ichan])*remnantSnu;
        -:  138:            #endif
        -:  139:
    32550:  140:            rayData.flux[index].intense[ichan] += brightnessIncrement;
    32550:  141:            rayData.flux[index].tau[ichan] += dtau;
        -:  142:
        -:  143:        }
        -:  144:
        -:  145:      }else{
    48747:  146:          contJnu = 0.0;
    48747:  147:          contAlpha = 0.0;
        -:  148:      
    48747:  149:          sourceFunc_cont(gp[posn1].cont, &contJnu, &contAlpha);
call    0 returned 100%
        -:  150:
  2486097:  151:          for(ichan=0;ichan<img[im].nchan;ichan++){
branch  0 taken 2%
branch  1 taken 98%
  2437350:  152:            jnu1 = contJnu;
  2437350:  153:            alpha1 = contAlpha;
  2437350:  154:            jnu2 = contJnu;
  2437350:  155:            alpha2 = contAlpha;
        -:  156:
  2437350:  157:            vThisChan = vels[ichan];
  2437350:  158:            if(img[im].doline){
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
  4874700:  159:              for(molI=0;molI<par->nSpecies;molI++){
branch  0 taken 50% (fallthrough)
branch  1 taken 50%
  4874700:  160:                for(lineID=0;lineID<rayData.mols[molI].numLines;lineID++){
branch  0 taken 50%
branch  1 taken 50% (fallthrough)
  2437350:  161:                    lineI = rayData.mols[molI].lines[lineID];
        -:  162:                    /* Calculate the red shift of the transition wrt to the frequency specified for the image.
        -:  163:                    */
  2437350:  164:                    if(img[im].trans > -1){
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
  2437350:  165:                      lineRedShift=(md[img[im].molI].freq[img[im].trans]-md[molI].freq[lineI])/md[img[im].molI].freq[img[im].trans]*CLIGHT;
        -:  166:                    } else {
    #####:  167:                      lineRedShift=(img[im].freq-md[molI].freq[lineI])/img[im].freq*CLIGHT;
        -:  168:                    }
  2437350:  169:                    deltav = vThisChan - img[im].source_vel - lineRedShift;
        -:  170:
        -:  171:                    /* Calculating the source function for the nearest two radial points, which will later be used to intepolate the jnu and alpha at the current radial point. Could add some logic here to store the jnu and alpha values as a function of position (and velocity), and look them up if needed again, rather than recalculating them (good idea to test how often the same one gets reused, to know if this would help).
        -:  172:                    */
        -:  173:
        -:  174:                    //Calculating source function and velocity term for 1st radial point
  2437350:  175:                    vfac = gaussline(deltav-dotProduct3D(dx,vel),gp[posn1].mol[molI].binv);                  
call    0 returned 100%
call    1 returned 100%
  2437350:  176:                    sourceFunc_line(&md[molI],vfac,&(gp[posn1].mol[molI]),lineI,&jnu1,&alpha1);
call    0 returned 100%
        -:  177:
        -:  178:                    //Calculating source function and velocity term for 2nd radial point
  2437350:  179:                    vfac = gaussline(deltav-dotProduct3D(dx,vel),gp[posn2].mol[molI].binv);       
call    0 returned 100%
call    1 returned 100%
  2437350:  180:                    sourceFunc_line(&md[molI],vfac,&(gp[posn2].mol[molI]),lineI,&jnu2,&alpha2);
call    0 returned 100%
        -:  181:
        -:  182:                }//end for lineI
        -:  183:              }//end for molI
        -:  184:            }//end if doline
        -:  185:
  2437350:  186:            alpha = linear_interp(logr1, logr2, alpha1, alpha2, logr);
call    0 returned 100%
  2437350:  187:            jnu = linear_interp(logr1, logr2, jnu1, jnu2, logr);
call    0 returned 100%
        -:  188:
  2437350:  189:            dtau=alpha*dz;
  2437350:  190:            calcSourceFn(dtau, par, &remnantSnu, &expDTau);
call    0 returned 100%
  2437350:  191:            remnantSnu *= jnu*dz;
        -:  192:
        -:  193:        #ifdef FASTEXP
  2437350:  194:            brightnessIncrement = FastExp(rayData.flux[index].tau[ichan])*remnantSnu;
call    0 returned 100%
        -:  195:        #else
        -:  196:            brightnessIncrement =    exp(-rayData.flux[index].tau[ichan])*remnantSnu;
        -:  197:        #endif
        -:  198:
  2437350:  199:            rayData.flux[index].intense[ichan] += brightnessIncrement;
  2437350:  200:            rayData.flux[index].tau[ichan] += dtau;
        -:  201:      
        -:  202:          }//end loop over ichan
        -:  203:         }//check for r<radius[0]
        -:  204:      }//Check if current point is behind the nucleus
        -:  205:    }//Check current point is within the model boundary 
        -:  206:  }//Loop over z points
        -:  207:
        -:  208:/* Convolve the spectral axis by the requested PSF*/
      500:  209:   if(img[im].psfShape == 1){ // Boxcar smooth
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  210:      if(img[im].psfKernelN%2!=0){// Odd kernel width
branch  0 never executed
branch  1 never executed
        -:  211:        // printf("Boxcar smoothing %d\n",img[im].psfKernelN);
    #####:  212:         for(ichan=0;ichan<img[im].nchan;ichan++){
branch  0 never executed
branch  1 never executed
        -:  213:            avg=0.;
        -:  214:            avgtau=0.;
    #####:  215:            for(i=-(img[im].psfKernelN-1)/2;i<=(img[im].psfKernelN-1)/2;i++){
branch  0 never executed
branch  1 never executed
    #####:  216:               if (ichan+i > -1 && ichan+i < img[im].nchan){
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  217:                  avg += rayData.flux[index].intense[ichan+i];
    #####:  218:                  avgtau += rayData.flux[index].tau[ichan+i];
        -:  219:               }
        -:  220:            }   
    #####:  221:            rayData.fluxc[index].intense[ichan]=avg/img[im].psfKernelN;
    #####:  222:            rayData.fluxc[index].tau[ichan]=avgtau/img[im].psfKernelN;
        -:  223:         }
        -:  224:      }else{// Even kernel width - have to interpolate the values to find the intermediate points
        -:  225:       //  printf("Boxcar smoothing %d\n",img[im].psfKernelN);
    #####:  226:         for(ichan=0;ichan<img[im].nchan;ichan++){
branch  0 never executed
branch  1 never executed
        -:  227:            avg=0.;
        -:  228:            avgtau=0.;
    #####:  229:            for(i=-img[im].psfKernelN/2;i<img[im].psfKernelN/2;i++){
branch  0 never executed
branch  1 never executed
    #####:  230:               if (ichan+i > -1 && ichan+i+1 < img[im].nchan){
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  231:                  avg += (rayData.flux[index].intense[ichan+i]+rayData.flux[index].intense[ichan+i+1])/2.0;
    #####:  232:                  avgtau += (rayData.flux[index].tau[ichan+i]+rayData.flux[index].tau[ichan+i+1])/2.0;
        -:  233:               }
        -:  234:            }   
    #####:  235:            rayData.fluxc[index].intense[ichan]=avg/img[im].psfKernelN;
    #####:  236:            rayData.fluxc[index].tau[ichan]=avgtau/img[im].psfKernelN;
        -:  237:         }
        -:  238:      }    
      500:  239:    }else if(img[im].psfShape == 2){ // Gaussian smooth - note that the Gaussian kernel size is always odd
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  240:      // printf("Gaussian smoothing %.2f\n",img[im].psfWidth);
    #####:  241:        for(ichan = (img[im].psfKernelN-1)/2; ichan < (img[im].nchan - ((img[im].psfKernelN-1)/2)); ichan++){
branch  0 never executed
branch  1 never executed
        -:  242:            avg=0.;
        -:  243:            avgtau=0.;
    #####:  244:            for(i=0;i<img[im].psfKernelN;i++){
branch  0 never executed
branch  1 never executed
    #####:  245:               avg += img[im].psfKernel[i] * rayData.flux[index].intense[ichan-((img[im].psfKernelN-1)/2)+i];
    #####:  246:               avgtau += img[im].psfKernel[i] * rayData.flux[index].tau[ichan-((img[im].psfKernelN-1)/2)+i];
        -:  247:            }
    #####:  248:            rayData.fluxc[index].intense[ichan]=avg;
    #####:  249:            rayData.fluxc[index].tau[ichan]=avgtau;
        -:  250:         }
        -:  251:      /*Zero-padded end regions where the kernel runs off the ends of the spectrum */
    #####:  252:        for(ichan=0; ichan<(img[im].psfKernelN-1)/2; ichan ++){
branch  0 never executed
branch  1 never executed
        -:  253:           avg=0.;
        -:  254:           avgtau=0.;
    #####:  255:           for(i=((img[im].psfKernelN-1)/2)-ichan;i<img[im].psfKernelN;i++){
branch  0 never executed
branch  1 never executed
    #####:  256:              avg += img[im].psfKernel[i] * rayData.flux[index].intense[ichan+i-((img[im].psfKernelN-1)/2)];
    #####:  257:              avgtau += img[im].psfKernel[i] * rayData.flux[index].tau[ichan+i-((img[im].psfKernelN-1)/2)];
        -:  258:           }  
    #####:  259:           rayData.fluxc[index].intense[ichan]=avg; 
    #####:  260:           rayData.fluxc[index].tau[ichan]=avgtau;
        -:  261:        }
    #####:  262:        for(ichan=img[im].nchan - ((img[im].psfKernelN-1)/2) ; ichan < img[im].nchan; ichan ++){
branch  0 never executed
branch  1 never executed
        -:  263:           avg=0.;
        -:  264:           avgtau=0.;
    #####:  265:           for(i=0;i<((img[im].psfKernelN-1)/2) + (img[im].nchan - ichan);i++){
branch  0 never executed
branch  1 never executed
    #####:  266:              avg += img[im].psfKernel[i] * rayData.flux[index].intense[ichan+i-((img[im].psfKernelN-1)/2)];
    #####:  267:              avgtau += img[im].psfKernel[i] * rayData.flux[index].tau[ichan+i-((img[im].psfKernelN-1)/2)];
        -:  268:           }  
    #####:  269:           rayData.fluxc[index].intense[ichan]=avg;
    #####:  270:           rayData.fluxc[index].tau[ichan]=avgtau;
        -:  271:        }
        -:  272:        
        -:  273:   }else{// No spectral smoothing
      500:  274:       rayData.fluxc[index].intense = rayData.flux[index].intense;
      500:  275:       rayData.fluxc[index].tau = rayData.flux[index].tau;
        -:  276:   }
        -:  277:   
        -:  278:   //Combine tau and intense to make the image vector:
        -:  279:   
        -:  280:  #ifdef FASTEXP
    25500:  281:    for(ichan=0;ichan<img[im].nchan;ichan++){
branch  0 taken 98%
branch  1 taken 2% (fallthrough)
    25000:  282:      rayData.fluxc[index].image[ichan] = rayData.fluxc[index].intense[ichan] + (FastExp(rayData.fluxc[index].tau[ichan])-1.0)*local_cmb;
call    0 returned 100%
        -:  283:    }
        -:  284:  #else
        -:  285:    for(ichan=0;ichan<img[im].nchan;ichan++){
        -:  286:      rayData.fluxc[index].image[ichan] = rayData.fluxc[index].intense[ichan] + (exp(-rayData.fluxc[index].tau[ichan])-1.0)*local_cmb;
        -:  287:    }
        -:  288:  #endif
        -:  289:  
        -:  290:  // Rebin the image vector spectral axis (if required) 
      500:  291:  if(img[im].rebinSpec == 1){
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  292:     newvels = malloc(sizeof(*newvels) * img[im].nBins);
    #####:  293:        for(ichan=0;ichan<img[im].nBins;ichan++){
branch  0 never executed
branch  1 never executed
    #####:  294:           newvels[ichan] = (ichan-(img[im].nBins-1)*0.5)*img[im].binWidth;
        -:  295:        }
        -:  296:
    #####:  297:     for(i=0;i<img[im].nBins;i++){
branch  0 never executed
branch  1 never executed
    #####:  298:        for(j=0;j<img[im].nchan;j++){
branch  0 never executed
branch  1 never executed
    #####:  299:          if(vels[j]>newvels[i]){
branch  0 never executed
branch  1 never executed
        -:  300:          break;
        -:  301:          }
        -:  302:        }
        -:  303:  
    #####:  304:        if (j==img[im].nchan){
branch  0 never executed
branch  1 never executed
    #####:  305:          rayData.fluxc[index].imageRB[i] = rayData.fluxc[index].image[img[im].nchan-1];
    #####:  306:        }else if (j==0){
branch  0 never executed
branch  1 never executed
    #####:  307:          rayData.fluxc[index].imageRB[i] = rayData.fluxc[index].image[0];
        -:  308:        }else{
    #####:  309:          rayData.fluxc[index].imageRB[i] = linear_interp(vels[j], vels[j-1], rayData.fluxc[index].image[j], rayData.fluxc[index].image[j-1], newvels[i]);
call    0 never executed
        -:  310:        }  
        -:  311:     }
        -:  312:  
        -:  313:  // Overwrite the original image vector for this ray index
    #####:  314:  rayData.fluxc[index].image = rayData.fluxc[index].imageRB;   
        -:  315:      
        -:  316:  }
        -:  317:  
        -:  318:  
        -:  319:  
      500:  320:}
        -:  321:
        -:  322:/*....................................................................*/
function rhoGrid2image called 65536 returned 100% blocks executed 59%
    65536:  323:void rhoGrid2image(int ppi,configInfo *par, double *rho_grid, struct rayData rayData, imageInfo *img, double pixelSize, double imgCentrePixels, const int im){
        -:  324:/*Take the raytraced rho vector and interpolate it into the 2D image grid at pixel number ppi*/
        -:  325:
        -:  326:    double xs[2], ro;
        -:  327:    int ppx, ppy, ichan, i, index;
        -:  328:        
    65536:  329:    ppx = ppi % img[im].pxls;
    65536:  330:    ppy = (int)(ppi/img[im].pxls);
        -:  331:
    65536:  332:    xs[0] = (0.5 + ppx - imgCentrePixels) * pixelSize;
    65536:  333:    xs[1] = (0.5 + ppy - imgCentrePixels) * pixelSize;
    65536:  334:    ro = sqrt(xs[0]*xs[0] + xs[1]*xs[1]);
        -:  335:    
    65536:  336:    if(ro>=rho_grid[par->pIntensity-1]){
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  337:    // Pixel is outside model domain so set to zero
    #####:  338:      for(ichan=0;ichan<img[im].nchan;ichan++){
branch  0 never executed
branch  1 never executed
    #####:  339:          img[im].pixel[ppi].intense[ichan] = 0.0;
    #####:  340:          img[im].pixel[ppi].tau[ichan] = 0.0;          
        -:  341:        }
        -:  342:    }else{
        -:  343:    
 27917924:  344:    for(i=0;i<par->pIntensity;i++) //TODO: use a more efficient searching algorithm, such as binary search (since its already sorted)
branch  0 taken 100%
branch  1 taken 0% (fallthrough)
 27917924:  345:      if(rho_grid[i]>ro){
branch  0 taken 100% (fallthrough)
branch  1 taken 1%
        -:  346:        index =i;
        -:  347:        break;
        -:  348:      }
        -:  349:      
    65536:  350:      if(index==0){
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  351:        for(ichan=0;ichan<img[im].nchan;ichan++){
branch  0 never executed
branch  1 never executed
    #####:  352:          img[im].pixel[ppi].intense[ichan] = rayData.fluxc[index].image[ichan];
    #####:  353:          img[im].pixel[ppi].tau[ichan] = rayData.fluxc[index].tau[ichan];          
        -:  354:        }
        -:  355:      }
        -:  356:
    65536:  357:      else if(index==par->pIntensity){
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
    #####:  358:        index = par->pIntensity-1;
    #####:  359:        for(ichan=0;ichan<img[im].nchan;ichan++){
branch  0 never executed
branch  1 never executed
    #####:  360:          img[im].pixel[ppi].intense[ichan] = rayData.fluxc[index].image[ichan];
    #####:  361:          img[im].pixel[ppi].tau[ichan] = rayData.fluxc[index].tau[ichan];
        -:  362:        }
        -:  363:      }
        -:  364:      else{
  3342336:  365:        for(ichan=0;ichan<img[im].nchan;ichan++){
branch  0 taken 98%
branch  1 taken 2% (fallthrough)
  3276800:  366:          img[im].pixel[ppi].intense[ichan] = linear_interp(log10(rho_grid[index-1]),log10(rho_grid[index]),rayData.fluxc[index-1].image[ichan],rayData.fluxc[index].image[ichan],log10(ro));
call    0 returned 100%
  3276800:  367:          img[im].pixel[ppi].tau[ichan] = linear_interp(log10(rho_grid[index-1]),log10(rho_grid[index]),rayData.fluxc[index-1].tau[ichan],rayData.fluxc[index].tau[ichan],log10(ro));
call    0 returned 100%
        -:  368:        }
        -:  369:      }
        -:  370:    }
    65536:  371:}
        -:  372:
        -:  373:/*....................................................................*/
        -:  374:void
function raytrace called 1 returned 100% blocks executed 82%
        1:  375:raytrace(int im, configInfo *par, struct grid *gp, molData *md\
        1:  376:  , imageInfo *img, double *lamtab, double *kaptab, const int nEntries, double *radii){
        -:  377:
        -:  378:  /*
        -:  379:This function constructs an image cube by following sets of rays (at least 1 per image pixel) through the model, solving the radiative transfer equations as appropriate for each ray. The ray locations within each pixel are chosen randomly within the pixel, but the number of rays per pixel is set equal to the number of projected model grid points falling within that pixel, down to a minimum equal to par->alias.
        -:  380:
        -:  381:Note that the argument 'md', and the grid element '.mol', are only accessed for line images.
        -:  382:  */
        -:  383:
        1:  384:  printf("\nRaytracing in progress...\n");
call    0 returned 100%
        -:  385:
        1:  386:    double pixelSize, imgCentrePixels,minfreq,absDeltaFreq,xs[2],rho_grid[par->pIntensity], sorted_radius[par->pIntensity], ro;
        -:  387:    int totalNumImagePixels,ppi, ichan,lastChan,molI,lineI,i,j,k,di, xi, yi,id, index, pixoff,pixoff2,pixshiftx,pixshifty, nsupsamppix,numRays;
        -:  388:    double local_cmb,cmbFreq,scale,shift,offset,logdz,*vels = NULL,*zp_grid = NULL,*dz_grid = NULL,*dz_vals = NULL,*posneg = NULL;
        -:  389:    int cmbMolI,cmbLineI, ppx,ppy,*dz_indices = NULL;
        -:  390:
        -:  391:    // Set up the z integration grid. Length of the z grid is double this:
        -:  392:    int dz_grid_size = 50;
        -:  393:  
        -:  394:    // Image parameters
        1:  395:    pixelSize = img[im].distance*img[im].imgres;
        1:  396:    totalNumImagePixels = img[im].pxls*img[im].pxls;
        1:  397:    imgCentrePixels = img[im].pxls/2.0;
        -:  398:
        -:  399:
        1:  400:    if(img[im].doline){
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  401:    /* The user may have set img.trans/img.molI but not img.freq. If so, we calculate freq now.*/
        1:  402:      if(img[im].trans>-1)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        1:  403:        img[im].freq = md[img[im].molI].freq[img[im].trans];
        -:  404:
        -:  405:      /* Fill in the missing one of the triplet nchan/velres/bandwidth.
        -:  406:      */
       1*:  407:      if(img[im].bandwidth > 0 && img[im].velres > 0){
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
branch  2 never executed
branch  3 never executed
    #####:  408:        img[im].nchan = (int)(img[im].bandwidth/(img[im].velres/CLIGHT*img[im].freq));
        -:  409:
       1*:  410:      }else if(img[im].bandwidth > 0 && img[im].nchan > 0){
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
branch  2 never executed
branch  3 never executed
    #####:  411:        img[im].velres = img[im].bandwidth*CLIGHT/img[im].freq/img[im].nchan;
        -:  412:
        -:  413:      }else{ /*(img[im].velres > 0 && img[im].nchan > 0 */
        1:  414:        img[im].bandwidth = img[im].nchan*img[im].velres/CLIGHT*img[im].freq;
        -:  415:      }
        -:  416:    } /* If not doline, we already have img.freq and nchan by now anyway. */
        -:  417:
        -:  418:  /*
        -:  419:  We need to calculate or choose a single value of 'local' CMB flux, also single values (i.e. one of each per grid point) of dust and knu, all corresponding the the nominal image frequency. The sensible thing would seem to be to calculate them afresh for each new image; and for continuum images, this is what in fact has always been done. For line images however local_cmb and the dust/knu values were calculated for the frequency of each spectral line and stored respectively in the molData struct and the struct populations element of struct grid. These multiple values (of dust/knu at least) are required during the main solution kernel of LIME, so for line images at least they were kept until the present point, just so one from their number could be chosen. :-/
        -:  420:  At the present point in the code, for line images, instead of calculating the 'continuum' values of local_cmb/dust/knu, the algorithm chose the nearest 'line' frequency and calculates the required numbers from that. The intent is to preserve (for the present at least) the former numerical behaviour, while changing the way the information is parcelled out among the variables and structs. I.e. a dedicated 'continuum' pair of dust/knu values is now available for each grid point in addition to the array of spectral line values. This decoupling allows better management of memory and avoids the deceptive use of spectral-line variables for continuum use.
        -:  421:  */
        1:  422:   if(img[im].doline){
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        1:  423:    if (img[im].trans>=0){
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        1:  424:      cmbMolI  = img[im].molI;
        -:  425:      cmbLineI = img[im].trans;
        -:  426:
        -:  427:    }else{ /* User didn't set trans. Find the nearest line to the image frequency. */
    #####:  428:      minfreq = fabs(img[im].freq - md[0].freq[0]);;
        -:  429:      cmbMolI = 0;
        -:  430:      cmbLineI = 0;
    #####:  431:      for(molI=0;molI<par->nSpecies;molI++){
branch  0 never executed
branch  1 never executed
    #####:  432:        for(lineI=0;lineI<md[molI].nline;lineI++){
branch  0 never executed
branch  1 never executed
    #####:  433:          if((molI==0 && lineI==0)) continue;
branch  0 never executed
branch  1 never executed
        -:  434:
    #####:  435:          absDeltaFreq = fabs(img[im].freq - md[molI].freq[lineI]);
    #####:  436:          if(absDeltaFreq < minfreq){
branch  0 never executed
branch  1 never executed
        -:  437:            minfreq = absDeltaFreq;
        -:  438:            cmbMolI = molI;
        -:  439:            cmbLineI = lineI;
        -:  440:          }
        -:  441:        }
        -:  442:      }
        -:  443:    }
        1:  444:    cmbFreq = md[cmbMolI].freq[cmbLineI];
        -:  445:
        -:  446:  }else{ /* continuum image */
    #####:  447:    cmbFreq = img[im].freq;
        -:  448:  }
        -:  449:
        1:  450:  local_cmb = planckfunc(cmbFreq,LOCAL_CMB_TEMP);
call    0 returned 100%
        1:  451:  calcGridContDustOpacity(par, cmbFreq, lamtab, kaptab, nEntries, gp); /* Reads gp attributes x, dens, and t and writes attributes cont.dust and cont.knu. */
call    0 returned 100%
        -:  452:
        -:  453:  struct rayData rayData;
        1:  454:  rayData.id = malloc(sizeof(int) * par->pIntensity);
        1:  455:  rayData.flux = malloc(sizeof(*rayData.flux) * par->pIntensity);
        1:  456:  rayData.fluxc = malloc(sizeof(*rayData.fluxc) * par->pIntensity);
        1:  457:  rayData.radius = radii;
        -:  458:  double current;
        -:  459:  
        1:  460:  offset =  rayData.radius[0] + 1.0e-30;
        -:  461:  
      501:  462:  for (i = 0; i < par->pIntensity; i++) {
branch  0 taken 100%
branch  1 taken 1% (fallthrough)
      500:  463:    rho_grid[i] = rayData.radius[i] - offset;
        -:  464:    //printf("radius=%le\n",rayData.radius[i]);
        -:  465:  }
        -:  466:
        -:  467:  //This code involving a gridpoint lookup table should be overhauled now that we have a sorted radius array (radii)
      501:  468:  for (i = 0; i < par->pIntensity; i++) {
branch  0 taken 100%
branch  1 taken 1% (fallthrough)
      500:  469:    current = rayData.radius[i];
   250500:  470:    for (j = 0; j < par->pIntensity; j++) //TODO: More efficient algorithm than sequential search could be implemented
branch  0 taken 100%
branch  1 taken 1% (fallthrough)
   250000:  471:      if (current == gp[j].radius)
branch  0 taken 1% (fallthrough)
branch  1 taken 100%
      500:  472:        rayData.id[i] = j; //holds sorted ids according to the time/radius of its corresponding gridpoint
        -:  473:  }
        -:  474:
      501:  475:  for(i = 0; i < par->pIntensity; i++){
branch  0 taken 100%
branch  1 taken 1% (fallthrough)
      500:  476:    rayData.flux[i].intense= malloc(sizeof(double) * img[im].nchan);
      500:  477:    rayData.fluxc[i].intense= malloc(sizeof(double) * img[im].nchan);
      500:  478:    rayData.flux[i].tau= malloc(sizeof(double) * img[im].nchan);
      500:  479:    rayData.fluxc[i].tau= malloc(sizeof(double) * img[im].nchan);
      500:  480:    rayData.fluxc[i].image= malloc(sizeof(double) * img[im].nchan);
      500:  481:    rayData.fluxc[i].imageRB= malloc(sizeof(double) * img[im].nBins);
        -:  482:
    25500:  483:    for(ichan=0;ichan<img[im].nchan;ichan++){
branch  0 taken 98%
branch  1 taken 2% (fallthrough)
    25000:  484:      rayData.flux[i].intense[ichan] = 0.0;
    25000:  485:      rayData.flux[i].tau[ichan] = 0.0;
        -:  486:    }
        -:  487:  }
        -:  488:
        1:  489:  rayData.mols = malloc(sizeof(*rayData.mols) * par->nSpecies);
        -:  490:  int numLines= 0;
        -:  491:
        -:  492:  //For each molecule,count how many lines fall within the spectral range of the image. This way, we know how much space to allocate for each rayData.mols[molI].lines
        -:  493:  //We do these steps now so that we don't need to determine which spectral lines contribute to the image repeteadly inside traceray(), which is time consuming
        2:  494:  for(molI=0;molI<par->nSpecies;molI++){
branch  0 taken 50% (fallthrough)
branch  1 taken 50%
       26:  495:    for(lineI=0;lineI<md[molI].nline;lineI++){
branch  0 taken 96%
branch  1 taken 4% (fallthrough)
       25:  496:      if((md[molI].freq[lineI] * (1. - img[im].source_vel/CLIGHT)) > img[im].freq-img[im].bandwidth*0.5\
branch  0 taken 88% (fallthrough)
branch  1 taken 12%
       22:  497:        && (md[molI].freq[lineI] * (1. - img[im].source_vel/CLIGHT)) < img[im].freq+img[im].bandwidth*0.5){
branch  0 taken 5% (fallthrough)
branch  1 taken 95%
        1:  498:        numLines++;
        -:  499:      }
        -:  500:    }
        1:  501:    rayData.mols[molI].lines = malloc(sizeof(*rayData.mols[molI].lines)*numLines);
        1:  502:    rayData.mols[molI].numLines = numLines;
        -:  503:    numLines = 0;
        -:  504:  }
        -:  505:
        -:  506:  //Now we store the index of the lines that contribute to the image.
        2:  507:  for(molI=0;molI<par->nSpecies;molI++){
branch  0 taken 50% (fallthrough)
branch  1 taken 50%
        -:  508:    index = 0;
       26:  509:    for(lineI=0;lineI<md[molI].nline;lineI++){
branch  0 taken 96%
branch  1 taken 4% (fallthrough)
       25:  510:      if((md[molI].freq[lineI] * (1. - img[im].source_vel/CLIGHT)) > img[im].freq-img[im].bandwidth*0.5\
branch  0 taken 88% (fallthrough)
branch  1 taken 12%
       22:  511:        && (md[molI].freq[lineI] * (1. - img[im].source_vel/CLIGHT)) < img[im].freq+img[im].bandwidth*0.5){
branch  0 taken 5% (fallthrough)
branch  1 taken 95%
        1:  512:        rayData.mols[molI].lines[index] = lineI;
        1:  513:        index++;
        -:  514:      }
        -:  515:    }
        -:  516:  }
        -:  517:  
        -:  518:  // Set up the z integration grid
        1:  519:  dz_grid = malloc(sizeof(*dz_grid) * dz_grid_size);
        1:  520:  dz_vals = malloc(sizeof(*dz_vals) * dz_grid_size);
        1:  521:  dz_indices = malloc(sizeof(*dz_indices) * dz_grid_size * 2);
        1:  522:  posneg = malloc(sizeof(*posneg) * dz_grid_size * 2);
        1:  523:  zp_grid = malloc(sizeof(*zp_grid) * (dz_grid_size + 1));
        -:  524:  
        -:  525:  // Channel velocities
        1:  526:  vels = malloc(sizeof(*vels) * img[im].nchan);
       51:  527:  for(ichan=0;ichan<img[im].nchan;ichan++){
branch  0 taken 98%
branch  1 taken 2% (fallthrough)
       50:  528:      vels[ichan] = (ichan-(img[im].nchan-1)*0.5)*img[im].velres;
        -:  529:  }
        -:  530:   
        -:  531:  //Creating zp_grid
        1:  532:  logdz=log10(par->radius)/dz_grid_size;
       52:  533:  for (i=0;i<=dz_grid_size;i++){
branch  0 taken 98%
branch  1 taken 2% (fallthrough)
       51:  534:  zp_grid[i]=pow(10,i*logdz)-1.0;
        -:  535:  }
        1:  536:  zp_grid[dz_grid_size]=par->radius;
        -:  537:  
        -:  538:  //Halfway points and associated dz values
       51:  539:  for (i=0;i<dz_grid_size;i++){
branch  0 taken 98%
branch  1 taken 2% (fallthrough)
       50:  540:  dz_grid[i]=(zp_grid[i]+zp_grid[i+1])/2.0;
       50:  541:  dz_vals[i]=zp_grid[i+1]-zp_grid[i];
        -:  542:  }
        -:  543:
        -:  544:  //Generate the indices and posneg terms (for front vs. back of coma)
        -:  545:  j=0;
       51:  546:  for (i=(dz_grid_size-1);i>=0;i--){
branch  0 taken 98%
branch  1 taken 2% (fallthrough)
       50:  547:     dz_indices[j]=i;
       50:  548:     posneg[j]=1.0;
       50:  549:     j++;
        -:  550:  }
       51:  551:    for (i=0;i<dz_grid_size;i++){
branch  0 taken 98%
branch  1 taken 2% (fallthrough)
       50:  552:     dz_indices[j]=i;
       50:  553:     posneg[j]=-1.0;
       50:  554:     j++;
        -:  555:  }
        -:  556:
        1:  557:  printf("Calling traceray...\n");
call    0 returned 100%
        -:  558:  
        -:  559:  // Do the raytracing as a function of rho (linear vector from the origin), to later be interpolated onto the image grid
        -:  560:  // Parallel loop over rho grid points
        1:  561:  omp_set_num_threads(par->nThreads);
call    0 returned 100%
        1:  562:  #pragma omp parallel for schedule (dynamic)
        -:  563:  for(i = 0; i < par->pIntensity; i++){
        -:  564:    traceray(img,par,gp,md,rayData,im,i,rho_grid,dz_grid_size,dz_grid,dz_vals,dz_indices,posneg,local_cmb,vels);
        -:  565:  }
        -:  566:
        1:  567:  if(img[im].rebinSpec == 1){
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  568:     img[im].nchan = img[im].nBins;
    #####:  569:     img[im].velres = img[im].binWidth;
        -:  570:  }
        -:  571:
        1:  572:  free(dz_grid);
        1:  573:  free(dz_vals);
        1:  574:  free(zp_grid);
        1:  575:  free(dz_indices);
        -:  576:  
        1:  577:  printf("Interpolating to image grid...\n");
call    0 returned 100%
        -:  578:
        -:  579:  // Parallel loop over image pixels
        1:  580:  #pragma omp parallel for schedule (dynamic)
        -:  581:  for (ppi = 0; ppi<totalNumImagePixels; ppi++){
        -:  582:     rhoGrid2image(ppi,par,rho_grid,rayData,img,pixelSize,imgCentrePixels,im);
        -:  583:  }
        -:  584:
        1:  585:  printf("Supersampling the central pixels...\n");
call    0 returned 100%
        -:  586:  
        -:  587:  const int supsamp = 20; // Number of rays per pixel (supsamp * supsamp in x,y plane)
        1:  588:  scale = pixelSize/((double)supsamp);
        -:  589:  
        1:  590:  if(img[im].pxls % 2 != 0){
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  591:  // If there is an odd number of image pixels, supersample the innermost nsupsamppix x nsupsamppix region:
        -:  592:      nsupsamppix = 5; 
    #####:  593:      shift = (pixelSize/2.0) + (scale/2.0);
        -:  594:      pixoff = 1;
        -:  595:      pixoff2 = 0;
        -:  596:  }else{
        -:  597:  // If there is an even number of image pixels, supersample the innermost nsupsamppix x nsupsamppix region:
        -:  598:      nsupsamppix = 4;
        1:  599:      shift = (scale/2.0);
        -:  600:      pixoff = 0;
        -:  601:      pixoff2 = 1;
        -:  602:  }
        -:  603:  
        5:  604:  for(pixshiftx=(pixoff-nsupsamppix)/2;pixshiftx<=(nsupsamppix-pixoff-pixoff2)/2;pixshiftx++){
branch  0 taken 80%
branch  1 taken 20% (fallthrough)
        -:  605:  // Parallel loop over y axis of supersampled region. At some point we should extend this treatment to all pixels
        4:  606:    #pragma omp parallel for schedule (dynamic) default(shared) private(numRays,xi,yi,ppi,ichan,i,j,xs,ro,index,k)
        -:  607:    for(pixshifty=(pixoff-nsupsamppix)/2;pixshifty<=(nsupsamppix-pixoff-pixoff2)/2;pixshifty++){
        -:  608:      
        -:  609:      numRays=0;
        -:  610:      
        -:  611:      // Initially set supersampled pixels to zero
        -:  612:      xi=pixshiftx+(img[im].pxls-pixoff)/2;
        -:  613:      yi=pixshifty+(img[im].pxls-pixoff)/2;
        -:  614:      ppi = yi * img[im].pxls + xi;
        -:  615:      for(ichan=0;ichan<img[im].nchan;ichan++){
        -:  616:          img[im].pixel[ppi].intense[ichan] = 0.0;
        -:  617:          img[im].pixel[ppi].tau[ichan] = 0.0;
        -:  618:      }
        -:  619:      
        -:  620:      for(j=1;j<=supsamp;j++){
        -:  621:        for(i=1;i<=supsamp;i++){
        -:  622:          xs[0] = (j*scale) - shift + (pixshiftx*pixelSize);
        -:  623:          xs[1] = (i*scale) - shift + (pixshifty*pixelSize);
        -:  624:          ro = sqrt(xs[0]*xs[0] + xs[1]*xs[1]);
        -:  625:          
        -:  626:          if(ro>=par->radius){
        -:  627:            // Outside the model boundary so do not add any flux
        -:  628:            numRays++;
        -:  629:            continue;
        -:  630:          
        -:  631:          }else{
        -:  632:          
        -:  633:          xi = round(xs[0]/pixelSize + imgCentrePixels - 0.5);
        -:  634:          yi = round(xs[1]/pixelSize + imgCentrePixels - 0.5);
        -:  635:          ppi = yi * img[im].pxls + xi;
        -:  636:          numRays++;
        -:  637:
        -:  638:          for(k=0;k<par->pIntensity;k++)
        -:  639:            if(rho_grid[k]>ro){
        -:  640:              index =k;
        -:  641:              break;
        -:  642:            }
        -:  643:          for(ichan=0;ichan<img[im].nchan;ichan++){
        -:  644:              img[im].pixel[ppi].intense[ichan] += linear_interp(log10(rho_grid[index-1]),log10(rho_grid[index]),rayData.fluxc[index-1].image[ichan],rayData.fluxc[index].image[ichan],log10(ro)); 
        -:  645:              img[im].pixel[ppi].tau[ichan] += linear_interp(log10(rho_grid[index-1]),log10(rho_grid[index]),rayData.fluxc[index-1].tau[ichan],rayData.fluxc[index].tau[ichan],log10(ro));
        -:  646:            }
        -:  647:          }
        -:  648:        }
        -:  649:      }
        -:  650:    
        -:  651:     for(ichan=0;ichan<img[im].nchan;ichan++){
        -:  652:       img[im].pixel[ppi].intense[ichan] /= numRays;
        -:  653:       img[im].pixel[ppi].tau[ichan] /= numRays;
        -:  654:     }
        -:  655:    }
        -:  656:  }
        -:  657:  
        -:  658:
      501:  659:  for(i = 0; i < par->pIntensity; i++){
branch  0 taken 100%
branch  1 taken 1% (fallthrough)
      500:  660:    free(rayData.flux[i].intense);
      500:  661:    free(rayData.flux[i].tau);
      500:  662:    if(img[im].psfShape != 0){
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  663:      free(rayData.fluxc[i].intense);
    #####:  664:      free(rayData.fluxc[i].tau); 
        -:  665:    }
        -:  666:  }
        2:  667:  for(molI=0;molI<par->nSpecies;molI++){
branch  0 taken 50%
branch  1 taken 50% (fallthrough)
        1:  668:    free(rayData.mols[molI].lines);
        -:  669:  }
        1:  670:  free(rayData.id);
        1:  671:  free(rayData.flux);
        1:  672:  free(rayData.fluxc);
        1:  673:  free(rayData.mols);
        -:  674:
        -:  675:
        1:  676:printf("Raytracing done...\n");
call    0 returned 100%
        -:  677:
        1:  678:}
