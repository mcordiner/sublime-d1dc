        -:    0:Source:src/solver.c
        -:    0:Graph:src/solver.gcno
        -:    0:Data:src/solver.gcda
        -:    0:Runs:1
        -:    1:/*
        -:    2: *  solver.c
        -:    3: *  This file is part of LIME, the versatile line modeling engine
        -:    4: *
        -:    5: *  Copyright (C) 2006-2014 Christian Brinch
        -:    6: *  Copyright (C) 2015-2017 The LIME development team
        -:    7: *
        -:    8:TODO:
        -:    9:  - The test to run calculateJBar() etc in levelPops just tests dens[0]. This is a bit sloppy.
        -:   10: */
        -:   11:
        -:   12:#include <stdio.h>
        -:   13:#include <stdlib.h>
        -:   14:
        -:   15:#include <cvode/cvode.h>               /* prototypes for CVODE fcts., consts.  */
        -:   16:#include <nvector/nvector_serial.h>    /* access to serial N_Vector            */
        -:   17:#include <sunmatrix/sunmatrix_dense.h> /* access to dense SUNMatrix            */
        -:   18:#include <sunlinsol/sunlinsol_dense.h> /* access to dense SUNLinearSolver      */
        -:   19:#include <sundials/sundials_types.h>   /* defs. of realtype, sunindextype      */
        -:   20:
        -:   21:#include "lime.h"
        -:   22:#include <gsl/gsl_sort.h>
        -:   23:#include <gsl/gsl_statistics.h>
        -:   24:#include <gsl/gsl_vector.h>
        -:   25:#include <gsl/gsl_permutation.h>
        -:   26:#include <gsl/gsl_errno.h>
        -:   27:#include <gsl/gsl_sf_bessel.h>
        -:   28:
        -:   29://###
        -:   30:#define Ith(v,i)    NV_Ith_S(v,i)         /* Ith numbers components 0..NEQ-1 */
        -:   31:#define IJth(sunMatrix,i,j) SM_ELEMENT_D(sunMatrix,i,j) /* IJth numbers rows,cols 0..NEQ-1 */
        -:   32:
        -:   33:/* Data concerning a single grid vertex which is passed from calculateJBar() to solveStatEq(). This data needs to be thread-safe. */
        -:   34:typedef struct {
        -:   35:  double *jbar,*phot,*vfac,*vfac_loc;
        -:   36:} gridPointData;
        -:   37:
        -:   38:struct blend{
        -:   39:  int molJ, lineJ;
        -:   40:  double deltaV;
        -:   41:};
        -:   42:
        -:   43:struct lineWithBlends{
        -:   44:  int lineI, numBlends;
        -:   45:  struct blend *blends;
        -:   46:};
        -:   47:
        -:   48:struct molWithBlends{
        -:   49:  int molI, numLinesWithBlends;
        -:   50:  struct lineWithBlends *lines;
        -:   51:};
        -:   52:
        -:   53:struct blendInfo{
        -:   54:  int numMolsWithBlends;
        -:   55:  struct molWithBlends *mols;
        -:   56:};
        -:   57:struct time_struct{
        -:   58:  int *id;
        -:   59:  double *time;
        -:   60:};
        -:   61:
        -:   62:
        -:   63:/* Parameters used to determine transition rates */
        -:   64:struct cvode_physdata{
        -:   65:  int array_size; //Equal to the number of levels (i.e NEQ)
        -:   66:  double *A_array; //Holds Einstein's As
        -:   67:  double *transition_rates; //Holds transition rates
        -:   68:  molData *md;
        -:   69:  int ispec;
        -:   70:  struct grid *gp;
        -:   71:  configInfo *par;
        -:   72:  double *jbar_grid;
        -:   73:  int *nMaserWarnings;
        -:   74:  struct CKCdata CKCdata; 
        -:   75:};
        -:   76:
        -:   77:/* Checks for errors when calling any CVode functions */
function check_retval called 0 returned 0% blocks executed 0%
    #####:   78:int check_retval(void *returnvalue, const char *funcname, int opt)
        -:   79:{
        -:   80:  int *retval;
        -:   81:
        -:   82:  /* Check if SUNDIALS function returned NULL pointer - no memory allocated */
    #####:   83:  if (opt == 0 && returnvalue == NULL) {
branch  0 never executed
branch  1 never executed
    #####:   84:    fprintf(stderr, "\nSUNDIALS_ERROR: %s() failed - returned NULL pointer\n\n",
call    0 never executed
        -:   85:      funcname);
    #####:   86:    return(1); }
        -:   87:
        -:   88:  /* Check if retval < 0 */
    #####:   89:  else if (opt == 1) {
branch  0 never executed
branch  1 never executed
        -:   90:    retval = (int *) returnvalue;
    #####:   91:    if (*retval < 0) {
branch  0 never executed
branch  1 never executed
    #####:   92:      fprintf(stderr, "\nSUNDIALS_ERROR: %s() failed with retval = %d\n\n",
call    0 never executed
        -:   93:        funcname, *retval);
    #####:   94:      return(1); }}
        -:   95:
        -:   96:  /* Check if function returned NULL pointer - no memory allocated */
    #####:   97:  else if (opt == 2 && returnvalue == NULL) {
branch  0 never executed
branch  1 never executed
    #####:   98:    fprintf(stderr, "\nMEMORY_ERROR: %s() failed - returned NULL pointer\n\n",
call    0 never executed
        -:   99:      funcname);
    #####:  100:    return(1); }
        -:  101:
        -:  102:  return(0);
        -:  103:}
        -:  104:
        -:  105:/* ELECTRON TEMPERATURE FUNCTION: ORIGINAL VERSION */
function Telec called 0 returned 0% blocks executed 0%
    #####:  106:double Telec(double r, double Q, double Tkin){
        -:  107:  double Te,rcs;
        -:  108:  double Tmax = 1e4;
    #####:  109:  rcs = 1.125e6 * pow(Q/1e29,0.75);
    #####:  110:  if (r < rcs) {
branch  0 never executed
branch  1 never executed
        -:  111:    Te = Tkin;
        -:  112:  }
    #####:  113:  else if (r > 2.*rcs) {
branch  0 never executed
branch  1 never executed
        -:  114:    Te = Tmax;
        -:  115:  }
        -:  116:  else {
    #####:  117:    Te = Tkin + (Tmax - Tkin)*((r/rcs)-1.);
        -:  118:  }
    #####:  119:  return Te;
        -:  120:}
        -:  121:
        -:  122:/* ELECTRON DENSITY FUNCTION: ORIGINAL VERSION */
function nelec called 0 returned 0% blocks executed 0%
    #####:  123:double nelec(double r, double Q, double vexp, double Te, double rH, double xne){
        -:  124:  double Rrec, ne, krec, kion;
        -:  125:  kion = 4.1e-7;
    #####:  126:  krec = 3e-13 * sqrt(300./Te); /* Recombination rate From RATE12, accountiong for cm3 to m3 conversion */
    #####:  127:  Rrec = 3.2e6 * sqrt(Q/1e29);
        -:  128:  /* Equation 5 of Zakharov 2007 */
    #####:  129:  ne = xne * sqrt(Q*kion/vexp/krec/(rH*rH)) * pow((Te/300.),0.15) * (Rrec/(r*r)) * (1-exp(-r/Rrec)) + (5e6/(rH*rH));
        -:  130:  
    #####:  131:  return ne;
        -:  132:}
        -:  133:
        -:  134:
        -:  135:
        -:  136:/*....................................................................*/
        -:  137:void
function freeMolsWithBlends called 0 returned 0% blocks executed 0%
    #####:  138:freeMolsWithBlends(struct molWithBlends *mols, const int numMolsWithBlends){
        -:  139:  int mi, li;
        -:  140:
    #####:  141:  if(mols != NULL){
branch  0 never executed
branch  1 never executed
    #####:  142:    for(mi=0;mi<numMolsWithBlends;mi++){
branch  0 never executed
branch  1 never executed
    #####:  143:      if(mols[mi].lines != NULL){
branch  0 never executed
branch  1 never executed
    #####:  144:        for(li=0;li<mols[mi].numLinesWithBlends;li++)
branch  0 never executed
branch  1 never executed
    #####:  145:          free(mols[mi].lines[li].blends);
    #####:  146:        free(mols[mi].lines);
        -:  147:      }
        -:  148:    }
    #####:  149:    free(mols);
        -:  150:  }
    #####:  151:}
        -:  152:
        -:  153:/*....................................................................*/
        -:  154:void
function freeGridPointData called 0 returned 0% blocks executed 0%
    #####:  155:freeGridPointData(const int nSpecies, gridPointData *mol){
        -:  156:  /*
        -:  157:Note that this is called from within the multi-threaded block.
        -:  158:  */
        -:  159:  int i;
    #####:  160:  if(mol!= NULL){
branch  0 never executed
branch  1 never executed
    #####:  161:    for(i=0;i<nSpecies;i++){
branch  0 never executed
branch  1 never executed
    #####:  162:      free(mol[i].jbar);
    #####:  163:      free(mol[i].phot);
    #####:  164:      free(mol[i].vfac);
    #####:  165:      free(mol[i].vfac_loc);
        -:  166:    }
        -:  167:  }
    #####:  168:}
        -:  169:
        -:  170:
        -:  171:/*....................................................................*/
function mallocGridCont called 0 returned 0% blocks executed 0%
    #####:  172:void mallocGridCont(configInfo *par, molData *md, struct grid *gp){
        -:  173:  int id,si,li;
        -:  174:
    #####:  175:  for(id=0;id<par->ncell;id++){
branch  0 never executed
branch  1 never executed
    #####:  176:    for(si=0;si<par->nSpecies;si++){
branch  0 never executed
branch  1 never executed
    #####:  177:      gp[id].mol[si].cont = malloc(sizeof(*(gp[id].mol[si].cont))*md[si].nline);
    #####:  178:      for(li=0;li<md[si].nline;li++){
branch  0 never executed
branch  1 never executed
    #####:  179:        gp[id].mol[si].cont[li].dust = 0.0;
    #####:  180:        gp[id].mol[si].cont[li].knu  = 0.0;
        -:  181:      }
        -:  182:    }
        -:  183:  }
    #####:  184:}
        -:  185:
        -:  186:/*....................................................................*/
function freeGridCont called 0 returned 0% blocks executed 0%
    #####:  187:void freeGridCont(configInfo *par, struct grid *gp){
        -:  188:  int id,si;
        -:  189:
    #####:  190:  for(id=0;id<par->ncell;id++){
branch  0 never executed
branch  1 never executed
    #####:  191:    if(gp[id].mol==NULL)
branch  0 never executed
branch  1 never executed
    #####:  192:      continue;
        -:  193:
    #####:  194:    for(si=0;si<par->nSpecies;si++){
branch  0 never executed
branch  1 never executed
    #####:  195:      free(gp[id].mol[si].cont);
    #####:  196:      gp[id].mol[si].cont = NULL;
        -:  197:    }
        -:  198:  }
    #####:  199:}
        -:  200:
        -:  201:/*....................................................................*/
function calcGridLinesDustOpacity called 0 returned 0% blocks executed 0%
    #####:  202:void calcGridLinesDustOpacity(configInfo *par, molData *md, double *lamtab\
        -:  203:  , double *kaptab, const int nEntries, struct grid *gp){
        -:  204:
        -:  205:  int iline,id,si;
        -:  206:  double *kappatab,gtd;
        -:  207:  gsl_spline *spline = NULL;
        -:  208:  gsl_interp_accel *acc = NULL;
        -:  209:  double *knus=NULL, *dusts=NULL;
        -:  210:
    #####:  211:  if(par->dust != NULL){
branch  0 never executed
branch  1 never executed
    #####:  212:    acc = gsl_interp_accel_alloc();
call    0 never executed
    #####:  213:    spline = gsl_spline_alloc(gsl_interp_cspline,nEntries);
call    0 never executed
    #####:  214:    gsl_spline_init(spline,lamtab,kaptab,nEntries);
call    0 never executed
        -:  215:  }
        -:  216:
    #####:  217:  for(si=0;si<par->nSpecies;si++){
branch  0 never executed
branch  1 never executed
    #####:  218:    kappatab = malloc(sizeof(*kappatab)*md[si].nline);
    #####:  219:    knus     = malloc(sizeof(*knus)    *md[si].nline);
    #####:  220:    dusts    = malloc(sizeof(*dusts)   *md[si].nline);
        -:  221:
    #####:  222:    if(par->dust == NULL){
branch  0 never executed
branch  1 never executed
    #####:  223:      for(iline=0;iline<md[si].nline;iline++)
branch  0 never executed
branch  1 never executed
    #####:  224:        kappatab[iline] = 0.;
        -:  225:    }else{
    #####:  226:      for(iline=0;iline<md[si].nline;iline++)
branch  0 never executed
branch  1 never executed
    #####:  227:        kappatab[iline] = interpolateKappa(md[si].freq[iline]\
call    0 never executed
        -:  228:                        , lamtab, kaptab, nEntries, spline, acc);
        -:  229:    }
        -:  230:
    #####:  231:    for(id=0;id<par->ncell;id++){
branch  0 never executed
branch  1 never executed
    #####:  232:      gasIIdust(gp[id].x[0],gp[id].x[1],gp[id].x[2],&gtd);
call    0 never executed
    #####:  233:      calcDustData(par, gp[id].dens, md[si].freq, gtd, kappatab, md[si].nline, gp[id].t, knus, dusts);
call    0 never executed
    #####:  234:      for(iline=0;iline<md[si].nline;iline++){
branch  0 never executed
branch  1 never executed
    #####:  235:        gp[id].mol[si].cont[iline].knu  = knus[iline];
    #####:  236:        gp[id].mol[si].cont[iline].dust = dusts[iline];
        -:  237:      }
        -:  238:    }
        -:  239:
    #####:  240:    free(kappatab);
    #####:  241:    free(knus);
    #####:  242:    free(dusts);
        -:  243:  }
        -:  244:
    #####:  245:  if(par->dust != NULL){
branch  0 never executed
branch  1 never executed
    #####:  246:    gsl_spline_free(spline);
call    0 never executed
    #####:  247:    gsl_interp_accel_free(acc);
call    0 never executed
        -:  248:  }
    #####:  249:}
        -:  250:
        -:  251:/*....................................................................*/
        -:  252:int
function getNextEdge called 0 returned 0% blocks executed 0%
    #####:  253:getNextEdge(double *inidir, const int startGi, const int presentGi\
        -:  254:  , struct grid *gp, const gsl_rng *ran){
        -:  255:  /*
        -:  256:The idea here is to select for the next grid point, that one which lies closest (with a little randomizing jitter) to the photon track, while requiring the direction of the edge to be in the 'forward' hemisphere of the photon direction.
        -:  257:
        -:  258:Note that this is called from within the multi-threaded block.
        -:  259:  */
        -:  260:  int i,ni,niOfSmallest=-1,niOfNextSmallest=-1;
        -:  261:  double dirCos,distAlongTrack,dirFromStart[3],coord,distToTrackSquared,smallest=0.0,nextSmallest=0.0;
        -:  262:  const static double scatterReduction = 0.4;
        -:  263:  /*
        -:  264:This affects the ratio of N_2/N_1, where N_2 is the number of times the edge giving the 2nd-smallest distance from the photon track is chosen and N_1 ditto the smallest. Some ratio values obtained from various values of scatterReduction:
        -:  265:
        -:  266:  scatterReduction  <N_2/N_1>
        -:  267:    1.0     0.42
        -:  268:    0.5     0.75
        -:  269:    0.4     0.90
        -:  270:    0.2     1.52
        -:  271:
        -:  272:Note that the equivalent ratio value produced by the 1.6 code was 0.91.
        -:  273:  */
        -:  274:
        -:  275:  i = 0;
    #####:  276:  for(ni=0;ni<gp[presentGi].numNeigh;ni++){
branch  0 never executed
branch  1 never executed
    #####:  277:    dirCos = dotProduct3D(inidir, gp[presentGi].dir[ni].xn);
call    0 never executed
        -:  278:
    #####:  279:    if(dirCos<=0.0)
branch  0 never executed
branch  1 never executed
    #####:  280:  continue; /* because the edge points in the backward direction. */
        -:  281:
    #####:  282:    dirFromStart[0] = gp[presentGi].neigh[ni]->x[0] - gp[startGi].x[0];
    #####:  283:    dirFromStart[1] = gp[presentGi].neigh[ni]->x[1] - gp[startGi].x[1];
    #####:  284:    dirFromStart[2] = gp[presentGi].neigh[ni]->x[2] - gp[startGi].x[2];
    #####:  285:    distAlongTrack = dotProduct3D(inidir, dirFromStart);
call    0 never executed
        -:  286:
    #####:  287:    coord = dirFromStart[0] - distAlongTrack*inidir[0];
    #####:  288:    distToTrackSquared  = coord*coord;
    #####:  289:    coord = dirFromStart[1] - distAlongTrack*inidir[1];
    #####:  290:    distToTrackSquared += coord*coord;
    #####:  291:    coord = dirFromStart[2] - distAlongTrack*inidir[2];
    #####:  292:    distToTrackSquared += coord*coord;
        -:  293:
    #####:  294:    if(i==0){
branch  0 never executed
branch  1 never executed
        -:  295:      smallest = distToTrackSquared;
        -:  296:      niOfSmallest = ni;
        -:  297:    }else{
    #####:  298:      if(distToTrackSquared<smallest){
branch  0 never executed
branch  1 never executed
        -:  299:        nextSmallest = smallest;
        -:  300:        niOfNextSmallest = niOfSmallest;
        -:  301:        smallest = distToTrackSquared;
        -:  302:        niOfSmallest = ni;
    #####:  303:      }else if(i==1 || distToTrackSquared<nextSmallest){
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  304:        nextSmallest = distToTrackSquared;
        -:  305:        niOfNextSmallest = ni;
        -:  306:      }
        -:  307:    }
        -:  308:
    #####:  309:    i++;
        -:  310:  }
        -:  311:
        -:  312:  /* Choose the edge to follow.
        -:  313:  */
    #####:  314:  if(i>1){ /* then nextSmallest, niOfNextSmallest should exist. */
branch  0 never executed
branch  1 never executed
    #####:  315:    if((smallest + scatterReduction*nextSmallest)*gsl_rng_uniform(ran)<smallest){
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  316:      return niOfNextSmallest;
        -:  317:    }else{
        -:  318:      return niOfSmallest;
        -:  319:    }
    #####:  320:  }else if(i>0){
branch  0 never executed
branch  1 never executed
        -:  321:    return niOfSmallest;
        -:  322:  }else{
    #####:  323:    if(!silent)
branch  0 never executed
branch  1 never executed
    #####:  324:      bail_out("Photon propagation error - no valid edges.");
call    0 never executed
    #####:  325:    exit(1);
call    0 never executed
        -:  326:  }
        -:  327:}
        -:  328:
        -:  329:/*....................................................................*/
function calcLineAmpPWLin called 0 returned 0% blocks executed 0%
    #####:  330:void calcLineAmpPWLin(struct grid *g, const int id, const int k\
        -:  331:  , const int molI, const double deltav, double *inidir, double *vfac_in, double *vfac_out){
        -:  332:  /*
        -:  333:Note that this is called from within the multi-threaded block.
        -:  334:  */
        -:  335:
        -:  336:  /* convolution of a Gaussian with a box */
        -:  337:  double binv_this, binv_next, v[5];
        -:  338:
    #####:  339:  binv_this=g[id].mol[molI].binv;
    #####:  340:  binv_next=(g[id].neigh[k])->mol[molI].binv;
    #####:  341:  v[0]=deltav-dotProduct3D(inidir,g[id].vel);
call    0 never executed
    #####:  342:  v[1]=deltav-dotProduct3D(inidir,&(g[id].v1[3*k]));
call    0 never executed
    #####:  343:  v[2]=deltav-dotProduct3D(inidir,&(g[id].v2[3*k]));
call    0 never executed
    #####:  344:  v[3]=deltav-dotProduct3D(inidir,&(g[id].v3[3*k]));
call    0 never executed
    #####:  345:  v[4]=deltav-dotProduct3D(inidir,g[id].neigh[k]->vel);
call    0 never executed
        -:  346:
        -:  347:  /* multiplying by the appropriate binv changes from velocity to doppler widths(?) */
        -:  348:  /* if the values were be no more than 2 erf table bins apart, we just take a single Gaussian */
        -:  349:
        -:  350:  /*
        -:  351:  vfac_out is the lineshape for the part of the edge in the current Voronoi cell,
        -:  352:  vfac_in is for the part in the next cell
        -:  353:  */
        -:  354:
    #####:  355:  if (fabs(v[1]-v[0])*binv_this>(2.0*BIN_WIDTH)) {
branch  0 never executed
branch  1 never executed
    #####:  356:     *vfac_out=0.5*geterf(v[0]*binv_this,v[1]*binv_this);
call    0 never executed
    #####:  357:  } else *vfac_out=0.5*gaussline(0.5*(v[0]+v[1]),binv_this);
call    0 never executed
    #####:  358:  if (fabs(v[2]-v[1])*binv_this>(2.0*BIN_WIDTH)) {
branch  0 never executed
branch  1 never executed
    #####:  359:    *vfac_out+=0.5*geterf(v[1]*binv_this,v[2]*binv_this);
call    0 never executed
    #####:  360:  } else *vfac_out+=0.5*gaussline(0.5*(v[1]+v[2]),binv_this);
call    0 never executed
        -:  361:
    #####:  362:  if (fabs(v[3]-v[2])*binv_next>(2.0*BIN_WIDTH)) {
branch  0 never executed
branch  1 never executed
    #####:  363:     *vfac_in=0.5*geterf(v[2]*binv_next,v[3]*binv_next);
call    0 never executed
    #####:  364:  } else *vfac_in=0.5*gaussline(0.5*(v[2]+v[3]),binv_next);
call    0 never executed
    #####:  365:  if (fabs(v[4]-v[3])*binv_next>(2.0*BIN_WIDTH)) {
branch  0 never executed
branch  1 never executed
    #####:  366:    *vfac_in+=0.5*geterf(v[3]*binv_next,v[4]*binv_next);
call    0 never executed
    #####:  367:  } else *vfac_in+=0.5*gaussline(0.5*(v[3]+v[4]),binv_next);
call    0 never executed
    #####:  368:}
        -:  369:
        -:  370:/*....................................................................*/
function calcLineAmpLin called 0 returned 0% blocks executed 0%
    #####:  371:void calcLineAmpLin(struct grid *g, const int id, const int k\
        -:  372:  , const int molI, const double deltav, double *inidir, double *vfac_in, double *vfac_out){
        -:  373:  /*
        -:  374:Note that this is called from within the multi-threaded block.
        -:  375:  */
        -:  376:
        -:  377:  /* convolution of a Gaussian with a box */
        -:  378:  double binv_this, binv_next, v[3];
        -:  379:
    #####:  380:  binv_this=g[id].mol[molI].binv;
    #####:  381:  binv_next=(g[id].neigh[k])->mol[molI].binv;
    #####:  382:  v[0]=deltav-dotProduct3D(inidir,g[id].vel);
call    0 never executed
    #####:  383:  v[2]=deltav-dotProduct3D(inidir,g[id].neigh[k]->vel);
call    0 never executed
    #####:  384:  v[1]=0.5*(v[0]+v[2]);
        -:  385:
    #####:  386:  if (fabs(v[1]-v[0])*binv_this>(2.0*BIN_WIDTH)) {
branch  0 never executed
branch  1 never executed
    #####:  387:     *vfac_out=geterf(v[0]*binv_this,v[1]*binv_this);
call    0 never executed
    #####:  388:  } else *vfac_out+=gaussline(0.5*(v[0]+v[1]),binv_this);
call    0 never executed
        -:  389:
    #####:  390:  if (fabs(v[2]-v[1])*binv_next>(2.0*BIN_WIDTH)) {
branch  0 never executed
branch  1 never executed
    #####:  391:     *vfac_in=geterf(v[1]*binv_next,v[2]*binv_next);
call    0 never executed
    #####:  392:  } else *vfac_in+=gaussline(0.5*(v[1]+v[2]),binv_next);
call    0 never executed
    #####:  393:}
        -:  394:
        -:  395:/*....................................................................*/
        -:  396:void
function calculateJBar called 0 returned 0% blocks executed 0%
    #####:  397:calculateJBar(int id, struct grid *gp, molData *md, const gsl_rng *ran\
        -:  398:  , configInfo *par, const int nlinetot, struct blendInfo blends\
    #####:  399:  , gridPointData *mp, double *halfFirstDs, int *nMaserWarnings){
        -:  400:  /*
        -:  401:Note that this is called from within the multi-threaded block.
        -:  402:  */
        -:  403:
        -:  404:  int iphot,iline,here,there,firststep,neighI,numLinks=0;
        -:  405:  int nextMolWithBlend, nextLineWithBlend, molI, lineI, molJ, lineJ, bi;
        -:  406:  double segment,vblend_in,vblend_out,dtau,expDTau,ds_in=0.0,ds_out=0.0,pt_theta,pt_z,semiradius;
    #####:  407:  double deltav[par->nSpecies],vfac_in[par->nSpecies],vfac_out[par->nSpecies],vfac_inprev[par->nSpecies];
    #####:  408:  double expTau[nlinetot],inidir[3];
        -:  409:  double remnantSnu,velProj;
        -:  410:  char message[STR_LEN_0];
        -:  411:
    #####:  412:  for(iphot=0;iphot<gp[id].nphot;iphot++){
branch  0 never executed
branch  1 never executed
        -:  413:    firststep=1;
        -:  414:    iline = 0;
    #####:  415:    for(molI=0;molI<par->nSpecies;molI++){
branch  0 never executed
branch  1 never executed
    #####:  416:      for(lineI=0;lineI<md[molI].nline;lineI++){
branch  0 never executed
branch  1 never executed
    #####:  417:        mp[molI].phot[lineI+iphot*md[molI].nline]=0.;
    #####:  418:        expTau[iline]=1.;
    #####:  419:        iline++;
        -:  420:      }
        -:  421:    }
        -:  422:
        -:  423:    /* Choose random initial photon direction (the distribution used here is even over the surface of a sphere of radius 1).
        -:  424:    */
    #####:  425:    pt_theta=gsl_rng_uniform(ran)*2*M_PI;
call    0 never executed
    #####:  426:    pt_z=2*gsl_rng_uniform(ran)-1;
call    0 never executed
    #####:  427:    semiradius = sqrt(1.-pt_z*pt_z);
    #####:  428:    inidir[0]=semiradius*cos(pt_theta);
    #####:  429:    inidir[1]=semiradius*sin(pt_theta);
    #####:  430:    inidir[2]=pt_z;
        -:  431:
        -:  432:    /* Choose the photon frequency/velocity offset.
        -:  433:    */
    #####:  434:    segment=gsl_rng_uniform(ran)-0.5;
call    0 never executed
        -:  435:    /*
        -:  436:    Values of segment should be evenly distributed (considering the
        -:  437:    entire ensemble of photons) between -0.5 and +0.5.
        -:  438:    */
        -:  439:
    #####:  440:    for (molI=0;molI<par->nSpecies;molI++){
branch  0 never executed
branch  1 never executed
        -:  441:      /* Is factor 4.3=[-2.15,2.15] enough?? */
    #####:  442:      deltav[molI]=4.3*segment*gp[id].mol[molI].dopb+dotProduct3D(inidir,gp[id].vel);
call    0 never executed
        -:  443:      /*
        -:  444:      This is the local (=evaluated at a grid point, not averaged over the local cell) lineshape.
        -:  445:      We store this for later use in ALI loops.
        -:  446:      */
    #####:  447:      mp[molI].vfac_loc[iphot]=gaussline(deltav[molI]-dotProduct3D(inidir,gp[id].vel),gp[id].mol[molI].binv);
call    0 never executed
call    1 never executed
        -:  448:    }
        -:  449:
    #####:  450:    here = gp[id].id;
        -:  451:
        -:  452:    /* Photon propagation loop */
        -:  453:    numLinks=0;
    #####:  454:    while(!gp[here].sink){ /* Testing for sink at loop start is redundant for the first step, since we only start photons from non-sink points, but it makes for simpler code. */
branch  0 never executed
branch  1 never executed
    #####:  455:      numLinks++;
    #####:  456:      if(numLinks>par->ncell){
branch  0 never executed
branch  1 never executed
    #####:  457:        if(!silent){
branch  0 never executed
branch  1 never executed
    #####:  458:          snprintf(message, STR_LEN_0, "Bad grid? Too many links in photon path, point %d photon %d", id, iphot);
    #####:  459:          bail_out(message);
call    0 never executed
        -:  460:        }
    #####:  461:exit(1);
call    0 never executed
        -:  462:      }
        -:  463:
    #####:  464:      neighI = getNextEdge(inidir,id,here,gp,ran);
call    0 never executed
        -:  465:
    #####:  466:      there=gp[here].neigh[neighI]->id;
        -:  467:
    #####:  468:      if(firststep){
branch  0 never executed
branch  1 never executed
        -:  469:        firststep=0;
    #####:  470:        ds_out=0.5*gp[here].ds[neighI]*dotProduct3D(inidir,gp[here].dir[neighI].xn);
call    0 never executed
    #####:  471:        halfFirstDs[iphot]=ds_out;
        -:  472:
    #####:  473:        for(molI=0;molI<par->nSpecies;molI++){
branch  0 never executed
branch  1 never executed
    #####:  474:          if(par->edgeVelsAvailable) {
branch  0 never executed
branch  1 never executed
    #####:  475:            calcLineAmpPWLin(gp,here,neighI,molI,deltav[molI],inidir,&vfac_in[molI],&vfac_out[molI]);
call    0 never executed
        -:  476:         } else
    #####:  477:            calcLineAmpLin(gp,here,neighI,molI,deltav[molI],inidir,&vfac_in[molI],&vfac_out[molI]);
call    0 never executed
        -:  478:
    #####:  479:          mp[molI].vfac[iphot]=vfac_out[molI];
        -:  480:        }
        -:  481:        /*
        -:  482:        Contribution of the local cell to emission and absorption is done in updateJBar.
        -:  483:        We only store the vfac for the local cell for use in ALI loops.
        -:  484:        */
        -:  485:        here=there;
    #####:  486:    continue;
        -:  487:      }
        -:  488:
        -:  489:      /* If we've got to here, we have progressed beyond the first edge. Length of the new "in" edge is the length of the previous "out".
        -:  490:      */
        -:  491:      ds_in=ds_out;
    #####:  492:      ds_out=0.5*gp[here].ds[neighI]*dotProduct3D(inidir,gp[here].dir[neighI].xn);
call    0 never executed
        -:  493:
    #####:  494:      for(molI=0;molI<par->nSpecies;molI++){
branch  0 never executed
branch  1 never executed
    #####:  495:        vfac_inprev[molI]=vfac_in[molI];
    #####:  496:        if(par->edgeVelsAvailable)
branch  0 never executed
branch  1 never executed
    #####:  497:          calcLineAmpPWLin(gp,here,neighI,molI,deltav[molI],inidir,&vfac_in[molI],&vfac_out[molI]);
call    0 never executed
        -:  498:        else
    #####:  499:          calcLineAmpLin(gp,here,neighI,molI,deltav[molI],inidir,&vfac_in[molI],&vfac_out[molI]);
call    0 never executed
        -:  500:      }
        -:  501:
        -:  502:      nextMolWithBlend = 0;
        -:  503:      iline = 0;
    #####:  504:      for(molI=0;molI<par->nSpecies;molI++){
branch  0 never executed
branch  1 never executed
        -:  505:        nextLineWithBlend = 0;
    #####:  506:        for(lineI=0;lineI<md[molI].nline;lineI++){
branch  0 never executed
branch  1 never executed
    #####:  507:          double jnu_line_in=0., jnu_line_out=0., jnu_cont=0., jnu_blend=0.;
    #####:  508:          double alpha_line_in=0., alpha_line_out=0., alpha_cont=0., alpha_blend=0.;
        -:  509:
    #####:  510:          sourceFunc_line(&md[molI],vfac_inprev[molI],&(gp[here].mol[molI]),lineI,&jnu_line_in,&alpha_line_in);
call    0 never executed
    #####:  511:          sourceFunc_line(&md[molI],vfac_out[molI],&(gp[here].mol[molI]),lineI,&jnu_line_out,&alpha_line_out);
call    0 never executed
    #####:  512:          sourceFunc_cont(gp[here].mol[molI].cont[lineI],&jnu_cont,&alpha_cont);
call    0 never executed
        -:  513:
        -:  514:          /* cont and blend could use the same alpha and jnu counter, but maybe it's clearer this way */
        -:  515:
        -:  516:          /* Line blending part.
        -:  517:          */
    #####:  518:          if(par->blend && blends.mols!=NULL && molI==blends.mols[nextMolWithBlend].molI\
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####:  519:          && lineI==blends.mols[nextMolWithBlend].lines[nextLineWithBlend].lineI){
branch  0 never executed
branch  1 never executed
        -:  520:
    #####:  521:            for(bi=0;bi<blends.mols[nextMolWithBlend].lines[nextLineWithBlend].numBlends;bi++){
branch  0 never executed
branch  1 never executed
    #####:  522:              molJ  = blends.mols[nextMolWithBlend].lines[nextLineWithBlend].blends[bi].molJ;
    #####:  523:              lineJ = blends.mols[nextMolWithBlend].lines[nextLineWithBlend].blends[bi].lineJ;
    #####:  524:              velProj = deltav[molI] - blends.mols[nextMolWithBlend].lines[nextLineWithBlend].blends[bi].deltaV;
        -:  525:        /*  */
    #####:  526:              if(par->edgeVelsAvailable)
branch  0 never executed
branch  1 never executed
    #####:  527:                calcLineAmpPWLin(gp,here,neighI,molJ,velProj,inidir,&vblend_in,&vblend_out);
call    0 never executed
        -:  528:              else
    #####:  529:                calcLineAmpLin(gp,here,neighI,molJ,velProj,inidir,&vblend_in,&vblend_out);
call    0 never executed
        -:  530:
        -:  531:        /* we should use also the previous vblend_in, but I don't feel like writing the necessary code now */
    #####:  532:              sourceFunc_line(&md[molJ],vblend_out,&(gp[here].mol[molJ]),lineJ,&jnu_blend,&alpha_blend);
call    0 never executed
        -:  533:              /* note that sourceFunc* increment jnu and alpha, they don't overwrite it  */
        -:  534:            }
        -:  535:
    #####:  536:            nextLineWithBlend++;
    #####:  537:            if(nextLineWithBlend>=blends.mols[nextMolWithBlend].numLinesWithBlends){
branch  0 never executed
branch  1 never executed
        -:  538:              nextLineWithBlend = 0;
        -:  539:              /* The reason for doing this is as follows. Firstly, we only enter the present IF block if molI has at least 1 line which is blended with others; and further, if we have now processed all blended lines for that molecule. Thus no matter what value lineI takes for the present molecule, it won't appear as blends.mols[nextMolWithBlend].lines[i].lineI for any i. Yet we will still test blends.mols[nextMolWithBlend].lines[nextLineWithBlend], thus we want nextLineWithBlend to at least have a sensible value between 0 and blends.mols[nextMolWithBlend].numLinesWithBlends-1. We could set nextLineWithBlend to any number in this range in safety, but zero is simplest. */
        -:  540:            }
        -:  541:          }
        -:  542:          /* End of line blending part */
        -:  543:
        -:  544:    /* as said above, out-in split should be done also for blended lines... */
        -:  545:
    #####:  546:    dtau=(alpha_line_out+alpha_cont+alpha_blend)*ds_out;
    #####:  547:          if(dtau < -MAX_NEG_OPT_DEPTH) dtau = -MAX_NEG_OPT_DEPTH;
branch  0 never executed
branch  1 never executed
    #####:  548:          calcSourceFn(dtau, par, &remnantSnu, &expDTau);
call    0 never executed
    #####:  549:          remnantSnu *= (jnu_line_out+jnu_cont+jnu_blend)*ds_out;
    #####:  550:          mp[molI].phot[lineI+iphot*md[molI].nline]+=expTau[iline]*remnantSnu;
    #####:  551:    expTau[iline]*=expDTau;
        -:  552:
    #####:  553:    dtau=(alpha_line_in+alpha_cont+alpha_blend)*ds_in;
    #####:  554:          if(dtau < -MAX_NEG_OPT_DEPTH) dtau = -MAX_NEG_OPT_DEPTH;
branch  0 never executed
branch  1 never executed
    #####:  555:          calcSourceFn(dtau, par, &remnantSnu, &expDTau);
call    0 never executed
    #####:  556:          remnantSnu *= (jnu_line_in+jnu_cont+jnu_blend)*ds_in;
    #####:  557:          mp[molI].phot[lineI+iphot*md[molI].nline]+=expTau[iline]*remnantSnu;
    #####:  558:    expTau[iline]*=expDTau;
        -:  559:
    #####:  560:          if(expTau[iline] > exp(MAX_NEG_OPT_DEPTH)){
branch  0 never executed
branch  1 never executed
    #####:  561:            (*nMaserWarnings)++;
    #####:  562:            expTau[iline]=exp(MAX_NEG_OPT_DEPTH);
        -:  563:          }
        -:  564:
    #####:  565:          iline++;
        -:  566:        } /* Next line this molecule. */
        -:  567:
    #####:  568:        if(par->blend && blends.mols!=NULL && molI==blends.mols[nextMolWithBlend].molI)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####:  569:          nextMolWithBlend++;
        -:  570:      }
        -:  571:
        -:  572:      here=there;
        -:  573:    };
        -:  574:
        -:  575:    /* Add cmb contribution.
        -:  576:    */
        -:  577:    iline = 0;
    #####:  578:    for(molI=0;molI<par->nSpecies;molI++){
branch  0 never executed
branch  1 never executed
    #####:  579:      for(lineI=0;lineI<md[molI].nline;lineI++){
branch  0 never executed
branch  1 never executed
    #####:  580:        mp[molI].phot[lineI+iphot*md[molI].nline]+=expTau[iline]*md[molI].cmb[lineI];
    #####:  581:        iline++;
        -:  582:      }
        -:  583:    }
        -:  584:  }
    #####:  585:}
        -:  586:
        -:  587:/*....................................................................*/
        -:  588:void
function updateJBar called 0 returned 0% blocks executed 0%
    #####:  589:updateJBar(int posn, molData *md, struct grid *gp, const int molI\
        -:  590:  , configInfo *par, struct blendInfo blends, int nextMolWithBlend\
        -:  591:  , gridPointData *mp, double *halfFirstDs){
        -:  592:  /*
        -:  593:Note that this is called from within the multi-threaded block.
        -:  594:  */
        -:  595:  int lineI,iphot,bi,molJ,lineJ,nextLineWithBlend;
        -:  596:  double dtau,expDTau,remnantSnu,vsum=0.;
        -:  597:  
    #####:  598:  for(lineI=0;lineI<md[molI].nline;lineI++) mp[molI].jbar[lineI]=0.;
branch  0 never executed
branch  1 never executed
        -:  599:
    #####:  600:  for(iphot=0;iphot<gp[posn].nphot;iphot++){
branch  0 never executed
branch  1 never executed
    #####:  601:    if(mp[molI].vfac_loc[iphot]>0){
branch  0 never executed
branch  1 never executed
        -:  602:      nextLineWithBlend = 0;
    #####:  603:      for(lineI=0;lineI<md[molI].nline;lineI++){
branch  0 never executed
branch  1 never executed
    #####:  604:        double jnu=0.0;
    #####:  605:        double alpha=0;
        -:  606:
    #####:  607:        sourceFunc_line(&md[molI],mp[molI].vfac[iphot],&(gp[posn].mol[molI]),lineI,&jnu,&alpha);
call    0 never executed
    #####:  608:        sourceFunc_cont(gp[posn].mol[molI].cont[lineI],&jnu,&alpha);
call    0 never executed
        -:  609:
        -:  610:        /* Line blending part.
        -:  611:        */
    #####:  612:        if(par->blend && blends.mols!=NULL && molI==blends.mols[nextMolWithBlend].molI\
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####:  613:        && lineI==blends.mols[nextMolWithBlend].lines[nextLineWithBlend].lineI){
branch  0 never executed
branch  1 never executed
    #####:  614:          for(bi=0;bi<blends.mols[nextMolWithBlend].lines[nextLineWithBlend].numBlends;bi++){
branch  0 never executed
branch  1 never executed
    #####:  615:            molJ  = blends.mols[nextMolWithBlend].lines[nextLineWithBlend].blends[bi].molJ;
    #####:  616:            lineJ = blends.mols[nextMolWithBlend].lines[nextLineWithBlend].blends[bi].lineJ;
        -:  617:            /*
        -:  618:            The next line is not quite correct, because vfac may be different for other molecules due to different values of binv. Unfortunately we don't necessarily have vfac for molJ available yet.
        -:  619:            */
    #####:  620:            sourceFunc_line(&md[molJ],mp[molI].vfac[iphot],&(gp[posn].mol[molJ]),lineJ,&jnu,&alpha);
call    0 never executed
        -:  621:      /* note that sourceFunc* increment jnu and alpha, they don't overwrite it  */
        -:  622:          }
        -:  623:
    #####:  624:          nextLineWithBlend++;
    #####:  625:          if(nextLineWithBlend>=blends.mols[nextMolWithBlend].numLinesWithBlends){
branch  0 never executed
branch  1 never executed
        -:  626:            nextLineWithBlend = 0;
        -:  627:            /* The reason for doing this is as follows. Firstly, we only enter the present IF block if molI has at least 1 line which is blended with others; and further, if we have now processed all blended lines for that molecule. Thus no matter what value lineI takes for the present molecule, it won't appear as blends.mols[nextMolWithBlend].lines[i].lineI for any i. Yet we will still test blends.mols[nextMolWithBlend].lines[nextLineWithBlend], thus we want nextLineWithBlend to at least have a sensible value between 0 and blends.mols[nextMolWithBlend].numLinesWithBlends-1. We could set nextLineWithBlend to any number in this range in safety, but zero is simplest. */
        -:  628:          }
        -:  629:        }
        -:  630:        /* End of line blending part */
        -:  631:
    #####:  632:        dtau=alpha*halfFirstDs[iphot];
    #####:  633:        calcSourceFn(dtau, par, &remnantSnu, &expDTau);
call    0 never executed
    #####:  634:        remnantSnu *= jnu*halfFirstDs[iphot];
    #####:  635:        mp[molI].jbar[lineI]+=mp[molI].vfac_loc[iphot]*(expDTau*mp[molI].phot[lineI+iphot*md[molI].nline]+remnantSnu);
        -:  636:
        -:  637:      }
    #####:  638:      vsum+=mp[molI].vfac_loc[iphot];
        -:  639:    }
        -:  640:  }
    #####:  641:  for(lineI=0;lineI<md[molI].nline;lineI++) mp[molI].jbar[lineI] /= vsum;
branch  0 never executed
branch  1 never executed
    #####:  642:}
        -:  643:
        -:  644:/*....................................................................*/
        -:  645:
        -:  646:void
function getTransitionRates called 0 returned 0% blocks executed 0%
    #####:  647:getTransitionRates(molData *md, int ispec, struct grid *gp, configInfo *par, int NEQ, double A[NEQ-1], double *p, realtype radius, double *jbar_grid, double *Pops, int *nMaserWarnings, double vexp, struct CKCdata *CKCdata){
        -:  648:  int itemp,ipart,t_binlow,iline,k,l,ti, li, upper, lower, j,tnint=-1;
    #####:  649:  double rnuc, Te, ne, aij, sigmaij, ve, bessel, ceij, gij, ceji, dens[md[ispec].npart], tkin[md[ispec].npart];
    #####:  650:  double jbar[par->pIntensity],molDens[par->nSpecies], tau, beta, interp_coeff;
        -:  651:
        -:  652:  rnuc = par->minScale;
    #####:  653:  density(radius,0.0,0.0,dens);
call    0 never executed
    #####:  654:  temperature(radius,0.0,0.0,tkin);
call    0 never executed
        -:  655:
        -:  656:  /* Initialize matrix with zeros */
    #####:  657:  if(md[ispec].nlev<=0){
branch  0 never executed
branch  1 never executed
    #####:  658:    if(!silent) bail_out("Matrix initialization error in solveStatEq");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  659:    exit(1);
call    0 never executed
        -:  660:  }
        -:  661:
    #####:  662:  for(k=0;k<md[ispec].nlev;k++)
branch  0 never executed
branch  1 never executed
    #####:  663:    for(l=0;l<md[ispec].nlev;l++){
branch  0 never executed
branch  1 never executed
    #####:  664:      p[k * NEQ + l] = 0.0;
        -:  665:    }
        -:  666:
        -:  667:  /* Populate matrix with collisional transitions */
    #####:  668:  for(ipart=0;ipart<md[ispec].npart;ipart++){
branch  0 never executed
branch  1 never executed
    #####:  669:    struct cpData part = md[ispec].part[ipart];
        -:  670:    double *downrates = part.down;
    #####:  671:    int di = md[ispec].part[ipart].densityIndex;
    #####:  672:    if (di<0) continue;
branch  0 never executed
branch  1 never executed
        -:  673:
        -:  674:  /* Collision temperature interpolation coefficients */
    #####:  675:    if((tkin[ipart]>part.temp[0])&&(tkin[ipart]<part.temp[part.ntemp-1])){
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  676:            for(itemp=0;itemp<part.ntemp-1;itemp++){
branch  0 never executed
branch  1 never executed
    #####:  677:              if((tkin[ipart]>part.temp[itemp])&&(tkin[ipart]<=part.temp[itemp+1])){
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  678:                tnint=itemp;
        -:  679:              }
        -:  680:            }
    #####:  681:            interp_coeff =(tkin[ipart]-part.temp[tnint])/(part.temp[tnint+1]-part.temp[tnint]);
    #####:  682:            t_binlow = tnint;
        -:  683:
    #####:  684:    } else if(tkin[ipart]<=part.temp[0]) {
branch  0 never executed
branch  1 never executed
        -:  685:      t_binlow = 0;
        -:  686:      interp_coeff = 0.0;
        -:  687:    } else {
    #####:  688:      t_binlow = part.ntemp-2;
        -:  689:      interp_coeff = 1.0;
        -:  690:    }
        -:  691:
        -:  692:
    #####:  693:    for(ti=0;ti<part.ntrans;ti++){
branch  0 never executed
branch  1 never executed
    #####:  694:      int coeff_index = ti*part.ntemp + t_binlow;
    #####:  695:      double down = downrates[coeff_index]\
    #####:  696:                  + interp_coeff*(downrates[coeff_index+1] - downrates[coeff_index]);
    #####:  697:      double up = down*md[ispec].gstat[part.lcu[ti]]/md[ispec].gstat[part.lcl[ti]]\
    #####:  698:                *exp(-HCKB*(md[ispec].eterm[part.lcu[ti]]-md[ispec].eterm[part.lcl[ti]])/tkin[ipart]);
        -:  699:
    #####:  700:      p[part.lcu[ti] * NEQ + part.lcl[ti]] = p[part.lcu[ti] * NEQ + part.lcl[ti]] + down*dens[ipart];
    #####:  701:      p[part.lcl[ti] * NEQ + part.lcu[ti]] = p[part.lcl[ti] * NEQ + part.lcu[ti]] + up*dens[ipart];
        -:  702:  }
        -:  703:
        -:  704:  }
        -:  705:  
        -:  706:  /*GENERATE ELECTRON COLLISIONAL RATES AND ADD TO MATRIX*/
        -:  707:  //Presently, only electrons produced from collision parter 0 are considered.
        -:  708:  //It would be easy enough to add others, but the partner production rates would be needed as an input
        -:  709:  //parameter, like par->Qpartner, and their temperatures can be given as tkin[n] from temperature()
        -:  710:  
        -:  711:  
    #####:  712:  if (par->useCKCdata == 1 || par->useCKCdata == 2) {
branch  0 never executed
branch  1 never executed
        -:  713:		/* Interpolating from the CKC code */
    #####:  714:		Te = get_Telec (CKCdata, par->Qwater, par->rHelio, radius);
call    0 never executed
    #####:  715:		ne = get_nelec (CKCdata, par->Qwater, par->rHelio, radius);
call    0 never executed
        -:  716:		//Below is for debugging only
        -:  717:		FILE *fPtr; 
        -:  718:		char *filePath = "output/elec_data.txt";
    #####:  719:		fPtr = fopen(filePath, "a");
call    0 never executed
    #####:  720:		fprintf(fPtr, "%12.3e %12.3e %12.3e\n", radius, Te, ne);
call    0 never executed
    #####:  721:		fclose(fPtr);
call    0 never executed
        -:  722:	}
        -:  723:	else {
        -:  724:		/*Formalism of Zakharov et al. (2007)*/
    #####:  725:	   Te = Telec(radius,par->Qwater,tkin[0]);
call    0 never executed
    #####:  726:	   ne = nelec(radius,par->Qwater,vexp,Te,par->rHelio,par->xne);
call    0 never executed
        -:  727:	}
        -:  728:	
        -:  729:
        -:  730:   
    #####:  731:   for(iline=0;iline<md[ispec].nline;iline++){
branch  0 never executed
branch  1 never executed
    #####:  732:     aij = HPLANCK*md[ispec].freq[iline]/2./KBOLTZ/Te;
    #####:  733:     sigmaij = ELEC_MASS*pow(ELEC_CHARGE,2)*pow(CLIGHT,3)*md[ispec].aeinst[iline]/16./pow(PI,2)/EPS_0/pow(HPLANCK,2)/pow(md[ispec].freq[iline],4);
    #####:  734:     ve = sqrt(8.*KBOLTZ*Te/PI/ELEC_MASS);
    #####:  735:     bessel = gsl_sf_bessel_K0(aij);
call    0 never executed
    #####:  736:     ceij = ne*ve*sigmaij*2.*aij*exp(aij)*bessel;
    #####:  737:     gij = md[ispec].gstat[md[ispec].lau[iline]]/md[ispec].gstat[md[ispec].lal[iline]];
    #####:  738:     ceji = ne*ve*gij*sigmaij*2.*aij*exp(-aij)*bessel;
        -:  739:
    #####:  740:     p[md[ispec].lau[iline] * NEQ + md[ispec].lal[iline]] = p[md[ispec].lau[iline] * NEQ + md[ispec].lal[iline]] + ceij;
    #####:  741:     p[md[ispec].lal[iline] * NEQ + md[ispec].lau[iline]] = p[md[ispec].lal[iline] * NEQ + md[ispec].lau[iline]] + ceji;
        -:  742:
        -:  743:   }
        -:  744:
        -:  745:   /* Add the pumping rates to the matrix */
    #####:  746:   if(par->girdatfile!=NULL){
branch  0 never executed
branch  1 never executed
    #####:  747:      for(k=0;k<md[ispec].nlev;k++){
branch  0 never executed
branch  1 never executed
    #####:  748:        for(l=0;l<md[ispec].nlev;l++){
branch  0 never executed
branch  1 never executed
    #####:  749:          if(k!=l){
branch  0 never executed
branch  1 never executed
    #####:  750:            p[l * NEQ + k] = p[l * NEQ + k] + md[ispec].gir[l*md[ispec].nlev+k];
        -:  751:          }
        -:  752:        }
        -:  753:      }  
        -:  754:   }
        -:  755:
        -:  756: 
        -:  757:   //Radiation trapping using the Escape Probaility method
    #####:  758:   if(par->useEP){ 
branch  0 never executed
branch  1 never executed
        -:  759:
    #####:  760:   molNumDensity(radius,0.0,0.0, molDens); 
call    0 never executed
    #####:  761:    for(li=0;li<md[ispec].nline;li++){
branch  0 never executed
branch  1 never executed
    #####:  762:      upper=md[ispec].lau[li];
    #####:  763:      lower=md[ispec].lal[li];
        -:  764:
        -:  765:      //Calculating the optical depth
    #####:  766:      tau = ((A[li]*pow(CLIGHT,3))/(8*PI*pow(md[ispec].freq[li],3))) * ((md[ispec].gstat[upper]/md[ispec].gstat[lower])*Pops[lower] - Pops[upper]) * ((molDens[ispec]* radius)/vexp);
        -:  767:
        -:  768:      //If the optical depth is small, ignore it
    #####:  769:      if (tau > -1.0e-6 && tau < 1.0e-6){
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  770:        beta = 1.0;
    #####:  771:      }else if (tau>0.0) {
branch  0 never executed
branch  1 never executed
    #####:  772:        beta = (2/(3*tau)) - exp(-tau/2)*(tau*(gsl_sf_bessel_Kn(2,tau/2)-gsl_sf_bessel_K1(tau/2))/3 -  gsl_sf_bessel_K1(tau/2)); 
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  773:      }else if (tau<0.0){ 
branch  0 never executed
branch  1 never executed
    #####:  774:        beta = (1 - exp(-tau)) / tau;
        -:  775:      }    
        -:  776:        
    #####:  777:      p[upper * NEQ + lower] = p[upper * NEQ + lower] + A[li]*beta;
        -:  778:
        -:  779:    }//end for
        -:  780:  }else{
        -:  781:     
    #####:  782:     for(li=0;li<md[ispec].nline;li++){
branch  0 never executed
branch  1 never executed
    #####:  783:        upper=md[ispec].lau[li];
    #####:  784:        lower=md[ispec].lal[li];
    #####:  785:        p[upper * NEQ + lower] = p[upper * NEQ + lower] + A[li];
        -:  786:     }
        -:  787:  }
    #####:  788:}
        -:  789:
        -:  790:/*....................................................................*/
function lteOnePoint called 500 returned 100% blocks executed 100%
      500:  791:void lteOnePoint(molData *md, const int ispec, const double temp, double *pops){
        -:  792:  int ilev;
        -:  793:  double sum;
        -:  794:
        -:  795:  sum = 0.0;
    13500:  796:  for(ilev=0;ilev<md[ispec].nlev;ilev++){
branch  0 taken 96%
branch  1 taken 4% (fallthrough)
    13000:  797:    pops[ilev] = md[ispec].gstat[ilev]*exp(-HCKB*md[ispec].eterm[ilev]/temp);
    13000:  798:    sum += pops[ilev];
        -:  799:  }
    13500:  800:  for(ilev=0;ilev<md[ispec].nlev;ilev++)
branch  0 taken 96%
branch  1 taken 4% (fallthrough)
    13000:  801:    pops[ilev] /= sum;
      500:  802:}
        -:  803:
        -:  804:/*....................................................................*/
        -:  805:void
function LTE called 1 returned 100% blocks executed 100%
        1:  806:LTE(configInfo *par, struct grid *gp, molData *md){
        -:  807:  int id,ispec;
        -:  808:
      501:  809:  for(id=0;id<par->pIntensity;id++){
branch  0 taken 100% (fallthrough)
branch  1 taken 1%
     1000:  810:    for(ispec=0;ispec<par->nSpecies;ispec++){
branch  0 taken 50%
branch  1 taken 50% (fallthrough)
      500:  811:      lteOnePoint(md, ispec, gp[id].t[0], gp[id].mol[ispec].pops);
call    0 returned 100%
        -:  812:    }
        -:  813:  }
        1:  814:}
        -:  815:
        -:  816:
        -:  817:/*....................................................................*/
        -:  818:/* Sets the Differential Equation (Pdot) to be solved by CVode */
function f called 0 returned 0% blocks executed 0%
    #####:  819:int f(realtype radius, N_Vector P, N_Vector Pdot, void *data){
        -:  820:
        -:  821:  int i, j, NEQ, id;
        -:  822:  struct cvode_physdata *user_data = data;
    #####:  823:  NEQ = user_data -> array_size;
    #####:  824:  double *pij = user_data -> transition_rates;
    #####:  825:  double Pops_array[NEQ], vel[DIM], vexp;
        -:  826:
    #####:  827:  velocity(0.,0.,radius,vel);
call    0 never executed
    #####:  828:  vexp = sqrt(vel[0]*vel[0] + vel[1]*vel[1] + vel[2]*vel[2]);
        -:  829:
        -:  830:  //Pasing P values to Pops_array for readability
    #####:  831:  for(i=0; i < NEQ; ++i)
branch  0 never executed
branch  1 never executed
    #####:  832:    Pops_array[i] = Ith(P,i);
        -:  833:
    #####:  834:  getTransitionRates(user_data->md,user_data->ispec,user_data->gp,user_data->par, NEQ, user_data -> A_array, pij, radius, user_data->jbar_grid, Pops_array, user_data ->nMaserWarnings, vexp, &user_data -> CKCdata);
call    0 never executed
        -:  835:
        -:  836:  //Initializing Pdot (otherwise it stores previous values between calls to CVode)
    #####:  837:  for(i=0; i < NEQ; ++i)
branch  0 never executed
branch  1 never executed
    #####:  838:    Ith(Pdot,i) = 0.0;
        -:  839:
        -:  840:  //Setting Pdot
    #####:  841:  for(i=0; i < NEQ; ++i)
branch  0 never executed
branch  1 never executed
    #####:  842:    for(j=0; j < NEQ; ++j){
branch  0 never executed
branch  1 never executed
    #####:  843:      if(i != j) 
branch  0 never executed
branch  1 never executed
    #####:  844:        Ith(Pdot,i) = Ith(Pdot,i) + (Pops_array[j] * (pij[j* NEQ +i])) - (Pops_array[i] * pij[i * NEQ +j]);
        -:  845:    }
        -:  846:    
        -:  847:   // Multiply equations by 1/V to get dP/dr     
    #####:  848:   for(i=0; i < NEQ; ++i){
branch  0 never executed
branch  1 never executed
    #####:  849:      Ith(Pdot,i) = Ith(Pdot,i) / vexp;
        -:  850:    //  Prind the Pdots for debugging
        -:  851:    //  printf("%d %le\n",i,  Ith(Pdot,i));
        -:  852:   }
        -:  853:   
    #####:  854:  return(0);
        -:  855:}
        -:  856:
function reduceTol called 0 returned 0% blocks executed 0%
    #####:  857:void reduceTol(N_Vector abstol, realtype reltol, void *cvode_mem, double factor, int NEQ){
    #####:  858:   printf("INFO: Reducing RTOL and ATOL by 0.1 and restarting CVODE\n");
call    0 never executed
        -:  859:   int i, retval;
        -:  860:
    #####:  861:   for(i=0; i < NEQ; ++i){
branch  0 never executed
branch  1 never executed
    #####:  862:      Ith(abstol,i) = Ith(abstol,i) * factor;
        -:  863:  }
        -:  864:
    #####:  865:   reltol = reltol * factor;
        -:  866:   
    #####:  867:  retval = CVodeSVtolerances(cvode_mem, reltol, abstol);
call    0 never executed
    #####:  868:  if (check_retval(&retval, "CVodeSVtolerances", 1)) return;
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  869:
        -:  870:}
        -:  871:
        -:  872:/*....................................................................*/
        -:  873:void
function solveStatEq called 0 returned 0% blocks executed 0%
    #####:  874:solveStatEq(struct grid *gp, molData *md, const int ispec, configInfo *par\
        -:  875:  , struct blendInfo blends, int *nextMolWithBlend, gridPointData **mp\
    #####:  876:  , double **halfFirstDs, int *nMaserWarnings, double *radii, int *gp_sorter){
        -:  877:
        -:  878:  int id;
        -:  879:  realtype reltol, t;
        -:  880:  N_Vector P, abstol;
        -:  881:  SUNMatrix sunMatrix;
        -:  882:  SUNLinearSolver LS;
        -:  883:  void *cvode_mem;
        -:  884:  int i,j, cvodeErrs = 0;
        -:  885:  int retval,cvstatus;
        -:  886:
        -:  887:  /* Initializing parameters to be used by CVode */
    #####:  888:  int NEQ = md[ispec].nlev; // Number of Equations
    #####:  889:  double p[NEQ][NEQ]; //Collisional rates
    #####:  890:  double A[md[ispec].nline]; //Einstein As
    #####:  891:  double Pops[NEQ]; //Level Populations
        -:  892:  double logtstep,tout;
    #####:  893:  double timearr[par->pIntensity], sorted_timearr[par->pIntensity]; //times through which the solver will iterate (each one corresponds to a specific gridpoint)
        -:  894:
    #####:  895:  for(id=0;id<md[ispec].nline;id++)
branch  0 never executed
branch  1 never executed
    #####:  896:    A[id] = md[ispec].aeinst[id];
        -:  897:
    #####:  898:  double (*jbar_grid)[md[ispec].nline] = malloc(sizeof(double[par->pIntensity][md[ispec].nline]));
        -:  899:
        -:  900:  /*Initializing Pops */
    #####:  901:  for(i=0;i<md[ispec].nlev;i++)
branch  0 never executed
branch  1 never executed
    #####:  902:    Pops[i] = gp[gp_sorter[0]].mol[ispec].pops[i];
        -:  903:
        -:  904:  struct CKCdata CKCdata;
    #####:  905:	if (par->useCKCdata == 1) {
branch  0 never executed
branch  1 never executed
    #####:  906:		readCKCdata(&CKCdata);
call    0 never executed
        -:  907:	}
    #####:  908:	else if (par->useCKCdata == 2) {
branch  0 never executed
branch  1 never executed
    #####:  909:		readCKCfile(&CKCdata, par->CKCTeFile, par->CKCneFile, par->Qwater, par->rHelio);
call    0 never executed
        -:  910:	}
        -:  911:  
    #####:  912:  struct cvode_physdata user_data = {NEQ, A, *p, md,ispec,gp,par, *jbar_grid, nMaserWarnings, CKCdata}; 
        -:  913:
        -:  914:  P = abstol = NULL;
        -:  915:  sunMatrix = NULL;
        -:  916:  LS = NULL;
    #####:  917:  cvode_mem = NULL;
        -:  918:
        -:  919:  /* Create serial vector of length NEQ for I.C. and abstol */
    #####:  920:  P = N_VNew_Serial(NEQ);
call    0 never executed
    #####:  921:  if (check_retval((void *)P, "N_VNew_Serial", 0)) return;
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  922:  abstol = N_VNew_Serial(NEQ); 
call    0 never executed
    #####:  923:  if (check_retval((void *)abstol, "N_VNew_Serial", 0)) return;
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  924:
        -:  925:  /* Set the scalar relative tolerance */
        -:  926:  reltol = RTOL;
        -:  927:
        -:  928:  /* Set the initial population values and the tolerances*/
    #####:  929:  for(i=0; i < NEQ; ++i){
branch  0 never executed
branch  1 never executed
    #####:  930:    Ith(P,i) = Pops[i];
    #####:  931:    Ith(abstol,i) = ATOL;
        -:  932:  }
        -:  933:  
        -:  934:
        -:  935:  /* Call CVodeCreate to create the solver memory and specify the 
        -:  936:  * Backward Differentiation Formula */
    #####:  937:  cvode_mem = CVodeCreate(CV_BDF);
call    0 never executed
    #####:  938:  if (check_retval((void *)cvode_mem, "CVodeCreate", 0)) return;
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  939:
        -:  940:  /* Call CVodeInit to initialize the integrator memory and specify the
        -:  941:   * user's right hand side function in y'=f(t,y), the inital time T0, and
        -:  942:   * the initial dependent variable vector y. */
    #####:  943:  retval = CVodeInit(cvode_mem, f,  radii[0], P);
call    0 never executed
    #####:  944:  if (check_retval(&retval, "CVodeInit", 1)) return;
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  945:
    #####:  946:  retval = CVodeSetUserData(cvode_mem, &user_data);
call    0 never executed
    #####:  947:  if (check_retval(&retval, "CVodeSetUserData", 0)) return;
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  948:
        -:  949:  /* Call CVodeSVtolerances to specify the scalar relative tolerance
        -:  950:   * and vector absolute tolerances */
    #####:  951:  retval = CVodeSVtolerances(cvode_mem, reltol, abstol);
call    0 never executed
    #####:  952:  if (check_retval(&retval, "CVodeSVtolerances", 1)) return;
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  953:
    #####:  954:  retval = CVodeSetMaxNumSteps(cvode_mem, 5000);
call    0 never executed
    #####:  955:    if (check_retval(&retval, "CVodeSetMaxNumSteps", 1)) return;
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  956:
        -:  957:  /* Create dense SUNMatrix for use in linear solves */
    #####:  958:  sunMatrix = SUNDenseMatrix(NEQ, NEQ);
call    0 never executed
    #####:  959:  if(check_retval((void *)sunMatrix, "SUNDenseMatrix", 0)) return;
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  960:
        -:  961:  /* Create dense SUNLinearSolver object for use by CVode */
    #####:  962:  LS = SUNLinSol_Dense(P, sunMatrix);
call    0 never executed
    #####:  963:  if(check_retval((void *)LS, "SUNLinSol_Dense", 0)) return;
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  964:
        -:  965:  /* Call CVodeSetLinearSolver to attach the matrix and linear solver to CVode */
    #####:  966:  retval = CVodeSetLinearSolver(cvode_mem, LS, sunMatrix);
call    0 never executed
    #####:  967:  if(check_retval(&retval, "CVodeSetLinearSolver", 1)) return;
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  968:
        -:  969:  /* Set the user-supplied Jacobian routine Jac */
        -:  970:  //retval = CVodeSetJacFn(cvode_mem, Jac);
        -:  971:  //if(check_retval(&retval, "CVodeSetJacFn", 1)) return;
        -:  972:
        -:  973:  /* Use a difference quotient Jacobian */
    #####:  974:  retval = CVodeSetJacFn(cvode_mem, NULL);
call    0 never executed
    #####:  975:  if(check_retval(&retval, "CVodeSetJacFn", 1)) return;
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  976:
    #####:  977:  printf("Starting CVODE time-dependent solver...\n");
call    0 never executed
    #####:  978:  fflush(stdout);
call    0 never executed
        -:  979:
        -:  980:  // Call CVODE for each radius
        -:  981:  // Do/while loop to catch CVODE error test failure status
        -:  982:  do{
    #####:  983:     for(i=1; i<par->pIntensity; i++){
branch  0 never executed
branch  1 never executed
    #####:  984:         cvstatus = CVode(cvode_mem, radii[i], P, &t, CV_NORMAL);
call    0 never executed
        -:  985:        
    #####:  986:       if(cvstatus == CV_SUCCESS){
branch  0 never executed
branch  1 never executed
    #####:  987:         for(j=0;j<md[ispec].nlev;j++){ 
branch  0 never executed
branch  1 never executed
    #####:  988:           gp[gp_sorter[i]].mol[ispec].pops[j]= Ith(P,j); 
        -:  989:         }
        -:  990:       }
        -:  991:      
    #####:  992:      if(cvstatus==-3 && reltol > MINTOL){ // Reduce the tolerances and try again
branch  0 never executed
branch  1 never executed
    #####:  993:         retval = CVodeInit(cvode_mem, f,  radii[0], P);
call    0 never executed
    #####:  994:         if (check_retval(&retval, "CVodeInit", 1)) printf("Failed to reinitialize CVODE\n");
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
    #####:  995:         CVodeSetUserData(cvode_mem, &user_data);
call    0 never executed
    #####:  996:         CVodeSetMaxNumSteps(cvode_mem, 5000);
call    0 never executed
    #####:  997:         sunMatrix = SUNDenseMatrix(NEQ, NEQ);
call    0 never executed
    #####:  998:         LS = SUNLinSol_Dense(P, sunMatrix);
call    0 never executed
    #####:  999:         CVodeSetLinearSolver(cvode_mem, LS, sunMatrix);
call    0 never executed
    #####: 1000:         CVodeSetJacFn(cvode_mem, NULL);
call    0 never executed
    #####: 1001:         reduceTol(abstol, reltol, cvode_mem, 0.1, NEQ);
call    0 never executed
        -: 1002:         tout=par->minScale;
    #####: 1003:         break;
    #####: 1004:      }else if(cvstatus!=0){
branch  0 never executed
branch  1 never executed
    #####: 1005:      cvodeErrs++;
    #####: 1006:      printf("CVODE error %d (continuing to next timestep - check populations!!)\n",cvstatus);
call    0 never executed
        -: 1007:      }
        -: 1008:    //Next CVODE step
    #####: 1009:      if(cvodeErrs>=15){ 
branch  0 never executed
branch  1 never executed
    #####: 1010:         bail_out("CVODE solver failure - check physical model and tolerances.");
call    0 never executed
    #####: 1011:         exit(1);
call    0 never executed
        -: 1012:      }
        -: 1013:    }
    #####: 1014:  }while(cvstatus==-3) ;
branch  0 never executed
branch  1 never executed
        -: 1015:  
        -: 1016:  /* Free P and abstol vectors */
    #####: 1017:  N_VDestroy(P);
call    0 never executed
    #####: 1018:  N_VDestroy(abstol);
call    0 never executed
        -: 1019:
        -: 1020:  /* Free integrator memory */
    #####: 1021:  CVodeFree(&cvode_mem);
call    0 never executed
        -: 1022:
        -: 1023:  /* Free the linear solver memory */
    #####: 1024:  SUNLinSolFree(LS);
call    0 never executed
        -: 1025:
        -: 1026:  /* Free the matrix memory */
    #####: 1027:  SUNMatDestroy(sunMatrix);
call    0 never executed
        -: 1028:  
    #####: 1029:  free(jbar_grid);
        -: 1030:  
        -: 1031:  /* Free CKCdata in memory */
    #####: 1032:  if (par->useCKCdata == 1 || par->useCKCdata == 2) {
branch  0 never executed
branch  1 never executed
    #####: 1033:  	free(CKCdata.Tedata);
    #####: 1034:  	free(CKCdata.nedata);
    #####: 1035:  	free(CKCdata.r_values);
        -: 1036:	}
        -: 1037:  
        -: 1038:}
        -: 1039:
        -: 1040:
        -: 1041:/*....................................................................*/
        -: 1042:int
function levelPops called 1 returned 100% blocks executed 12%
        1: 1043:levelPops(molData *md, configInfo *par, struct grid *gp, int *popsdone, double *lamtab, double *kaptab, const int nEntries, double *radii, int *gp_sorter){
        -: 1044:
        -: 1045:  int id,ispec,i,nVerticesDone,nItersDone,nlinetot;
        -: 1046:  int totalNMaserWarnings=0;
        1: 1047:  const gsl_rng_type *ranNumGenType = gsl_rng_ranlxs2;
        -: 1048:  struct blendInfo blends;
        -: 1049:  char message[STR_LEN_0];
        1: 1050:  int RNG_seeds[par->nThreads];
        -: 1051:  gsl_error_handler_t *defaultErrorHandler=NULL;
        1: 1052:  int nextMolWithBlend[par->pIntensity],nMaserWarnings[par->pIntensity];
      501: 1053:  for(id=0;id<par->pIntensity;id++){
branch  0 taken 100%
branch  1 taken 1% (fallthrough)
      500: 1054:    nMaserWarnings[id] = 0;
        -: 1055:  }
        -: 1056:
        -: 1057:  nlinetot = 0;
        -: 1058:  for(ispec=0;ispec<par->nSpecies;ispec++)
        -: 1059:    nlinetot += md[ispec].nline;
        -: 1060:
        1: 1061:  if(par->lte_only){
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        1: 1062:    LTE(par,gp,md);
call    0 returned 100%
        1: 1063:    if(par->outputfile) popsout(par,gp,md);
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
        -: 1064:  }
        -: 1065:
        -: 1066:   /* Non-LTE */
    #####: 1067:  else{
        -: 1068:
        -: 1069:    /* Random number generator */
    #####: 1070:    gsl_rng *ran = gsl_rng_alloc(ranNumGenType);
call    0 never executed
    #####: 1071:    if(fixRandomSeeds)
branch  0 never executed
branch  1 never executed
    #####: 1072:      gsl_rng_set(ran, 1237106) ;
call    0 never executed
        -: 1073:    else 
    #####: 1074:      gsl_rng_set(ran,time(0));
call    0 never executed
call    1 never executed
        -: 1075:
        -: 1076:    gsl_rng **threadRans;
    #####: 1077:    threadRans = malloc(sizeof(gsl_rng *)*par->pIntensity);
        -: 1078:
    #####: 1079:    for (i=0;i<par->pIntensity;i++){
branch  0 never executed
branch  1 never executed
    #####: 1080:      threadRans[i] = gsl_rng_alloc(ranNumGenType);
call    0 never executed
    #####: 1081:      if (par->resetRNG==1) RNG_seeds[i] = (int)(gsl_rng_uniform(ran)*1e6);
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####: 1082:      else gsl_rng_set(threadRans[i],(int)(gsl_rng_uniform(ran)*1e6));
call    0 never executed
call    1 never executed
        -: 1083:    }
        -: 1084:
    #####: 1085:   freeGridCont(par, gp);
call    0 never executed
    #####: 1086:   mallocGridCont(par, md, gp);
call    0 never executed
    #####: 1087:   calcGridLinesDustOpacity(par, md, lamtab, kaptab, nEntries, gp);
call    0 never executed
        -: 1088:
        -: 1089:   /* Initialize populations with Boltzmann distribution (assuming LTE) */
    #####: 1090:   LTE(par,gp,md);
call    0 never executed
        -: 1091:
    #####: 1092:   defaultErrorHandler = gsl_set_error_handler_off();
call    0 never executed
        -: 1093:
        -: 1094:
    #####: 1095:  gridPointData *mp[par->pIntensity];
    #####: 1096:  double *halfFirstDs[par->pIntensity];
        -: 1097:
    #####: 1098:  calcGridMolSpecNumDens(par,md,gp);
call    0 never executed
        -: 1099:  totalNMaserWarnings = 0;
        -: 1100:  nVerticesDone=0;
        -: 1101:
        -: 1102:  //TODO: This for loop could be parallelized
    #####: 1103:  for(id=0;id<par->pIntensity;id++){
branch  0 never executed
branch  1 never executed
    #####: 1104:    ++nVerticesDone;
    #####: 1105:    nMaserWarnings[id]=0;
    #####: 1106:    nextMolWithBlend[id] = 0;
    #####: 1107:    mp[id]=malloc(sizeof(gridPointData)*par->nSpecies);
    #####: 1108:    halfFirstDs[id] = malloc(sizeof(*halfFirstDs)*gp[id].nphot);
        -: 1109:
    #####: 1110:    for (ispec=0;ispec<par->nSpecies;ispec++){
branch  0 never executed
branch  1 never executed
    #####: 1111:      mp[id][ispec].jbar = malloc(sizeof(double)*md[ispec].nline);
    #####: 1112:      mp[id][ispec].phot = malloc(sizeof(double)*md[ispec].nline*gp[id].nphot);
    #####: 1113:      mp[id][ispec].vfac = malloc(sizeof(double)*                gp[id].nphot);
    #####: 1114:      mp[id][ispec].vfac_loc = malloc(sizeof(double)*            gp[id].nphot);
        -: 1115:    }
    #####: 1116:    if(gp[id].dens[0] < 0 && gp[id].t[0] < 0){
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1117:      printf("\nError on grid point = %d\n, aborting", id);
call    0 never executed
    #####: 1118:      exit(1);
call    0 never executed
        -: 1119:    }
        -: 1120:
        -: 1121:  }
        -: 1122:  
    #####: 1123:  for(ispec=0;ispec<par->nSpecies;ispec++){
branch  0 never executed
branch  1 never executed
    #####: 1124:    solveStatEq(gp,md,ispec,par,blends,nextMolWithBlend,mp,halfFirstDs, nMaserWarnings, radii, gp_sorter); 
call    0 never executed
    #####: 1125:    for(i=0;i<par->pIntensity;i++)
branch  0 never executed
branch  1 never executed
    #####: 1126:      if(par->blend && blends.mols!=NULL && ispec==blends.mols[nextMolWithBlend[i]].molI)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####: 1127:        nextMolWithBlend[i] = nextMolWithBlend[i] + 1;
        -: 1128:  }
        -: 1129:
    #####: 1130:  for(id=0;id<par->pIntensity;id++){
branch  0 never executed
branch  1 never executed
    #####: 1131:    totalNMaserWarnings = nMaserWarnings[id];
        -: 1132:  }
        -: 1133:
    #####: 1134:  if(!silent && totalNMaserWarnings>0){
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1135:    snprintf(message, STR_LEN_0, "Maser warning: optical depth dropped below -%4.1f %d times this iteration.", MAX_NEG_OPT_DEPTH, totalNMaserWarnings);
    #####: 1136:    warning(message);
call    0 never executed
        -: 1137:  }
        -: 1138:
    #####: 1139:  if(!silent) warning("");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####: 1140:  for (i=0;i<par->pIntensity;i++){
branch  0 never executed
branch  1 never executed
    #####: 1141:    freeGridPointData(par->nSpecies, mp[i]);
call    0 never executed
    #####: 1142:    free(halfFirstDs[i]);
        -: 1143:  }
    #####: 1144:  if(par->outputfile != NULL) popsout(par,gp,md);
branch  0 never executed
branch  1 never executed
call    2 never executed
        -: 1145:
    #####: 1146:  freeMolsWithBlends(blends.mols, blends.numMolsWithBlends);
call    0 never executed
    #####: 1147:  freeGridCont(par, gp);
call    0 never executed
    #####: 1148:  for (i=0;i<par->pIntensity;i++)
branch  0 never executed
branch  1 never executed
    #####: 1149:    gsl_rng_free(threadRans[i]);
call    0 never executed
    #####: 1150:  free(threadRans);
    #####: 1151:  gsl_rng_free(ran);
call    0 never executed
        -: 1152: }//end else
        -: 1153:
        1: 1154:  par->dataFlags |= (1 << DS_bit_populations);
        -: 1155:
       1*: 1156:  if(par->binoutputfile != NULL) binpopsout(par,gp,md);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
        -: 1157:
        1: 1158:  *popsdone=1;
        -: 1159:
        1: 1160:  return (1);
        -: 1161:}
