        -:    0:Source:src/collparts.c
        -:    0:Graph:src/collparts.gcno
        -:    0:Data:src/collparts.gcda
        -:    0:Runs:1
        -:    1:/*
        -:    2: *  collparts.c
        -:    3: *  This file is part of LIME, the versatile line modeling engine
        -:    4: *
        -:    5: *  Copyright (C) 2006-2014 Christian Brinch
        -:    6: *  Copyright (C) 2015-2017 The LIME development team
        -:    7: *
        -:    8:TODO:
        -:    9:
        -:   10:Some explanation:
        -:   11:=================
        -:   12:We have three sources of information about the density and type of bulk gas (a.k.a. collision partner) species: (i) the number of elements returned by the density() function; (ii) the list par->collPartIds; (iii) and the transition rate values supplied in the moldatfiles. What we want to do is associate density functions with collision partners given in the moldatfiles. We would like to do this if possible without deviating from the original assumptions made in the earliest versions of LIME, and without loading the user down with too much crud.
        -:   13:
        -:   14:Below is given a typical timeline of processing within LIME, showing for each stage the questions which the code asks about par->collPartIds and the moldatfiles, and the decisions taken in response.
        -:   15:
        -:   16:main.initParImg():
        -:   17:------------------
        -:   18:
        -:   19:  - inpars->collPartIds (i.e. a struct of type 'inputPars') is malloc'd to size MAX_N_COLL_PART and all the entries are set to 0. Zero does not correspond with any LAMDA species and can therefore be used to flag that the user has not reset the value to something sensible.
        -:   20:
        -:   21:User's model file:
        -:   22:------------------
        -:   23:
        -:   24:  - (optionally) some enties of inpars->collPartIds are set to >0 values.
        -:   25:
        -:   26:run.parseInput():
        -:   27:-----------------
        -:   28:
        -:   29:  par->collPartIds (a struct of type 'configInfo') is malloc'd to size MAX_N_COLL_PART and the inpars values are copied over.
        -:   30:
        -:   31:collparts.checkUserDensWeights():
        -:   32:---------------------------------
        -:   33:
        -:   34:  - The number of >0 (therefore user-set) values of par->collPartIds are counted. Counting starts from the 0th element and stops as soon as the first <=0 value is found.
        -:   35:
        -:   36:  - The number of user-set values of par->collPartIds is compared to the number of density() function returns (by now stored in par->numDensities). If the numbers are unequal, par->collPartIds is freed and set to NULL (a warning is issued if the user set some values). If the numbers match, par->collPartIds is reallocated in size to that number (this is possibly unnecessary).
        -:   37:
        -:   38:  - If the user has supplied par->collPartNames, with the number of entries correctly matching the number of density() returns (par->numDensities), in the case that par->collPartIds was set to NULL just above, then par->collPartIds is malloc'd to size par->numDensities; it is loaded then with an increasing sequence of integers.
        -:   39:
        -:   40:  - par->collPartIds, if set, are checked for uniqueness.
        -:   41:
        -:   42:molinit.readMolData():
        -:   43:----------------------
        -:   44:
        -:   45:  - The collision partners listed in the set of moldatfiles are read from file. Here we first want to compile a list of unique (that is, without repetition) collision partners that occur in the files. We will only do this however if either (i) the user has supplied no values of par->collPartIds or (ii) the collision partner matches one supplied in par->collPartIds.
        -:   46:
        -:   47:  - Note that ALL collision partners read from the ith file are stored in md[i].part.
        -:   48:
        -:   49:collparts.setUpDensityAux():
        -:   50:----------------------------
        -:   51:
        -:   52:  - The processing in this looks quite complicated, but the only thing that is done to par->collPartIds is if it ==NULL: it is then malloc'd to size par->numDensities and, under limited circumstances, its values are set to those read from the moldatfiles.
        -:   53:
        -:   54:molinit.assignMolCollPartsToDensities():
        -:   55:----------------------------------------
        -:   56:
        -:   57:  - par->collPartIds is compared here to the collision partner IDs in md[i].part[ipart].collPartId. If a CP is found in par->collPartIds but not in md[i].part, no action is taken. If any md[i].part[ipart].collPartId is not found in par->collPartIds, md[i].part[ipart].densityIndex is set to -1. This flags to solver.getFixedMatrix() to ignore the respective transition rates.
        -:   58:
        -:   59: */
        -:   60:
        -:   61:#include "lime.h"
        -:   62:
        -:   63:/*....................................................................*/
function setCollPartsDefaults called 1 returned 100% blocks executed 100%
        1:   64:void setCollPartsDefaults(struct cpData *part){
        1:   65:  (*part).collPartId = -1;
        1:   66:  (*part).densityIndex = -1; /* Signals that there is no density function for this CP. */
        1:   67:  (*part).name = NULL; /* If it turns out to have a matching density function we will store the name. */
        1:   68:  (*part).ntemp  = -1;
        1:   69:  (*part).ntrans = -1;
        1:   70:  (*part).down  = NULL;
        1:   71:  (*part).temp  = NULL;
        1:   72:  (*part).lcl   = NULL;
        1:   73:  (*part).lcu   = NULL;
        1:   74:}
        -:   75:
        -:   76:/*....................................................................*/
function checkUserDensWeights called 1 returned 100% blocks executed 55%
        1:   77:void checkUserDensWeights(configInfo *par){
        -:   78:  /*
        -:   79:This deals with four user-settable list parameters which relate to collision partners and their number densities: par->collPartIds, par->nMolWeights, par->collPartMolWeights and par->collPartNames. We have to see if these (optional) parameters were set, do some basic checks on them, and if they were set make sure they match the number of density values, which by this time should be stored in par->numDensities.
        -:   80:
        -:   81:	* par->collPartIds: this list acts as a link between the N density function returns (I'm using here N as shorthand for par->numDensities) and the M collision partner ID integers found in the moldatfiles. This allows us to associate density functions with the collision partner transition rates provided in the moldatfiles.
        -:   82:
        -:   83:	* par->collPartNames: essentially this has only cosmetic importance since it has no effect on the functioning of LIME, only on the names of the collision partners which are printed to stdout. Its main purpose is to reassure the user who has provided transition rates for a non-LAMDA collision species in their moldatfile that they are actually getting these values and not some mysterious reversion to LAMDA.
        -:   84:
        -:   85:	The user can specify either, none, or both of these two parameters, with the following effects:
        -:   86:
        -:   87:		Ids	Names	Effect
        -:   88:		----------------------
        -:   89:		0	0	LAMDA collision partners are assumed and the association between the density functions and the moldatfiles is essentially guessed.
        -:   90:
        -:   91:		0	1	par->collPartIds is constructed to contain integers in a sequence from 1 to N. Naturally the user should write matching collision partner ID integers in their moldatfiles.
        -:   92:
        -:   93:		1	0	LAMDA collision partners are assumed.
        -:   94:
        -:   95:		1	1	User will get what they ask for.
        -:   96:		----------------------
        -:   97:
        -:   98:	* par->collPartMolWeights: this MUST be present if par->collPartNames has been supplied, and it MUST then have the same number and order of elements as all the other collision-partner lists. If this parameter is supplied but par->collPartNames not, it will be ignored.
        -:   99:
        -:  100:	* par->nMolWeights: this list gives the weights to be applied to the N density values when calculating molecular densities from abundances.
        -:  101:  */
        -:  102:  int i,j,numUserSetCPIds,numUserSetNMWs,numUserSetCPNames,numUserSetCPWeights;
        -:  103:  int *uniqueCPIds=NULL;
        -:  104:  double sum;
        -:  105:
        1:  106:  par->collPartUserSetFlags = 0;
        -:  107:
        -:  108:  /* . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .*/
        -:  109:  /* Get the numbers of elements set by the user for each of the 4 parameters:
        -:  110:  */
        -:  111:  i = 0;
        2:  112:  while(i<MAX_N_COLL_PART && par->collPartIds[i]>0) i++;
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 50%
branch  3 taken 50% (fallthrough)
        -:  113:  numUserSetCPIds = i;
        1:  114:  if(i>0) par->collPartUserSetFlags |= (1<<CPF_BIT_ids);
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  115:
        -:  116:  i = 0;
        2:  117:  while(i<MAX_N_COLL_PART && par->nMolWeights[i]>=0.0) i++;
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 50%
branch  3 taken 50% (fallthrough)
        -:  118:  numUserSetNMWs = i;
        1:  119:  if(i>0) par->collPartUserSetFlags |= (1<<CPF_BIT_weights);
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  120:
        -:  121:  i = 0;
       1*:  122:  while(i<MAX_N_COLL_PART && par->collPartNames[i]!=NULL) i++;
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 0%
branch  3 taken 100% (fallthrough)
        -:  123:  numUserSetCPNames = i;
       1*:  124:  if(i>0) par->collPartUserSetFlags |= (1<<CPF_BIT_names);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  125:
        -:  126:  i = 0;
       1*:  127:  while(i<MAX_N_COLL_PART && par->collPartMolWeights[i]>=0) i++;
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 0%
branch  3 taken 100% (fallthrough)
        -:  128:  numUserSetCPWeights = i;
       1*:  129:  if(i>0) par->collPartUserSetFlags |= (1<<CPF_BIT_MolWeights);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  130:
        -:  131:  /* . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .*/
        -:  132:  /* Perform checks on the numbers.
        -:  133:  */
        -:  134:  /* Check that we have either 0 par->collPartIds or the same number as the number of density values. If not, the par->collPartIds values the user set will be thrown away, the pointer will be reallocated, and new values will be written to it in setUpDensityAux(), taken from the values in the moldatfiles.
        -:  135:  */
        1:  136:  if(numUserSetCPIds != par->numDensities){
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  137:    free(par->collPartIds);
    #####:  138:    par->collPartIds = NULL;
        -:  139:    /* Note that in the present case we will (for a line-emission image) look for the collision partners listed in the moldatfiles and set par->collPartIds from them. For that to happen, we require the number of collision partners found in the files to equal par->numDensities. */
        -:  140:
        -:  141:    /* numUserSetCPIds==0 is ok, this just means the user has not set the parameter at all, but for other values we should issue some warnings, because if the user sets any at all, they should set the same number as there are returns from density():
        -:  142:    */
    #####:  143:    if(numUserSetCPIds > 0){
branch  0 never executed
branch  1 never executed
    #####:  144:      if(!silent) warning("par.collPartIds will be ignored - there should be 1 for each density.");
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  145:      numUserSetCPIds = 0;
        -:  146:    }
        -:  147:
        -:  148:  }else{
        1:  149:    par->collPartIds = realloc(par->collPartIds, sizeof(*(par->collPartIds))*par->numDensities);
        -:  150:  }
        -:  151:
        -:  152:  /* Check if we have either 0 par->nMolWeights or the same number as the number of density values.
        -:  153:  */
        1:  154:  if(numUserSetNMWs != par->numDensities){
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  155:    free(par->nMolWeights);
    #####:  156:    par->nMolWeights = NULL;
        -:  157:    /* Note that in the present case we will (for a line-emission image) look for the collision partners listed in the moldatfiles and set par->nMolWeights from them. */
        -:  158:
        -:  159:    /* numUserSetNMWs==0 is ok, this just means the user has not set the parameter at all, but for other values we should issue some warnings, because if the user sets any at all, they should set the same number as there are returns from density():
        -:  160:    */
    #####:  161:    if(numUserSetNMWs > 0){
branch  0 never executed
branch  1 never executed
    #####:  162:      if(!silent) warning("par->nMolWeights will be ignored - there should be 1 for each density() return.");
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  163:      numUserSetNMWs = 0;
        -:  164:    }
        -:  165:
        -:  166:  }else{
        1:  167:    par->nMolWeights = realloc(par->nMolWeights, sizeof(*(par->nMolWeights))*par->numDensities);
        -:  168:  }
        -:  169:
        -:  170:  /* Re the interaction between par->collPartIds and par->collPartNames: the possible scenarios are given in the function header.
        -:  171:  */
        1:  172:  if(numUserSetCPNames != par->numDensities){
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
       21:  173:    for(i=0;i<MAX_N_COLL_PART;i++) free(par->collPartNames[i]);
branch  0 taken 95%
branch  1 taken 5% (fallthrough)
        1:  174:    free(par->collPartNames);
        1:  175:    par->collPartNames = NULL;
        -:  176:
        -:  177:    /* numUserSetCPNames==0 is ok, this just means the user has not set the parameter at all, but for other values we should issue some warnings, because if the user sets any at all, they should set the same number as there are returns from density():
        -:  178:    */
        1:  179:    if(numUserSetCPNames > 0){
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  180:      if(!silent) warning("par->collPartNames will be ignored - there should be 1 for each density() return.");
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  181:      numUserSetCPNames = 0;
        -:  182:    }
        -:  183:
        -:  184:  }else{ /* If we get to here, then numUserSetCPNames==par->numDensities. */
    #####:  185:    for(i=par->numDensities;i<MAX_N_COLL_PART;i++){
branch  0 never executed
branch  1 never executed
    #####:  186:      free(par->collPartNames[i]);
        -:  187:    }
    #####:  188:    par->collPartNames = realloc(par->collPartNames, sizeof(*(par->collPartNames))*par->numDensities);
        -:  189:
    #####:  190:    if(numUserSetCPIds<=0){ /* This implies that we must have set par->collPartIds=NULL a little above here. */
branch  0 never executed
branch  1 never executed
    #####:  191:      par->collPartIds = malloc(sizeof(*(par->collPartIds))*par->numDensities);
    #####:  192:      for(i=0;i<par->numDensities;i++)
branch  0 never executed
branch  1 never executed
    #####:  193:        par->collPartIds[i] = i+1;
        -:  194://**** Won't this go wrong when the collPartIds read from moldatfiles are compared to par->collPartIds in molinit.readMolData()??
        -:  195:      numUserSetCPIds = par->numDensities;
        -:  196:    }
        -:  197:  }
        -:  198:
        -:  199:  /* The constraints on the list of CP molecular weights are similar, but NULL + warn that they will be ignored if there are no CP names.
        -:  200:  */
       1*:  201:  if(numUserSetCPWeights != par->numDensities || numUserSetCPNames <= 0){
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
branch  2 never executed
branch  3 never executed
        1:  202:    free(par->collPartMolWeights);
        1:  203:    par->collPartMolWeights = NULL;
        -:  204:
        -:  205:    /* numUserSetCPWeights==0 is ok, this just means the user has not set the parameter at all, but for other values we should issue some warnings, because if the user sets any at all, they should set the same number as there are returns from density():
        -:  206:    */
        1:  207:    if(numUserSetCPWeights > 0){
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  208:      if(numUserSetCPNames <= 0){
branch  0 never executed
branch  1 never executed
    #####:  209:        if(!silent) warning("par->collPartMolWeights will be ignored - you must also set par->collPartNames.");
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  210:      }else{
    #####:  211:        if(!silent) warning("par->collPartMolWeights will be ignored - there should be 1 for each density() return.");
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  212:      }
        -:  213:      numUserSetCPWeights = 0;
        -:  214:    }
        -:  215:
        -:  216:  }else{
    #####:  217:    par->collPartMolWeights = realloc(par->collPartMolWeights, sizeof(*(par->collPartMolWeights))*par->numDensities);
        -:  218:  }
        -:  219:
        -:  220:  /* . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .*/
        -:  221:  /* Now we do some sanity checks.
        -:  222:  */
        1:  223:  if(numUserSetCPIds>0){
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  224:    /* Check that they are unique.
        -:  225:    */
        1:  226:    uniqueCPIds = malloc(sizeof(int)*numUserSetCPIds);
        2:  227:    for(i=0;i<numUserSetCPIds;i++){
branch  0 taken 50% (fallthrough)
branch  1 taken 50%
       1*:  228:      for(j=0;j<i;j++){
branch  0 taken 0%
branch  1 taken 100% (fallthrough)
    #####:  229:        if(par->collPartIds[i]==uniqueCPIds[j]){
branch  0 never executed
branch  1 never executed
    #####:  230:          if(!silent) bail_out("Your list of par.collPartIds is not unique.");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  231:          exit(1);
call    0 never executed
        -:  232:        }
        -:  233:      }
        1:  234:      uniqueCPIds[i] = par->collPartIds[i];
        -:  235:    }
        1:  236:    free(uniqueCPIds);
        -:  237:  }
        -:  238:
        1:  239:  if(numUserSetNMWs>0){
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  240:    /* Check that they do not sum to zero.
        -:  241:    */
        -:  242:    sum = 0.0;
        2:  243:    for(i=0;i<numUserSetNMWs;i++){
branch  0 taken 50%
branch  1 taken 50% (fallthrough)
        1:  244:      sum += par->nMolWeights[i];
        -:  245:    }
        1:  246:    if(sum<=0.0){
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  247:      if(!silent) bail_out("At least some of your par.nMolWeights must be non-zero!");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  248:      exit(1);
call    0 never executed
        -:  249:    }
        -:  250:  }
        1:  251:}
        -:  252:
        -:  253:/*....................................................................*/
function setUpDensityAux called 1 returned 100% blocks executed 13%
        1:  254:void setUpDensityAux(configInfo *par, int *allUniqueCollPartIds, const int numUniqueCollParts){
        -:  255:  /*
        -:  256:The present function, which needs to be called only if we have to calculate the energy level populations at the grid points, deals with the user-settable vectors par->collPartIds and par->nMolWeights. The former of these is used to associate density values with collision-partner species, and the latter is used in converting, for each radiating species, its abundance to a number density, stored respectively in the grid struct attributes abun and nmol. The function deals specifically with the case in which the user has either not set par->collPartIds or par->nMolWeights at all (which they may choose to do), or has set them incorrectly. In either case the respective parameter will have been freed and set to NULL in checkUserDensWeights(). The function tries its best to guess likely values for the parameters, in line with the algorithm used in the code before par->collPartIds and par->nMolWeights were introduced.
        -:  257:
        -:  258:allUniqueCollPartIds is the list of all unique CP ID integers detected in the supplied moldata files.
        -:  259:  */
        1:  260:  double lamdaMolWeights[] = {2.0159,2.0159,2.0159,5.486e-4,1.00794,4.0026,1.00739};
        1:  261:  char *lamdaNames[] = {"H2","p-H2","o-H2","electrons","H","He","H+"};
        -:  262:  char message[STR_LEN_0];
        -:  263:  int i;
        -:  264:
        1:  265:  if(par->collPartIds==NULL){ /* For this to happen means that the user set neither par->collPartIds nor par->collPartNames. */
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  266:    /*
        -:  267:To preserve backward compatibility I am going to try to make the same guesses as were made before par->collPartIds was introduced, but this is made tricky by the fact that the switch block in the previous code did not cover all possibilities. I'm going to add some warnings too. We want users to be able to run their old model.c files for as long as possible, but at the same time urge them to make use of the new facility for specifying par->collPartIds.
        -:  268:    */
    #####:  269:    if(par->numDensities > numUniqueCollParts){
branch  0 never executed
branch  1 never executed
    #####:  270:      if(!silent) bail_out("Too many density profiles defined.");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  271:      exit(1);
call    0 never executed
        -:  272:    }
        -:  273:
    #####:  274:    if(numUniqueCollParts==1){
branch  0 never executed
branch  1 never executed
    #####:  275:      if(allUniqueCollPartIds[0]==CP_H2 || allUniqueCollPartIds[0]==CP_p_H2 || allUniqueCollPartIds[0]==CP_o_H2){
branch  0 never executed
branch  1 never executed
    #####:  276:        par->collPartIds = malloc(sizeof(int)*par->numDensities); /* par->numDensities must ==1 at this point. */
    #####:  277:        par->collPartIds[0] = allUniqueCollPartIds[0];
        -:  278:      }else{
    #####:  279:        if(!silent) bail_out("No H2 collision partner, and user didn't set par.collPartIds.");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  280:        exit(1);
call    0 never executed
        -:  281:      }
        -:  282:
    #####:  283:    }else if(numUniqueCollParts==2){
branch  0 never executed
branch  1 never executed
    #####:  284:      if((allUniqueCollPartIds[0]==CP_p_H2 && allUniqueCollPartIds[1]==CP_o_H2)\
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  285:      || (allUniqueCollPartIds[1]==CP_p_H2 && allUniqueCollPartIds[0]==CP_o_H2)){
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  286:        par->collPartIds = malloc(sizeof(int)*par->numDensities);
    #####:  287:        for(i=0;i<par->numDensities;i++) /* At this point par->numDensities can be only ==1 (previously signalled via 'flag') or ==2. */
branch  0 never executed
branch  1 never executed
    #####:  288:          par->collPartIds[i] = allUniqueCollPartIds[i];
        -:  289:
    #####:  290:        if(par->numDensities==1 && !silent) warning("Calculating molecular density with respect to first collision partner only.");
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
        -:  291:
        -:  292:      }else{
    #####:  293:        if(!silent) bail_out("No H2 collision partners, and user didn't set par.collPartIds.");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  294:        exit(1);
call    0 never executed
        -:  295:      }
        -:  296:
    #####:  297:    }else if(numUniqueCollParts==par->numDensities){ /* At this point, numUniqueCollParts must be >2. */
branch  0 never executed
branch  1 never executed
    #####:  298:      par->collPartIds = malloc(sizeof(int)*par->numDensities);
    #####:  299:      for(i=0;i<par->numDensities;i++)
branch  0 never executed
branch  1 never executed
    #####:  300:        par->collPartIds[i] = allUniqueCollPartIds[i];
        -:  301:
    #####:  302:      if(!silent) warning("Calculating molecular density with respect to first two collision partners only.");
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  303://*** Huh? What if they both ==3? Don't think this warning here is valid.
        -:  304:
        -:  305:    }else{ /* numUniqueCollParts>2 && par->numDensities<numUniqueCollParts */
    #####:  306:      if(!silent) bail_out("More than 2 collision partners, but number of density returns doesn't match.");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  307:      exit(1);
call    0 never executed
        -:  308:    }
        -:  309:
    #####:  310:    if(!silent) {
branch  0 never executed
branch  1 never executed
        -:  311:#ifdef NO_NCURSES
    #####:  312:      printMessage("User didn't set par.collPartIds, I'm having to guess them. Guessed:");
call    0 never executed
    #####:  313:      for(i=0;i<par->numDensities;i++){
branch  0 never executed
branch  1 never executed
    #####:  314:        snprintf(message, STR_LEN_0, "  Collision partner %d assigned code %d (=%s)\n", i, par->collPartIds[i], lamdaNames[par->collPartIds[i]-1]);
    #####:  315:        printMessage(message);
call    0 never executed
        -:  316:      }
    #####:  317:      printMessage("\n");
call    0 never executed
        -:  318:#else
        -:  319:      printMessage("User didn't set par.collPartIds, I'm having to guess them.");
        -:  320:#endif
        -:  321:    }
        -:  322:
    #####:  323:    if(par->nMolWeights==NULL){
branch  0 never executed
branch  1 never executed
        -:  324:      /*
        -:  325:The same backward-compatible guesses are made here as for par->collPartIds in the foregoing section of code. I've omitted warnings and errors because they have already been issued during the treatment of par->collPartIds.
        -:  326:      */
    #####:  327:      if(numUniqueCollParts==1){
branch  0 never executed
branch  1 never executed
    #####:  328:        if(allUniqueCollPartIds[0]==CP_H2 || allUniqueCollPartIds[0]==CP_p_H2 || allUniqueCollPartIds[0]==CP_o_H2){
branch  0 never executed
branch  1 never executed
    #####:  329:          par->nMolWeights = malloc(sizeof(double)*par->numDensities);
    #####:  330:          par->nMolWeights[0] = 1.0;
        -:  331:        }
        -:  332:
    #####:  333:      }else if(numUniqueCollParts==2){
branch  0 never executed
branch  1 never executed
    #####:  334:        if((allUniqueCollPartIds[0]==CP_p_H2 && allUniqueCollPartIds[1]==CP_o_H2)\
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  335:        || (allUniqueCollPartIds[1]==CP_p_H2 && allUniqueCollPartIds[0]==CP_o_H2)){
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  336:          par->nMolWeights = malloc(sizeof(double)*par->numDensities);
    #####:  337:          for(i=0;i<par->numDensities;i++) /* At this point par->numDensities can be only ==1 (previously signalled via 'flag') or ==2. */
branch  0 never executed
branch  1 never executed
    #####:  338:            par->nMolWeights[i] = 1.0;
        -:  339:        }
        -:  340:
    #####:  341:      }else if(numUniqueCollParts==par->numDensities){ /* At this point, numUniqueCollParts must be >2. */
branch  0 never executed
branch  1 never executed
    #####:  342:        par->nMolWeights = malloc(sizeof(double)*par->numDensities);
    #####:  343:        for(i=0;i<par->numDensities;i++)
branch  0 never executed
branch  1 never executed
    #####:  344:          par->nMolWeights[i] = 0.0;
    #####:  345:        par->nMolWeights[0] = 1.0;
    #####:  346:        par->nMolWeights[1] = 1.0;
        -:  347:      }
        -:  348:
        -:  349:    }else{
    #####:  350:      if(!silent){
branch  0 never executed
branch  1 never executed
    #####:  351:        warning("Your choices for par.nMolWeights have been let stand, but it");
call    0 never executed
    #####:  352:        warning("is risky to set them without also setting par.collPartIds.");
call    0 never executed
        -:  353:      }
        -:  354:    }
        -:  355:
        1:  356:  }else if(par->nMolWeights==NULL){ /* We get here only if the user has not supplied these values (or not supplied the right number of them) in their model.c. */
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  357:    if(par->numDensities==1){
branch  0 never executed
branch  1 never executed
    #####:  358:      if(par->collPartIds[0]==CP_H2 || par->collPartIds[0]==CP_p_H2 || par->collPartIds[0]==CP_o_H2){
branch  0 never executed
branch  1 never executed
    #####:  359:        par->nMolWeights = malloc(sizeof(double)*par->numDensities);
    #####:  360:        par->nMolWeights[0] = 1.0;
        -:  361:      }else{
    #####:  362:        if(!silent) bail_out("No H2 collision partner, and user didn't set par.nMolWeights.");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  363:        exit(1);
call    0 never executed
        -:  364:      }
        -:  365:
    #####:  366:    }else if(par->numDensities==2){
branch  0 never executed
branch  1 never executed
    #####:  367:      if((par->collPartIds[0]==CP_p_H2 && par->collPartIds[1]==CP_o_H2)\
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  368:      || (par->collPartIds[1]==CP_p_H2 && par->collPartIds[0]==CP_o_H2)){
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  369:        par->nMolWeights = malloc(sizeof(double)*par->numDensities);
    #####:  370:        for(i=0;i<par->numDensities;i++){
branch  0 never executed
branch  1 never executed
    #####:  371:          par->nMolWeights[i] = 1.0;
        -:  372:        }
        -:  373:
        -:  374:      }else{
    #####:  375:        if(!silent) bail_out("No H2 collision partners, and user didn't set par.nMolWeights.");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  376:        exit(1);
call    0 never executed
        -:  377:      }
        -:  378:
        -:  379:    }else{ /* par->numDensities>2 */
    #####:  380:      par->nMolWeights = malloc(sizeof(double)*par->numDensities);
    #####:  381:      for(i=0;i<par->numDensities;i++){
branch  0 never executed
branch  1 never executed
    #####:  382:        par->nMolWeights[i] = 0.0;
        -:  383:      }
    #####:  384:      par->nMolWeights[0] = 1.0;
    #####:  385:      par->nMolWeights[1] = 1.0;
        -:  386:    }
        -:  387:
    #####:  388:    if(!silent) warning("User didn't set par.nMolWeights, having to guess them.");
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  389:  }
        -:  390:
        -:  391:  /* If we get to here then par->collPartIds has definitely been malloc'd and its values set.
        -:  392:  */
        -:  393://*** check that no par->collPartIds[i] are out of lamda range.
        1:  394:  if(par->collPartNames==NULL){ /* Then load it from the LAMDA names. */
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        1:  395:    par->collPartNames=malloc(sizeof(*par->collPartNames)*par->numDensities);
        2:  396:    for(i=0;i<par->numDensities;i++)
branch  0 taken 50%
branch  1 taken 50% (fallthrough)
        1:  397:      copyInparStr(lamdaNames[par->collPartIds[i]-1], &(par->collPartNames[i]));
call    0 returned 100%
        -:  398:  }
        -:  399:
        1:  400:  if(par->collPartMolWeights==NULL){ /* Then load it from the LAMDA mol weights. */
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        1:  401:    par->collPartMolWeights=malloc(sizeof(*par->collPartMolWeights)*par->numDensities);
        2:  402:    for(i=0;i<par->numDensities;i++)
branch  0 taken 50%
branch  1 taken 50% (fallthrough)
        1:  403:      par->collPartMolWeights[i] = lamdaMolWeights[par->collPartIds[i]-1];
        -:  404:  }
        1:  405:}
        -:  406:
        -:  407:
        -:  408:
        -:  409:
