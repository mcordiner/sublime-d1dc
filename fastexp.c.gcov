        -:    0:Source:src/fastexp.c
        -:    0:Graph:src/fastexp.gcno
        -:    0:Data:src/fastexp.gcda
        -:    0:Runs:1
        -:    1:/*
        -:    2: *  fastexp.c
        -:    3: *  This file is part of LIME, the versatile line modeling engine
        -:    4: *
        -:    5: *  Copyright (C) 2006-2014 Christian Brinch
        -:    6: *  Copyright (C) 2015-2017 The LIME development team
        -:    7: *
        -:    8: */
        -:    9:
        -:   10:#include "lime.h"
        -:   11:
        -:   12:#ifdef FASTEXP
        -:   13:double EXP_TABLE_2D[128][10];
        -:   14:double EXP_TABLE_3D[256][2][10];
        -:   15:/* I've hard-wired the dimensions of these arrays, but it would be better perhaps to declare them as pointers, and calculate the dimensions with the help of the function call:
        -:   16:  calcFastExpRange(FAST_EXP_MAX_TAYLOR, FAST_EXP_NUM_BITS, &numMantissaFields, &lowestExponent, &numExponentsUsed)
        -:   17:*/
        -:   18:
        -:   19:double oneOver_i[FAST_EXP_MAX_TAYLOR+1];
        -:   20:#endif
        -:   21:
        -:   22:double ERF_TABLE[ERF_TABLE_SIZE];
        -:   23:
        -:   24:/*....................................................................*/
function fillErfTable called 1 returned 100% blocks executed 100%
        1:   25:void fillErfTable() {
        -:   26:  int i;
     6146:   27:  for (i=0;i<ERF_TABLE_SIZE;i++) {
branch  0 taken 100%
branch  1 taken 1% (fallthrough)
     6145:   28:    ERF_TABLE[i]=(SQRT_PI/2.)*erf(i*ERF_TABLE_LIMIT/(ERF_TABLE_SIZE-1.));
        -:   29:  }
        1:   30:}
        -:   31:
        -:   32:/*....................................................................*/
        -:   33:double
function geterf called 0 returned 0% blocks executed 0%
    #####:   34:geterf(const double x0, const double x1) {
        -:   35:  /* table lookup erf thingy */
        -:   36:
        -:   37:  double val0=0.,val1=0.;
        -:   38:  
    #####:   39:  if (fabs(x0)>=ERF_TABLE_LIMIT) val0=(SQRT_PI/2.);
branch  0 never executed
branch  1 never executed
        -:   40:  else {
    #####:   41:    int index = (int)(fabs(x0*IBIN_WIDTH));
    #####:   42:    double inter_coeff = (fabs(x0*IBIN_WIDTH)-index);
    #####:   43:    val0=(1-inter_coeff)*ERF_TABLE[index]+inter_coeff*ERF_TABLE[index+1];
        -:   44:  }
    #####:   45:  if (x0<0.) val0=-val0;
branch  0 never executed
branch  1 never executed
        -:   46: 
    #####:   47:  if (fabs(x1)>=ERF_TABLE_LIMIT) val1=(SQRT_PI/2.);
branch  0 never executed
branch  1 never executed
        -:   48:  else {
    #####:   49:    int index = (int)(fabs(x1*IBIN_WIDTH));
    #####:   50:    double inter_coeff = (fabs(x1*IBIN_WIDTH)-index);
    #####:   51:    val1=(1-inter_coeff)*ERF_TABLE[index]+inter_coeff*ERF_TABLE[index+1];
        -:   52:  }
    #####:   53:  if (x1<0.) val1=-val1;
branch  0 never executed
branch  1 never executed
        -:   54:
    #####:   55:  return fabs((val1-val0)/(x1-x0));
        -:   56:}
        -:   57:
        -:   58:/*....................................................................*/
function factorial called 0 returned 0% blocks executed 0%
    #####:   59:int factorial(const int n){
        -:   60:  int i, result;
        -:   61:
        -:   62:  result = 1.0;
       5*:   63:  for(i=1;i<n+1;i++){
branch  0 taken 80%
branch  1 taken 20% (fallthrough)
branch  2 never executed
branch  3 never executed
       4*:   64:    result *= i;
        -:   65:  }
    #####:   66:  return result;
        -:   67:}
        -:   68:
        -:   69:/*....................................................................*/
function taylor called 0 returned 0% blocks executed 0%
    #####:   70:double taylor(const int maxOrder, const float x){
        -:   71:  double result=1.0;
        -:   72:  int i;
        -:   73:
    #####:   74:  for (i=maxOrder;i>0;i--){
branch  0 never executed
branch  1 never executed
    #####:   75:    result = 1.0 + x*result/(double)i;
        -:   76:  }
        -:   77:
    #####:   78:  return result;
        -:   79:}
        -:   80:
        -:   81:/*....................................................................*/
function calcFastExpRange called 1 returned 100% blocks executed 100%
        1:   82:void calcFastExpRange(const int maxTaylorOrder, const int maxNumBitsPerMantField, int *numMantissaFields, int *lowestExponent, int *numExponentsUsed){
        -:   83:  /*
        -:   84:We want to approximate an exponential call exp(-|x|) (where x is a standard, i.e. IEEE 754-format, float) by a look-up table. The scheme proposed makes use of two arrays: a 2D one of shape (J=2^{B-B0},L) and a 3D one of shape (J=2^B,K-1,L), where B is the input argument maxNumBitsPerMantField. The purpose of the present function is to calculate and return B0, K and L, as well as the value of lowestExponent (explained in section 2 below).
        -:   85:
        -:   86:1) The fast-exp lookup algorithm.
        -:   87:=================================
        -:   88:The algorithm makes use of the fact that exp(a+b+c) = exp(a)*exp(b)*exp(c) to return a full precision exponential value via the product of several separate lower-precision lookups. This is done by dividing the mantissa of |x| into K contiguous fields, where K is calculated from
        -:   89:
        -:   90:	K = ceiling(23/B).
        -:   91:
        -:   92:Note that the IEEE 754 standard specifies that the mantissa of a float is 23 bits long. Each of these mantissa fields, considered as an integer, can generate a value for the first index j of the appropriate array. (The 0th field lookup values are in the 2D array, but every other field accesses values in the 3D array.) For field numbers k>0, the second index of the 3D array is found from k-1; and the third index l is taken by treating the bits of the float exponent (bits 1 to 9 in the IEEE 754 standard) as in integer, suitably offset as described below.
        -:   93:
        -:   94:The detailed working of the algorithm is illustrated with an example. We construct an example float x equal to -1.3a07b2x * 2^3. This should have a IEEE 754 bit representation as follows:
        -:   95:
        -:   96:	    seee eeee  emmm mmmm  mmmm mmmm  mmmm mmmm
        -:   97:	x = 1100 0001  0001 1101  0000 0011  1101 1001
        -:   98:
        -:   99:or, in hex,
        -:  100:
        -:  101:	0xc11d03d9
        -:  102:
        -:  103:If we set B=8, that gives the number of fields K=3. We thus divide the mantissa into three fields a, b and c as follows:
        -:  104:
        -:  105:	00111010000001111011001
        -:  106:	aaaaaaabbbbbbbbcccccccc
        -:  107:
        -:  108:Note that field a has only 7 bits, not 8: because 8 does not divide evenly into 23. It is this shorter k=0 field which necessitates the use of a separate array for this field. The value B0 is the number of 'missing' bits in this first field - i.e. =1 in the present case.
        -:  109:
        -:  110:The example above will yield
        -:  111:
        -:  112:	a = 0x1d
        -:  113:	b = 0x03
        -:  114:	c = 0xd9.
        -:  115:
        -:  116:Suppose we construct a new IEEE 754 bit representation for each of these. Starting with 'a', this gives
        -:  117:
        -:  118:	     seee eeee  emmm mmmm  mmmm mmmm  mmmm mmmm
        -:  119:	A0 = 1100 0001  0001 1101  0000 0000  0000 0000
        -:  120:
        -:  121:which is -1.3ax * 2^3 as desired. For 'b' however, if we naively shift the 'b' bit pattern 7 bits to the left, and decrement the exponent by 7, we get
        -:  122:
        -:  123:	     seee eeee  emmm mmmm  mmmm mmmm  mmmm mmmm
        -:  124:	A1 = 1011 1101  1000 0001  1000 0000  0000 0000
        -:  125:
        -:  126:According to the IEEE 754 rules for encoding floats, this is not -0.03x * 2^-4 as we need, but -1.03x * 2^-4. Similar will hold for 'c'. I.e. we left-shift the 'c' bit pattern by 15 bits, decrementing the exponent also by 15, to give
        -:  127:
        -:  128:	     seee eeee  emmm mmmm  mmmm mmmm  mmmm mmmm
        -:  129:	A2 = 1011 1001  1110 1100  1000 0000  0000 0000
        -:  130:
        -:  131:This is not -0.d9x * 2^-12 as we need, but -1.d9x * 2^-12. Thus we must add 1 * 2^{e-7} and 1 * 2^{e-15} to the total afterwards, where e is the original exponent (in the present example = 3). Thus we have
        -:  132:
        -:  133:	x = A0 + (A1 + 1*2^{e-7}) + (A2 + 1*2^{e-15})
        -:  134:
        -:  135:and thus
        -:  136:
        -:  137:	exp(x) = exp(A0)*exp(A1 + 1*2^{e-7})*exp(A2 + 1*2^{e-15}).
        -:  138:
        -:  139:2) Calculating the range of exponents.
        -:  140:======================================
        -:  141:Values of |x| which are smaller than a given cutoff are calculated via a Pth-order Taylor expansion; values greater than another cutoff return a value of zero. Ideally, we set the low-x cutoff to the point at which the absolute value of the next-higher-order Taylor term equals the floating-point precision, and the high-x cutoff to the point where exp(-|x|) reaches the same precision.
        -:  142:
        -:  143:The fractional precision of the lookup table is clearly epsilon=1/2^23, the same precision as an ordinary floating-point number. This will also be approximately the absolute precision sigma for small values of |x| where exp(-|x|) ~ 1. We should choose the low cutoff value x_lo such that the next higher term (P+1th term) of the Taylor series is equal to sigma, i.e.:
        -:  144:
        -:  145:	 |x_lo|^{P+1}      1
        -:  146:	-------------- = ------.
        -:  147:	    {P+1}!        2^23
        -:  148:
        -:  149:Having calculated |x_lo|, we want to find that exponent N_lo of 2 such that 2^N_lo < |x_lo| < 2^{N_lo+1}.
        -:  150:
        -:  151:The second part of the calculation is to find N_hi such that exp(-2^N_hi) < sigma < exp(-2^{N_hi-1}). The number of exponents L which needed is thus 1+N_hi-N_lo.
        -:  152:  */
        -:  153:
        -:  154:  int ieee754NumMantBits=23;
        -:  155:  double sigma, xLo;
        -:  156:  int nLo, nHi;
        -:  157:
        1:  158:  *numMantissaFields = 1+floor(ieee754NumMantBits/(float)maxNumBitsPerMantField);
        -:  159:
        -:  160:  sigma = 1.0/pow(2.,ieee754NumMantBits);
        1:  161:  xLo = pow((double)factorial(maxTaylorOrder+1)*sigma, 1/(double)(maxTaylorOrder+1));
        1:  162:  nLo = floor(log(xLo)/log(2.));
        -:  163:
        -:  164:  /*
        -:  165:	exp(-2^N_hi) < sigma
        -:  166:thus
        -:  167:	2^N_hi > -ln(sigma)
        -:  168:thus
        -:  169:	N_hi > ln(-ln(sigma))/ln(2).
        -:  170:  */
        -:  171:  nHi = 1+floor(log(-log(sigma))/log(2.));
        -:  172:
        1:  173:  *lowestExponent = nLo;
        1:  174:  *numExponentsUsed = 1+nHi-nLo;
        1:  175:}
        -:  176:
        -:  177:#ifdef FASTEXP
        -:  178:/*....................................................................*/
function calcExpTableEntries called 1 returned 100% blocks executed 100%
        1:  179:void calcExpTableEntries(const int maxTaylorOrder, const int maxNumBitsPerMantField){
        -:  180:  /*
        -:  181:See description of the lookup algorithm in function calcFastExpRange().
        -:  182:  */
        -:  183:
        -:  184:  int ieee754ExpOffset=127,ieee754NumMantBits=23;
        -:  185:  int negativeSignMask=0x80000000;
        -:  186:  int numJs,numJs0,numMantissaFields,lowestExponent,numExponentsUsed,exponentOffset,mantShift,bitOffset0,fieldBitOffset,fieldI,j,k,l,exponentMask;
        -:  187:  float argOffset;
        -:  188:  union
        -:  189:  {
        -:  190:    float f;
        -:  191:    int m;
        -:  192:  } floPo;
        -:  193:
        -:  194:  // Should raise an exception here #ifndef FASTEXP?
        -:  195:
        1:  196:  calcFastExpRange(maxTaylorOrder, maxNumBitsPerMantField, &numMantissaFields, &lowestExponent, &numExponentsUsed);
call    0 returned 100%
        -:  197:
        1:  198:  exponentOffset = ieee754ExpOffset + lowestExponent;
        1:  199:  mantShift = ieee754NumMantBits - maxNumBitsPerMantField;
        1:  200:  bitOffset0 = maxNumBitsPerMantField*numMantissaFields - ieee754NumMantBits;
        1:  201:  numJs  = (int)pow(2.,maxNumBitsPerMantField);
        1:  202:  numJs0 = (int)pow(2.,maxNumBitsPerMantField-bitOffset0);
        -:  203:
        -:  204:  fieldBitOffset = 0.0;
       11:  205:  for (l=0;l<numExponentsUsed;l++){
branch  0 taken 91%
branch  1 taken 9% (fallthrough)
        -:  206:    argOffset = 0.0;
       10:  207:    exponentMask = (l+exponentOffset+fieldBitOffset)<<ieee754NumMantBits;
        -:  208:
     1290:  209:    for (j=0;j<numJs0;j++){
branch  0 taken 99%
branch  1 taken 1% (fallthrough)
     1280:  210:      floPo.m = negativeSignMask | exponentMask | (j<<(mantShift+bitOffset0));
     1280:  211:      EXP_TABLE_2D[j][l] = exp(floPo.f + argOffset);
        -:  212:    }
        -:  213:  }
        -:  214:
        3:  215:  for (fieldI=1;fieldI<numMantissaFields;fieldI++){
branch  0 taken 67%
branch  1 taken 33% (fallthrough)
        2:  216:    k = fieldI-1;
        2:  217:    fieldBitOffset = bitOffset0 - fieldI*maxNumBitsPerMantField;
        -:  218:
       22:  219:    for (l=0;l<numExponentsUsed;l++){
branch  0 taken 91%
branch  1 taken 9% (fallthrough)
       20:  220:      argOffset = pow(2.,l+lowestExponent+fieldBitOffset);
       20:  221:      exponentMask = (l+exponentOffset+fieldBitOffset)<<ieee754NumMantBits;
        -:  222:
     5140:  223:      for (j=0;j<numJs;j++){
branch  0 taken 100%
branch  1 taken 1% (fallthrough)
     5120:  224:        floPo.m = negativeSignMask | exponentMask | (j<<mantShift);
     5120:  225:        EXP_TABLE_3D[j][k][l] = exp(floPo.f + argOffset);
        -:  226:      }
        -:  227:    }
        -:  228:  }
        -:  229:
        -:  230:  /*We also construct the table of 1/i to be used for faster calculation of the Taylor approximation.*/
        1:  231:  oneOver_i[0]=0.0;
        4:  232:  for (j=1;j<=FAST_EXP_MAX_TAYLOR;j++) oneOver_i[j]=1.0/(1.0*j);
branch  0 taken 75%
branch  1 taken 25% (fallthrough)
        1:  233:}
        -:  234:
        -:  235:/*....................................................................*/
        -:  236:double
function FastExp called 9839500 returned 100% blocks executed 90%
  9839500:  237:FastExp(const float negarg){
        -:  238:  /*
        -:  239:See description of the lookup algorithm in function calcFastExpRange(). ****NOTE!**** Most numbers here are hard-wired for the sake of speed. If need be, they can be verified (or recalculated for different conditions) via calcExpTableEntries().
        -:  240:  */
        -:  241:  int exponentMask=0x7f800000,ieee754NumMantBits=23;
        -:  242:  int exponentOffset=122,numExponentsUsed=10;
        -:  243:  /*
        -:  244:This value should be calculated from 127+lowestExponent, where 127 is the offset for an exponent of zero laid down in the IEEE 754 standard, and both lowestExponent and numExponentsUsed can be calculated via calcFastExpRange().
        -:  245:
        -:  246:  exponentOffset = ieee754ExpOffset + lowestExponent;
        -:  247:  */
        -:  248:
        -:  249:  int mantMask0=0x007f0000, mantMask1=0x0000ff00, mantMask2=0x000000ff;
        -:  250:  int mantOffset0=16, mantOffset1=8, mantOffset2=0;
        -:  251:  int i,j0,j1,j2,l;
        -:  252:  union
        -:  253:  {
        -:  254:    float f;
        -:  255:    int m;
        -:  256:  } floPo;
        -:  257:  double result;
        -:  258:
        -:  259:  // Should raise an exception here #ifndef FASTEXP?
        -:  260:
 9839500*:  261:  if (negarg<0.0) return exp(-negarg);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
  9839500:  262:  if (negarg==0.0) return 1.0;
branch  0 taken 76% (fallthrough)
branch  1 taken 24%
        -:  263:
  7435708:  264:  floPo.f = negarg;
  7435708:  265:  l = ((floPo.m & exponentMask)>>ieee754NumMantBits)-exponentOffset;
        -:  266:
  7435708:  267:  if (l<0){ // do the Taylor approximation.
branch  0 taken 32%
branch  1 taken 68%
        -:  268:    result = 1.0;
  9507208:  269:    for (i=FAST_EXP_MAX_TAYLOR;i>0;i--){
branch  0 taken 75%
branch  1 taken 25% (fallthrough)
  7130406:  270:      result = 1.0 - negarg*result*oneOver_i[i];
        -:  271:    }
  2376802:  272:    return result;
        -:  273:
  5058906:  274:  }else if(l>=numExponentsUsed){
branch  0 taken 46% (fallthrough)
branch  1 taken 54%
        -:  275:    return 0.0;
        -:  276:  }
        -:  277:
  2308400:  278:  j0 = (floPo.m & mantMask0)>>mantOffset0;
  2308400:  279:  j1 = (floPo.m & mantMask1)>>mantOffset1;
  2308400:  280:  j2 = (floPo.m & mantMask2)>>mantOffset2;
        -:  281:
  2308400:  282:  return (EXP_TABLE_2D[j0]   [l]*
  2308400:  283:          EXP_TABLE_3D[j1][0][l]*
  2308400:  284:          EXP_TABLE_3D[j2][1][l]);
        -:  285:}
        -:  286:#endif
        -:  287:
        -:  288:
