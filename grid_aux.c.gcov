        -:    0:Source:src/grid_aux.c
        -:    0:Graph:src/grid_aux.gcno
        -:    0:Data:src/grid_aux.gcda
        -:    0:Runs:1
        -:    1:/*
        -:    2: *  grid_aux.c
        -:    3: *  This file is part of LIME, the versatile line modeling engine
        -:    4: *
        -:    5: *  Copyright (C) 2006-2014 Christian Brinch
        -:    6: *  Copyright (C) 2015-2017 The LIME development team
        -:    7: *
        -:    8:TODO:
        -:    9: */
        -:   10:
        -:   11:#include "lime.h"
        -:   12:
        -:   13:/*....................................................................*/
function mallocAndSetDefaultGrid called 1 returned 100% blocks executed 89%
        1:   14:void mallocAndSetDefaultGrid(struct grid **gp, const size_t numPoints, const size_t numSpecies){
        -:   15:  size_t i,j;
        -:   16:
        1:   17:  *gp = malloc(sizeof(**gp)*numPoints);
      501:   18:  for(i=0;i<numPoints; i++){
branch  0 taken 100%
branch  1 taken 1% (fallthrough)
      500:   19:    (*gp)[i].v1 = NULL;
      500:   20:    (*gp)[i].v2 = NULL;
      500:   21:    (*gp)[i].v3 = NULL;
      500:   22:    (*gp)[i].dir = NULL;
      500:   23:    (*gp)[i].neigh = NULL;
      500:   24:    (*gp)[i].w = NULL;
      500:   25:    (*gp)[i].ds = NULL;
      500:   26:    (*gp)[i].dens=NULL;
      500:   27:    (*gp)[i].t[0]=-1.0;
      500:   28:    (*gp)[i].t[1]=-1.0;
      500:   29:    (*gp)[i].B[0]=0.0;
      500:   30:    (*gp)[i].B[1]=0.0;
      500:   31:    (*gp)[i].B[2]=0.0;
      500:   32:    (*gp)[i].conv=0;
        -:   33:
      500:   34:    if(numSpecies > 0){
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
      500:   35:      (*gp)[i].mol = malloc(sizeof(*(*gp)[i].mol)*numSpecies);
     1000:   36:      for(j=0;j<numSpecies;j++){
branch  0 taken 50%
branch  1 taken 50%
      500:   37:        (*gp)[i].mol[j].pops        = NULL;
      500:   38:        (*gp)[i].mol[j].specNumDens = NULL;
      500:   39:        (*gp)[i].mol[j].partner     = NULL;
      500:   40:        (*gp)[i].mol[j].cont        = NULL;
      500:   41:        (*gp)[i].mol[j].dopb = 0.0;
      500:   42:        (*gp)[i].mol[j].binv = 0.0;
      500:   43:        (*gp)[i].mol[j].nmol = 0.0;
      500:   44:        (*gp)[i].mol[j].abun = 0.0;
        -:   45:      }
        -:   46:    }else
    #####:   47:      (*gp)[i].mol = NULL;
        -:   48:  }
        1:   49:}
        -:   50:
        -:   51:/*....................................................................*/
function calcGridMolDoppler called 1 returned 100% blocks executed 100%
        1:   52:void calcGridMolDoppler(configInfo *par, molData *md, struct grid *gp){
        -:   53:  int i,id;
        -:   54:
        2:   55:  for(i=0;i<par->nSpecies;i++){
branch  0 taken 50% (fallthrough)
branch  1 taken 50%
        -:   56:    /* Calculate Doppler and thermal line broadening */
      501:   57:    for(id=0;id<par->ncell;id++) {
branch  0 taken 100%
branch  1 taken 1% (fallthrough)
      500:   58:      gp[id].mol[i].dopb = sqrt(gp[id].dopb_turb*gp[id].dopb_turb\
      500:   59:                                + 2.*KBOLTZ/md[i].amass*gp[id].t[0]);
      500:   60:      gp[id].mol[i].binv = 1./gp[id].mol[i].dopb;
        -:   61:    }
        -:   62:  }
        1:   63:}
        -:   64:
        -:   65:/*....................................................................*/
function calcGridMolDensities called 0 returned 0% blocks executed 0%
    #####:   66:void calcGridMolDensities(configInfo *par, struct grid **gp){
        -:   67:  int id,ispec,i;
        -:   68:
    #####:   69:  for(id=0;id<par->ncell;id++){
branch  0 never executed
branch  1 never executed
    #####:   70:    for(ispec=0;ispec<par->nSpecies;ispec++){
branch  0 never executed
branch  1 never executed
    #####:   71:      (*gp)[id].mol[ispec].nmol = 0.0;
    #####:   72:      for(i=0;i<par->numDensities;i++)
branch  0 never executed
branch  1 never executed
    #####:   73:        (*gp)[id].mol[ispec].nmol += (*gp)[id].mol[ispec].abun*(*gp)[id].dens[i]\
    #####:   74:                                    *par->nMolWeights[i];
        -:   75:    }
        -:   76:  }
    #####:   77:}
        -:   78:
        -:   79:/*....................................................................*/
function calcGridMolSpecNumDens called 1 returned 100% blocks executed 100%
        1:   80:void calcGridMolSpecNumDens(configInfo *par, molData *md, struct grid *gp){
        -:   81:  int gi,ispec,ei;
        -:   82:
      501:   83:  for(gi=0;gi<par->ncell;gi++){
branch  0 taken 100% (fallthrough)
branch  1 taken 1%
     1000:   84:    for(ispec=0;ispec<par->nSpecies;ispec++){
branch  0 taken 50% (fallthrough)
branch  1 taken 50%
    13500:   85:      for(ei=0;ei<md[ispec].nlev;ei++){
branch  0 taken 96%
branch  1 taken 4% (fallthrough)
    13000:   86:        gp[gi].mol[ispec].specNumDens[ei] = gp[gi].mol[ispec].binv\
    13000:   87:          *gp[gi].mol[ispec].nmol*gp[gi].mol[ispec].pops[ei];
        -:   88:      }
        -:   89:    }
        -:   90:  }
        1:   91:}
        -:   92:
        -:   93:/*....................................................................*/
        -:   94:void
function delaunay called 0 returned 0% blocks executed 0%
    #####:   95:delaunay(const int numDims, struct grid *gp, const unsigned long numPoints\
    #####:   96:  , const _Bool getCells, _Bool checkSink, struct cell **dc, unsigned long *numCells){
        -:   97:
        -:   98:  /*
        -:   99:The principal purpose of this function is to perform a Delaunay triangulation for the set of points defined by the input argument 'g'. This is achieved via routines in the 3rd-party package qhull.
        -:  100:
        -:  101:A note about qhull nomenclature: a vertex is what you think it is - i.e., a point; but a facet means in this context a Delaunay triangle (in 2D) or tetrahedron (in 3D). This nomenclature arises because the Delaunay cells are indeed facets (or rather projections of facets) of the convex hull constructed in 1 higher dimension.
        -:  102:
        -:  103:Required elements of structs:
        -:  104:	struct grid *gp:
        -:  105:		.id
        -:  106:		.x
        -:  107:
        -:  108:Elements of structs are set as follows:
        -:  109:	struct grid *gp:
        -:  110:		.sink
        -:  111:		.numNeigh
        -:  112:		.neigh (this is malloc'd too large and at present not realloc'd.)
        -:  113:
        -:  114:	cellType *dc (if getCells>0):
        -:  115:		.id
        -:  116:		.neigh
        -:  117:		.vertx
        -:  118:  */
        -:  119:
        -:  120:  coordT *pt_array=NULL;
    #####:  121:  unsigned long ppi,id,pointIdsThisFacet[numDims+1],idI,idJ,fi,ffi;
        -:  122:  int i,j,k;
        -:  123:  char flags[255];
        -:  124:  boolT ismalloc = False;
        -:  125:  vertexT *vertex,**vertexp;
        -:  126:  facetT *facet, *neighbor, **neighborp;
        -:  127:  int curlong, totlong;
        -:  128:  _Bool neighbourNotFound;
        -:  129:  char message[STR_LEN_1];//****[80];
        -:  130:
        -:  131:  /* pt_array contains the grid point locations in the format required by qhull.
        -:  132:  */
    #####:  133:  pt_array=malloc(sizeof(coordT)*numDims*numPoints);
    #####:  134:  for(ppi=0;ppi<numPoints;ppi++) {
branch  0 never executed
branch  1 never executed
    #####:  135:    for(j=0;j<numDims;j++) {
branch  0 never executed
branch  1 never executed
    #####:  136:      pt_array[ppi*numDims+j]=gp[ppi].x[j];
        -:  137:    }
        -:  138:  }
        -:  139:
        -:  140:  /* Run qhull to generate the Delaunay mesh. (After this, all the information of importance is stored in variables defined in the qhull header.)
        -:  141:  */
    #####:  142:  sprintf(flags,"qhull d Qbb Qt");
    #####:  143:  if (qh_new_qhull(numDims, (int)numPoints, pt_array, ismalloc, flags, NULL, NULL)) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  144:    if(!silent) bail_out("Qhull failed to triangulate");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  145:    exit(1);
call    0 never executed
        -:  146:  }
        -:  147:
    #####:  148:  if(checkSink){
branch  0 never executed
branch  1 never executed
    #####:  149:    FORALLfacets {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  150:      if(!facet->upperdelaunay){
branch  0 never executed
branch  1 never executed
    #####:  151:        FOREACHneighbor_(facet) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  152:          if(neighbor->upperdelaunay){ /* This should indicate that facet lies on the edge of the model. */
branch  0 never executed
branch  1 never executed
    #####:  153:            FOREACHvertex_(neighbor->vertices){
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  154:              ppi = (unsigned long)qh_pointid(vertex->point);
call    0 never executed
    #####:  155:              if(ppi<numPoints)
branch  0 never executed
branch  1 never executed
    #####:  156:                gp[ppi].sink = 1;
        -:  157:            }
        -:  158:          }
        -:  159:        }
        -:  160:      }
        -:  161:    }
        -:  162:  }
        -:  163:
        -:  164:  /* Malloc .neigh for each grid point. At present it is not known how many neighbours a point will have, so all the mallocs are larger than needed.
        -:  165:  */
    #####:  166:  FORALLvertices {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  167:    id=(unsigned long)qh_pointid(vertex->point);
call    0 never executed
        -:  168:    /* Note this is NOT the same value as vertex->id. Only the id gained via the call to qh_pointid() is the same as the index of the point in the input list. */
        -:  169:
    #####:  170:    gp[id].numNeigh=qh_setsize(vertex->neighbors);
call    0 never executed
        -:  171:    /* Note that vertex->neighbors refers to facets abutting the vertex, not other vertices. In general there seem to be more facets surrounding a point than vertices (in fact there seem to be exactly 2x as many). In any case, mallocing to N_facets gives extra room. */
        -:  172:
    #####:  173:    if(gp[id].numNeigh<=0){
branch  0 never executed
branch  1 never executed
    #####:  174:      if(!silent){
branch  0 never executed
branch  1 never executed
    #####:  175:        snprintf(message, STR_LEN_1, "qhull failed silently, grid point %lu has 0 neighbours. Smoother gridDensity() might help.", id);
    #####:  176:        bail_out(message);
call    0 never executed
        -:  177:      }
    #####:  178:exit(1);
call    0 never executed
        -:  179:    }
        -:  180:
    #####:  181:    free(gp[id].neigh);
    #####:  182:    gp[id].neigh=malloc(sizeof(struct grid *)*gp[id].numNeigh);
    #####:  183:    for(k=0;k<gp[id].numNeigh;k++) {
branch  0 never executed
branch  1 never executed
    #####:  184:      gp[id].neigh[k]=NULL;
        -:  185:    }
        -:  186:  }
        -:  187:
        -:  188:  /* Identify the Delaunay neighbors of each point. This is a little involved, because the only direct information we have about which vertices are linked to which others is stored in qhull's facetT objects.
        -:  189:  */
    #####:  190:  *numCells = 0;
    #####:  191:  FORALLfacets {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  192:    if (!facet->upperdelaunay) {
branch  0 never executed
branch  1 never executed
        -:  193:      /* Store the point IDs in a list for convenience. These ID values are conveniently ordered such that qh_pointid() returns ppi for gp[ppi]. 
        -:  194:      */
        -:  195:      j=0;
    #####:  196:      FOREACHvertex_ (facet->vertices) pointIdsThisFacet[j++]=(unsigned long)qh_pointid(vertex->point);
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
        -:  197:
    #####:  198:      for(i=0;i<numDims+1;i++){
branch  0 never executed
branch  1 never executed
    #####:  199:        idI = pointIdsThisFacet[i];
    #####:  200:        for(j=0;j<numDims+1;j++){
branch  0 never executed
branch  1 never executed
    #####:  201:          idJ = pointIdsThisFacet[j];
    #####:  202:          if(i!=j){
branch  0 never executed
branch  1 never executed
        -:  203:            /* Cycle through all the non-NULL links of gp[idI], storing the link if it is new.
        -:  204:            */
        -:  205:            k=0;
    #####:  206:            while(gp[idI].neigh[k] != NULL && gp[idI].neigh[k]->id != gp[idJ].id)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  207:              k++;
    #####:  208:            gp[idI].neigh[k]=&gp[idJ];
        -:  209:          }
        -:  210:        }
        -:  211:      }
    #####:  212:      (*numCells)++;
        -:  213:    }
        -:  214:  }
        -:  215:
        -:  216:  /* Count the actual number of neighbours per point.
        -:  217:  */
    #####:  218:  for(ppi=0;ppi<numPoints;ppi++){
branch  0 never executed
branch  1 never executed
        -:  219:    j=0;
    #####:  220:    for(k=0;k<gp[ppi].numNeigh;k++){
branch  0 never executed
branch  1 never executed
    #####:  221:      if(gp[ppi].neigh[k] != NULL)
branch  0 never executed
branch  1 never executed
    #####:  222:        j++;
        -:  223:    }
    #####:  224:    gp[ppi].numNeigh=j;
        -:  225:  }
        -:  226:
    #####:  227:  if(getCells){
branch  0 never executed
branch  1 never executed
    #####:  228:    (*dc) = malloc(sizeof(**dc)*(*numCells));
        -:  229:    fi = 0;
    #####:  230:    FORALLfacets {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  231:      if (!facet->upperdelaunay) {
branch  0 never executed
branch  1 never executed
    #####:  232:        (*dc)[fi].id = (unsigned long)facet->id; /* Do NOT expect this to be equal to fi. */
    #####:  233:        fi++;
        -:  234:      }
        -:  235:    }
        -:  236:
        -:  237:    fi = 0;
    #####:  238:    FORALLfacets {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  239:      if (!facet->upperdelaunay) {
branch  0 never executed
branch  1 never executed
        -:  240:        i = 0;
    #####:  241:        FOREACHneighbor_(facet) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  242:          if(neighbor->upperdelaunay){
branch  0 never executed
branch  1 never executed
    #####:  243:            (*dc)[fi].neigh[i] = NULL;
        -:  244:          }else{
        -:  245:            /* Have to find the member of *dc with the same id as neighbour.*/
        -:  246:            ffi = 0;
        -:  247:            neighbourNotFound=1;
    #####:  248:            while(ffi<(*numCells) && neighbourNotFound){
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  249:              if((*dc)[ffi].id==(unsigned long)neighbor->id){
branch  0 never executed
branch  1 never executed
    #####:  250:                (*dc)[fi].neigh[i] = &(*dc)[ffi];
        -:  251:                neighbourNotFound = 0;
        -:  252:              }
    #####:  253:              ffi++;
        -:  254:            }
    #####:  255:            if(ffi>=(*numCells) && neighbourNotFound){
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  256:              if(!silent){
branch  0 never executed
branch  1 never executed
    #####:  257:                snprintf(message, STR_LEN_1, "Something weird going on. Cannot find a cell with ID %lu", (unsigned long)(neighbor->id));
    #####:  258:                bail_out(message);
call    0 never executed
        -:  259:              }
    #####:  260:exit(1);
call    0 never executed
        -:  261:            }
        -:  262:          }
    #####:  263:          i++;
        -:  264:        }
        -:  265:
        -:  266:        i = 0;
    #####:  267:        FOREACHvertex_( facet->vertices ) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  268:          id = (unsigned long)qh_pointid(vertex->point);
call    0 never executed
    #####:  269:          (*dc)[fi].vertx[i] = &gp[id];
    #####:  270:          i++;
        -:  271:        }
        -:  272:
    #####:  273:        fi++;
        -:  274:      }
        -:  275:    }
        -:  276:  }
        -:  277:
    #####:  278:  qh_freeqhull(!qh_ALL);
call    0 never executed
    #####:  279:  qh_memfreeshort (&curlong, &totlong);
call    0 never executed
    #####:  280:  free(pt_array);
    #####:  281:}
        -:  282:
        -:  283:/*....................................................................*/
        -:  284:unsigned long
function reorderGrid called 0 returned 0% blocks executed 0%
    #####:  285:reorderGrid(const unsigned long numPoints, struct grid *gp){
        -:  286:  /*
        -:  287:The algorithm works its way up the list of points with one index and down with another. The 'up' travel stops at the 1st sink point it finds, the 'down' at the 1st non-sink point. If at that point the 'up' index is lower in value than the 'down', the points are swapped. This is just a tiny bit tricky because we also need to make sure all the neigh pointers are swapped. That's why we make an ordered list of indices and perform the swaps on that as well.
        -:  288:  */
        -:  289:
    #####:  290:  unsigned long indices[numPoints],upI,dnI,nExtraSinks=0,i,ngi;
        -:  291:  int j;
        -:  292:  struct grid tempGp;
        -:  293:
    #####:  294:  for(upI=0;upI<numPoints;upI++) indices[upI] = upI;
branch  0 never executed
branch  1 never executed
        -:  295:
        -:  296:  upI = 0;
    #####:  297:  dnI = numPoints-1;
        -:  298:  while(1){
    #####:  299:    while(upI<numPoints && !gp[upI].sink) upI++;
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  300:    while(dnI>=0        &&  gp[dnI].sink) dnI--;
branch  0 never executed
branch  1 never executed
        -:  301:
    #####:  302:  if(upI>=dnI) break;
branch  0 never executed
branch  1 never executed
        -:  303:
    #####:  304:    nExtraSinks++;
        -:  305:
    #####:  306:    i = indices[dnI];
    #####:  307:    indices[dnI] = indices[upI];
    #####:  308:    indices[upI] = i;
        -:  309:
    #####:  310:    tempGp = gp[dnI];
    #####:  311:    gp[dnI] = gp[upI];
    #####:  312:    gp[upI] = tempGp;
        -:  313:
        -:  314:    /* However we want to retain the .id values as sequential.
        -:  315:    */
    #####:  316:    gp[dnI].id = dnI;
    #####:  317:    gp[upI].id = upI;
        -:  318:  }
        -:  319:
        -:  320:  /*
        -:  321:Now we sort out the .neigh values. An example of how this should work is as follows. Suppose we swapped points 30 and 41. We have fixed up the .id values, but the swap is still shown in the 'indices' array. Thus we will have
        -:  322:
        -:  323:	gp[30].id == 30 (but all the other data is from 41)
        -:  324:	gp[41].id == 41 (but all the other data is from 30)
        -:  325:	indices[30] == 41
        -:  326:	indices[41] == 30
        -:  327:
        -:  328:Suppose further that the old value of gp[i].neigh[j] is &gp[30]. We detect that we need to fix it (change it to &gp[41]) because ngi=&gp[30].id=30 != indices[ngi=30]=41. gp[i].neigh[j] is then reset to &gp[indices[30]] = &gp[41], i.e. to point to the same data as used to be in location 30.
        -:  329:  */
    #####:  330:  for(i=0;i<numPoints;i++){
branch  0 never executed
branch  1 never executed
    #####:  331:    for(j=0;j<gp[i].numNeigh;j++){
branch  0 never executed
branch  1 never executed
    #####:  332:      ngi = (unsigned long)gp[i].neigh[j]->id;
    #####:  333:      if(ngi != indices[ngi])
branch  0 never executed
branch  1 never executed
    #####:  334:        gp[i].neigh[j] = &gp[indices[ngi]];
        -:  335:    }
        -:  336:  }
        -:  337:
    #####:  338:  return nExtraSinks;
        -:  339:}
        -:  340:
        -:  341:/*....................................................................*/
function distCalc called 0 returned 0% blocks executed 0%
    #####:  342:void distCalc(configInfo *par, struct grid *gp){
        -:  343:  int i,k,l;
        -:  344:
    #####:  345:  for(i=0;i<par->ncell;i++){
branch  0 never executed
branch  1 never executed
    #####:  346:    free(gp[i].dir);
    #####:  347:    free(gp[i].ds);
    #####:  348:    gp[i].dir=malloc(sizeof(*(gp[i].dir)) *gp[i].numNeigh);
    #####:  349:    gp[i].ds =malloc(sizeof(double)*gp[i].numNeigh);
    #####:  350:    memset(gp[i].dir, 0., sizeof(*(gp[i].dir)) * gp[i].numNeigh);
    #####:  351:    memset(gp[i].ds, 0., sizeof(double) * gp[i].numNeigh);
    #####:  352:    for(k=0;k<gp[i].numNeigh;k++){
branch  0 never executed
branch  1 never executed
    #####:  353:      for(l=0;l<3;l++)
branch  0 never executed
branch  1 never executed
    #####:  354:        gp[i].dir[k].x[l] = gp[i].neigh[k]->x[l] - gp[i].x[l];
        -:  355:
    #####:  356:      gp[i].ds[k] = sqrt(  gp[i].dir[k].x[0]*gp[i].dir[k].x[0]\
    #####:  357:                         + gp[i].dir[k].x[1]*gp[i].dir[k].x[1]\
    #####:  358:                         + gp[i].dir[k].x[2]*gp[i].dir[k].x[2]);
        -:  359:
    #####:  360:      for(l=0;l<3;l++)
branch  0 never executed
branch  1 never executed
    #####:  361:        gp[i].dir[k].xn[l] = gp[i].dir[k].x[l]/gp[i].ds[k];
        -:  362:    }
    #####:  363:    gp[i].nphot=RAYS_PER_POINT;
        -:  364:  }
    #####:  365:}
        -:  366:
        -:  367:
        -:  368:/*....................................................................*/
        -:  369:void
function write_VTK_unstructured_Points called 1 returned 100% blocks executed 85%
        1:  370:write_VTK_unstructured_Points(configInfo *par, struct grid *g){
        -:  371:  FILE *fp;
        -:  372:  double length;
        -:  373:  int i,j,l=0;
        -:  374:  char flags[255];
        -:  375:  boolT ismalloc = False;
        -:  376:  facetT *facet;
        -:  377:  vertexT *vertex,**vertexp;
        -:  378:  coordT *pt_array;
        -:  379:  int curlong, totlong;
        -:  380:
        1:  381:  pt_array=malloc(sizeof(coordT)*DIM*par->ncell);
        -:  382:
      501:  383:  for(i=0;i<par->ncell;i++) {
branch  0 taken 100% (fallthrough)
branch  1 taken 1%
     2000:  384:    for(j=0;j<DIM;j++) {
branch  0 taken 75%
branch  1 taken 25% (fallthrough)
     1500:  385:      pt_array[i*DIM+j]=g[i].x[j];
        -:  386:    }
        -:  387:  }
        -:  388:
        1:  389:  if((fp=fopen(par->gridfile, "w"))==NULL){
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:  390:    if(!silent) bail_out("Error writing grid file!");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  391:    exit(1);
call    0 never executed
        -:  392:  }
        1:  393:  fprintf(fp,"# vtk DataFile Version 3.0\n");
call    0 returned 100%
        1:  394:  fprintf(fp,"Lime grid\n");
call    0 returned 100%
        1:  395:  fprintf(fp,"ASCII\n");
call    0 returned 100%
        1:  396:  fprintf(fp,"DATASET UNSTRUCTURED_GRID\n");
call    0 returned 100%
        1:  397:  fprintf(fp,"POINTS %d float\n",par->ncell);
call    0 returned 100%
      501:  398:  for(i=0; i<par->ncell; i++) {
branch  0 taken 100%
branch  1 taken 1% (fallthrough)
      500:  399:    fprintf(fp,"%e %e %e\n", g[i].x[0], g[i].x[1], g[i].x[2]);
call    0 returned 100%
        -:  400:  }
        1:  401:  fprintf(fp, "\n");
call    0 returned 100%
        -:  402:
        1:  403:  sprintf(flags,"qhull d Qbb T0");
        -:  404:
        1:  405:  fprintf(fp,"\nCELL_TYPES %d\n",l);
call    0 returned 100%
        -:  406:  for(i=0;i<l;i++){
        -:  407:    fprintf(fp, "10\n");
        -:  408:  }
        1:  409:  fprintf(fp,"POINT_DATA %d\n",par->ncell);
call    0 returned 100%
        1:  410:  fprintf(fp,"SCALARS H2_density float 1\n");
call    0 returned 100%
        1:  411:  fprintf(fp,"LOOKUP_TABLE default\n");
call    0 returned 100%
      501:  412:  for(i=0;i<par->ncell;i++){
branch  0 taken 100%
branch  1 taken 1% (fallthrough)
      500:  413:    fprintf(fp, "%e\n", g[i].dens[0]);
call    0 returned 100%
        -:  414:  }
        1:  415:  fprintf(fp,"SCALARS Mol_density float 1\n");
call    0 returned 100%
        1:  416:  fprintf(fp,"LOOKUP_TABLE default\n");
call    0 returned 100%
        1:  417:  if(par->nSpecies>0){
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
      501:  418:    for(i=0;i<par->ncell;i++){
branch  0 taken 100%
branch  1 taken 1%
      500:  419:      fprintf(fp, "%e\n", g[i].mol[0].abun*g[i].dens[0]);
call    0 returned 100%
        -:  420:    }
        -:  421:  }else{
    #####:  422:    for(i=0;i<par->ncell;i++){
branch  0 never executed
branch  1 never executed
    #####:  423:      fprintf(fp, "%e\n", 0.0);
call    0 never executed
        -:  424:    }
        -:  425:  }
        1:  426:  fprintf(fp,"SCALARS Gas_temperature float 1\n");
call    0 returned 100%
        1:  427:  fprintf(fp,"LOOKUP_TABLE default\n");
call    0 returned 100%
      501:  428:  for(i=0;i<par->ncell;i++){
branch  0 taken 100%
branch  1 taken 1% (fallthrough)
      500:  429:    fprintf(fp, "%e\n", g[i].t[0]);
call    0 returned 100%
        -:  430:  }
        1:  431:  fprintf(fp,"VECTORS velocity float\n");
call    0 returned 100%
      501:  432:  for(i=0;i<par->ncell;i++){
branch  0 taken 100%
branch  1 taken 1% (fallthrough)
      500:  433:    length=sqrt(g[i].vel[0]*g[i].vel[0]+g[i].vel[1]*g[i].vel[1]+g[i].vel[2]*g[i].vel[2]);
      500:  434:    if(length > 0.){
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
      500:  435:      fprintf(fp, "%e %e %e\n", g[i].vel[0]/length,g[i].vel[1]/length,g[i].vel[2]/length);
call    0 returned 100%
        -:  436:    } else {
    #####:  437:      fprintf(fp, "%e %e %e\n", g[i].vel[0],g[i].vel[1],g[i].vel[2]);
call    0 never executed
        -:  438:    }
        -:  439:  }
        -:  440:
        1:  441:  fclose(fp);
call    0 returned 100%
        1:  442:  free(pt_array);
        1:  443:}
        -:  444:
        -:  445:/*....................................................................*/
        -:  446:void
function getEdgeVelocities called 0 returned 0% blocks executed 0%
    #####:  447:getEdgeVelocities(configInfo *par, struct grid *gp){
        -:  448:  int i,k,j,l;
        -:  449:  double vel[3], x[3];
        -:  450:  
    #####:  451:  for(i=0;i<par->ncell;i++){
branch  0 never executed
branch  1 never executed
    #####:  452:    gp[i].v1=malloc(3*gp[i].numNeigh*sizeof(double));
    #####:  453:    gp[i].v2=malloc(3*gp[i].numNeigh*sizeof(double));
    #####:  454:    gp[i].v3=malloc(3*gp[i].numNeigh*sizeof(double));
        -:  455:
    #####:  456:    for(k=0;k<gp[i].numNeigh;k++){
branch  0 never executed
branch  1 never executed
    #####:  457:      for(j=0;j<3;j++) x[j]=gp[i].x[j];		
branch  0 never executed
branch  1 never executed
    #####:  458:      for(l=0;l<5;l++){
branch  0 never executed
branch  1 never executed
    #####:  459:        velocity(x[0],x[1],x[2],vel);	
call    0 never executed
        -:  460:
    #####:  461:        if (l==1) {
branch  0 never executed
branch  1 never executed
    #####:  462:	  gp[i].v1[3*k]=vel[0]; gp[i].v1[3*k+1]=vel[1]; gp[i].v1[3*k+2]=vel[2];
        -:  463:        }
    #####:  464:        if (l==2) {
branch  0 never executed
branch  1 never executed
    #####:  465:          gp[i].v2[3*k]=vel[0]; gp[i].v2[3*k+1]=vel[1]; gp[i].v2[3*k+2]=vel[2];
        -:  466:        }
    #####:  467:        if (l==3) {
branch  0 never executed
branch  1 never executed
    #####:  468:          gp[i].v3[3*k]=vel[0]; gp[i].v3[3*k+1]=vel[1]; gp[i].v3[3*k+2]=vel[2];
        -:  469:        }
        -:  470:		
    #####:  471:        for(j=0;j<3;j++) x[j]=x[j]+(gp[i].dir[k].xn[j]*gp[i].ds[k])/4.;
branch  0 never executed
branch  1 never executed
        -:  472:      }
        -:  473:    }
        -:  474:  }
        -:  475:
    #####:  476:  par->edgeVelsAvailable = 1;
    #####:  477:}
        -:  478:
        -:  479:/*....................................................................*/
function setupAndWriteGrid called 0 returned 0% blocks executed 0%
    #####:  480:int setupAndWriteGrid(configInfo *par, struct grid *gp, molData *md, char *outFileName){
        -:  481:  // I removed an unused function from this function
        -:  482:  int status = 0;
    #####:  483:  return status;
        -:  484:}
        -:  485:
        -:  486:/*....................................................................*/
function writeGridIfRequired called 5 returned 100% blocks executed 67%
        5:  487:void writeGridIfRequired(configInfo *par, struct grid *gp, molData *md, const int dataStageI){
        5:  488:  if(par->writeGridAtStage[dataStageI-1]){
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  489:    int status=0;
        -:  490:    char message[80];
        -:  491:
        -:  492:    status = setupAndWriteGrid(par, gp, md, par->gridOutFiles[dataStageI-1]);
        -:  493:
        -:  494:    if(status){
        -:  495:      sprintf(message, "writeGrid at data stage %d returned with status %d", dataStageI, status);
        -:  496:      if(!silent) bail_out(message);
        -:  497:exit(1);
        -:  498:    }
        -:  499:  }
        5:  500:}
